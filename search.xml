<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础篇</title>
      <link href="/article/337fcc87.html"/>
      <url>/article/337fcc87.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><img src="/" alt="image-20220520183647583"></p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220515104738398.png" alt="image-20220515104738398"></p><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h1><blockquote><p><strong>该部分内容包括:</strong></p><ol><li>mysql的下载及安装</li><li>MySQL的启动</li><li>MySQL的客户端连接</li></ol></blockquote><h2 id="2-1-Ubuntu"><a href="#2-1-Ubuntu" class="headerlink" title="2.1 Ubuntu"></a>2.1 Ubuntu</h2><ul><li>更新apt源</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ul><li>安装MySQL-Server</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server-8.0</span><br></pre></td></tr></table></figure><ul><li>查看MySQL是否成功启动</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><ul><li>其它常用命令</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动mysql服务</span></span><br><span class="line"> sudo service mysql start</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 关闭Mysql服务</span></span><br><span class="line"> sudo service mysql stop</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 重启Mysql服务</span></span><br><span class="line"> sudo service mysql restart</span><br></pre></td></tr></table></figure><ul><li>sql命令</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库编码 </span></span><br><span class="line"> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;char%&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 更改密码</span></span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;root123&#x27;</span>), PLUGIN<span class="operator">=</span><span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 重启mysql 服务</span></span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h2 id="2-2-Docker"><a href="#2-2-Docker" class="headerlink" title="2.2 Docker"></a>2.2 Docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dit --name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:8.0</span><br></pre></td></tr></table></figure><h1 id="3-DDL（数据定义语言）"><a href="#3-DDL（数据定义语言）" class="headerlink" title="3 DDL（数据定义语言）"></a>3 DDL（数据定义语言）</h1><h2 id="3-1-数据库操作"><a href="#3-1-数据库操作" class="headerlink" title="3.1 数据库操作"></a>3.1 数据库操作</h2><ul><li>查询  所有数据库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> database;</span><br></pre></td></tr></table></figure><ul><li>查询当前数据库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><ul><li>创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] 数据库名 [ <span class="keyword">DEFAULT</span> CHARSET 字符集(utf8mb4)] [<span class="keyword">COLLATE</span> 排序规则 ];</span><br></pre></td></tr></table></figure><blockquote><p>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</p></blockquote><ul><li>删除数据库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [ IF <span class="keyword">EXISTS</span> ] 数据库名; </span><br></pre></td></tr></table></figure><ul><li>使用数据库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;  </span><br></pre></td></tr></table></figure><h2 id="3-2-表操作"><a href="#3-2-表操作" class="headerlink" title="3.2 表操作"></a>3.2 表操作</h2><ul><li>查询当前数据库所有表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><ul><li>查询表结构</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>查询指定表~的建表语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>创建表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br></pre></td></tr></table></figure><hr><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220515165438113.png" alt="image-20220515165438113"></p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220515170410370.png" alt="image-20220515170410370"></p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220515165942827.png" alt="image-20220515165942827"></p><blockquote><p><strong>注意:</strong> 最后一个字段后面没有逗号</p></blockquote><ul><li>添加字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 类型(长度) [comment 字段注释] [约束];</span><br></pre></td></tr></table></figure><ul><li>修改字段的数据类型：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><ul><li>修改字段名和字 段类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><ul><li>删除字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure><ul><li>修改表名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新表名; </span><br></pre></td></tr></table></figure><ul><li>删除表<br><code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除表，并重新创建该表<br><code>TRUNCATE TABLE 表名;</code></li></ul><h1 id="4-DML（数据操作语言）"><a href="#4-DML（数据操作语言）" class="headerlink" title="4 DML（数据操作语言）"></a>4 DML（数据操作语言）</h1><h2 id="4-1-添加数据"><a href="#4-1-添加数据" class="headerlink" title="4.1 添加数据"></a>4.1 添加数据</h2><ul><li>指定字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)[,(值<span class="number">1</span>,值<span class="number">2</span>)...];</span><br></pre></td></tr></table></figure><ul><li>全部字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>)[,(值<span class="number">1</span>,值<span class="number">2</span>)...];</span><br></pre></td></tr></table></figure><blockquote><p>**注意:**字符串和日期类型数据应该包含在引号中</p></blockquote><h2 id="4-2-修改数据"><a href="#4-2-修改数据" class="headerlink" title="4.2 修改数据"></a>4.2 修改数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>  <span class="keyword">where</span> 条件 ;</span><br></pre></td></tr></table></figure><h2 id="4-3-删除数据"><a href="#4-3-删除数据" class="headerlink" title="4.3 删除数据"></a>4.3 删除数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名  <span class="keyword">WHERE</span> 条件 ;</span><br></pre></td></tr></table></figure><h1 id="5-DQL（数据查询语言）"><a href="#5-DQL（数据查询语言）" class="headerlink" title="5 DQL（数据查询语言）"></a>5 DQL（数据查询语言）</h1><p>单表查询的语法结构如下: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名字段</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后的条件列表  </span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><h2 id="5-1-基础查询"><a href="#5-1-基础查询" class="headerlink" title="5.1 基础查询"></a>5.1 基础查询</h2><ul><li>查询多个字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>, 字段<span class="number">3</span>, ... <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>设置别名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [ <span class="keyword">AS</span> 别名<span class="number">1</span> ], 字段<span class="number">2</span> [ <span class="keyword">AS</span> 别名<span class="number">2</span> ], 字段<span class="number">3</span> [ <span class="keyword">AS</span> 别名<span class="number">3</span> ], ... <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [ 别名<span class="number">1</span> ], 字段<span class="number">2</span> [ 别名<span class="number">2</span> ], 字段<span class="number">3</span> [ 别名<span class="number">3</span> ], ... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>去除重复记录</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>转义字符:<code>/</code></p></blockquote><h2 id="5-2-条件查询"><a href="#5-2-条件查询" class="headerlink" title="5.2 条件查询"></a>5.2 条件查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220515193502779.png" alt="image-20220515193502779"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 年龄等于30</span><br><span class="line">select * from employee where age = 30;</span><br><span class="line">-- 年龄小于30</span><br><span class="line">select * from employee where age &lt; 30;</span><br><span class="line">-- 小于等于</span><br><span class="line">select * from employee where age &lt;= 30;</span><br><span class="line">-- 没有身份证</span><br><span class="line">select * from employee where idcard is null or idcard = &#x27;&#x27;;</span><br><span class="line">-- 有身份证</span><br><span class="line">select * from employee where idcard;</span><br><span class="line">select * from employee where idcard is not null;</span><br><span class="line">-- 不等于</span><br><span class="line">select * from employee where age != 30;</span><br><span class="line">-- 年龄在20到30之间</span><br><span class="line">select * from employee where age between 20 and 30;</span><br><span class="line">select * from employee where age &gt;= 20 and age &lt;= 30;</span><br><span class="line">-- 下面语句不报错，但查不到任何信息</span><br><span class="line">select * from employee where age between 30 and 20;</span><br><span class="line">-- 性别为女且年龄小于30</span><br><span class="line">select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;</span><br><span class="line">-- 年龄等于25或30或35</span><br><span class="line">select * from employee where age = 25 or age = 30 or age = 35;</span><br><span class="line">select * from employee where age in (25, 30, 35);</span><br><span class="line">-- 姓名为两个字</span><br><span class="line">select * from employee where name like &#x27;__&#x27;;</span><br><span class="line">-- 身份证最后为X</span><br><span class="line">select * from employee where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure><h2 id="5-3-聚合查询"><a href="#5-3-聚合查询" class="headerlink" title="5.3 聚合查询"></a>5.3 聚合查询</h2><table><thead><tr><th>聚合函数</th><th>功能</th></tr></thead><tbody><tr><td>count(字段)</td><td>统计记录的数量</td></tr><tr><td>max(字段)</td><td>最大值</td></tr><tr><td>min(字段)</td><td>最小值</td></tr><tr><td>avg(字段)</td><td>平均值</td></tr><tr><td>sum(字段)</td><td>求和</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> <code>null</code>值不参与所有聚合函数运算。</p></blockquote><h2 id="5-4-分组查询"><a href="#5-4-分组查询" class="headerlink" title="5.4 分组查询"></a>5.4 分组查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [ <span class="keyword">where</span> 条件 ] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [ <span class="keyword">having</span> 分组后的过滤条件 ];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span><br><span class="line">select count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性数量</span><br><span class="line">select gender, count(*) from employee group by gender;</span><br><span class="line">-- 根据性别分组，统计男性和女性的平均年龄</span><br><span class="line">select gender, avg(age) from employee group by gender;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组</span><br><span class="line">select workaddress, count(*) from employee where age &lt; 45 group by workaddress;</span><br><span class="line">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</span><br></pre></td></tr></table></figure><blockquote><p><strong>where 和 having 的区别：</strong></p><ul><li>执行时机不同：where是分组之<strong>前</strong>进行过滤，不满足where条件不参与分组；having是分组** **对结果进行过滤。</li><li>判断条件不同：<strong>where不能对聚合函数进行判断，而having可以。</strong></li></ul><p><strong>注意事项</strong></p><ul><li>执行顺序：where &gt; 聚合函数 &gt; <strong>having</strong></li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul></blockquote><h2 id="5-5-排序查询"><a href="#5-5-排序查询" class="headerlink" title="5.5 排序查询"></a>5.5 排序查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>排序方式：</p><ul><li>ASC: 升序（默认，即<strong>从小到大</strong>）</li><li>DESC: 降序，从大到小</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据年龄升序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC;</span><br><span class="line">SELECT * FROM employee ORDER BY age;</span><br><span class="line">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span><br><span class="line">SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong>:</p><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p></blockquote><h2 id="5-6-分页查询"><a href="#5-6-分页查询" class="headerlink" title="5.6 分页查询"></a>5.6 分页查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数;`</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询第一页数据，展示10条</span><br><span class="line">SELECT * FROM employee LIMIT 0, 10;</span><br><span class="line">-- 查询第二页</span><br><span class="line">SELECT * FROM employee LIMIT 10, 10;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p><ul><li>起始索引从0开始，<strong>起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</strong></li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><p><strong>DQL执行顺序</strong>(<code>重要</code> )</p><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; <strong>LIMIT</strong></p><p>如下sql语句是不能正常执行的：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.name <span class="keyword">as</span> ename,e.age <span class="keyword">as</span> eage <span class="keyword">from</span> emp <span class="keyword">as</span> e <span class="keyword">where</span> eage<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure></blockquote><h1 id="6-DCL（数据控制语言）"><a href="#6-DCL（数据控制语言）" class="headerlink" title="6 DCL（数据控制语言）"></a>6 DCL（数据控制语言）</h1><p>MySQL中所有的用户都放在<code>mysql</code>这一数据库中。</p><h2 id="6-1-管理用户"><a href="#6-1-管理用户" class="headerlink" title="6.1 管理用户"></a>6.1 管理用户</h2><ul><li>通过如下语句可以查看所有用户信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><ul><li>创建用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>修改用户密码</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>主机名可以使用<code>%</code>来作为通配符，即表示任意主机。</p></blockquote><h2 id="6-2-权限控制"><a href="#6-2-权限控制" class="headerlink" title="6.2 权限控制"></a>6.2 权限控制</h2><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修 改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表<br /></td></tr></tbody></table><blockquote><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p></blockquote><ul><li>查询指定用户的权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grant</span> <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>授予某个用户对某个表的权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>撤销用户权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;`</span><br></pre></td></tr></table></figure><blockquote><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul></blockquote><h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h1><p>函数是指一段可以直接被另一段程序调用的程序或代码。 也就意味着,这一段程序或代码MySQL中已经给我们提供了,我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。</p><p>MySQL中的函数主要分为以下四类: 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="7-1-字符串函数"><a href="#7-1-字符串函数" class="headerlink" title="7.1 字符串函数"></a>7.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>lower(str)</td><td>将字符串全部转为小写</td></tr><tr><td>upper(str)</td><td>将字符串全部转为大写</td></tr><tr><td>lpad(str, n, pad)</td><td>左填 充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>rpad(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>trim(str)</td><td>去掉字符串<strong>头部</strong>和<strong>尾部</strong>的空格</td></tr><tr><td>substring(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h2 id="7-2-数值函数"><a href="#7-2-数值函数" class="headerlink" title="7.2 数值函数"></a>7.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ceil(x)</td><td>向<strong>上</strong>取整</td></tr><tr><td>floor(x)</td><td>向<strong>下</strong>取整</td></tr><tr><td>mod(x, y)</td><td>返回x&#x2F;y的<strong>模</strong></td></tr><tr><td>rand()</td><td>返回0~1内的<strong>随机数</strong></td></tr><tr><td>round(x, y)</td><td>求参数x的<strong>四舍五入值</strong>，保留y位小数</td></tr></tbody></table><h2 id="7-3-日期函数"><a href="#7-3-日期函数" class="headerlink" title="7.3 日期函数"></a>7.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期，2021-10-11</td></tr><tr><td>curtime()</td><td>返回当前时间，23:46:43</td></tr><tr><td>now()</td><td>返回当前日期和时间，2021-01-11 23:46:43</td></tr><tr><td>year(date)</td><td>获取指定date的年份，2021</td></tr><tr><td>month(date)</td><td>获取指定date的月份，10</td></tr><tr><td>day(date)</td><td>获取指定date的日期，12</td></tr><tr><td>date_add(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值 date<strong>加</strong>上一个<strong>时间间隔</strong>expr后的时间值</td></tr><tr><td>datedff(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数,u即 date2-date1</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- DATE_ADD</span><br><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</span><br></pre></td></tr></table></figure><h2 id="7-4-流程函数"><a href="#7-4-流程函数" class="headerlink" title="7.4 流程函数"></a>7.4 流程函数</h2><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>ifnull(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>&#96;&#96;case when <code>[val1 ] </code>THEN <code>[ res1 ] ... </code>ELSE<code>[ default ]</code>END&#96;</td><td>如果<strong>val1为true，返回res1</strong>，… 否则返回default默认值</td></tr><tr><td><code>case</code> [ expr ] <code>when</code> [ val1 ] <code>then</code>[ res1 ] … <code>else</code> [ default ] <code>end</code></td><td>如果<strong>expr的值等于val1，返回res1</strong>，… 否则返回default默认值</td></tr></tbody></table><p> 例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br><span class="line">select</span><br><span class="line">name,</span><br><span class="line">(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure><h1 id="8-约束"><a href="#8-约束" class="headerlink" title="8 约束"></a>8 约束</h1><p>约束是作用于表中<strong>字段</strong>上的规则,用于<strong>限制存储在表中的数据</strong>，保证了数据库中数据的正确、有效性和完整性。常用的约束有以下几种：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><blockquote><p> 约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p></blockquote><h2 id="8-1-常用约束"><a href="#8-1-常用约束" class="headerlink" title="8.1 常用约束"></a>8.1 常用约束</h2><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220516165156721.png" alt="image-20220516165156721"></p><p>对应的建表语句为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(10) not null unique,</span><br><span class="line">age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">status char(1) default &#x27;1&#x27;,</span><br><span class="line">gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="8-2-外键约束"><a href="#8-2-外键约束" class="headerlink" title="8.2 外键约束"></a>8.2 外键约束</h2><h4 id="1-添加外键"><a href="#1-添加外键" class="headerlink" title="1. 添加外键"></a>1. 添加外键</h4><p><code>外键</code>用来让两张表的数据之间建立连接,从而保证数据的一致性和完整性。我们通过以下两中方式来添加外键</p><ol><li>在创建表的同时添加约束</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">... </span><br><span class="line">[constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>update</code>来添加约束</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br></pre></td></tr></table></figure><p>也可以通过如下方式来删除外键<br><code>alter table 表名 drop foreign key 外键名;</code></p><h4 id="2-删除-x2F-更新行为"><a href="#2-删除-x2F-更新行为" class="headerlink" title="2. 删除&#x2F;更新行为"></a>2. 删除&#x2F;更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则<strong>不允许删除&#x2F;更新</strong>（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则<strong>不允许删除&#x2F;更新</strong>（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果<strong>有则也删除&#x2F;更新外键在子表中的记录</strong></td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果<strong>有则设置子表中该外键值为null</strong>（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，<strong>子表将外键设为一个默认值</strong>（Innodb不支持）</td></tr></tbody></table><p>通过<code>on</code>关键字来更改删除&#x2F;更新行为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ON</span> <span class="keyword">UPDATE</span> 行为 <span class="keyword">ON</span> <span class="keyword">DELETE</span> 行为;</span><br></pre></td></tr></table></figure><h1 id="9多表查询"><a href="#9多表查询" class="headerlink" title="9多表查询"></a>9多表查询</h1><h2 id="9-1-多表关系"><a href="#9-1-多表关系" class="headerlink" title="9.1 多表关系"></a>9.1 多表关系</h2><p>项目开发中,在进行数据库表结构设计时,会根据业务需求及业务模块之间的关系,分析并设计表结构,由于业务之间相互关联,所以**各个表结构之间也存在着各种联系,**基本上分为3种:</p><ul><li>一对多</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><blockquote><p>对于实体集<strong>A</strong>中的<code>每一个实体</code>，在实体集B中有<code>n个实体</code>(n&gt;&#x3D;0)与之有联系；反之，对于实体集B中的<code>每一个实体</code>，实体集A中<code>至多有一个实体</code>与之联系。则称为实体集A和实体集B具有1:n的联系。</p></blockquote><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在<strong>多的一方建立外键</strong>，指向一的一方的主键</li></ul><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220516193735185.png" alt="image-20220516193735185"></p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><blockquote><p>对于实体集A中的<code>每一个实体</code>，在实体集B中有<code>n个实体</code>(n&gt;&#x3D;0)与之有联系，<strong>反之亦然</strong>。则称为实体集A和实体集B具有m:n的联系。</p></blockquote><ul><li>案例：学生与课程</li><li>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修</li><li>实现：建立<strong>第三张中间表</strong>，中间表至少包含<strong>两个外键</strong>，<strong>分别关联两方主键</strong></li></ul><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220516194113059.png" alt="image-20220516194113059"></p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><blockquote><p>对于实体集A中的<code>每一个实体</code>，在实体集B中<code>至多有一个实体</code>与之有联系；<strong>反之亦然</strong>。则称为实体集A和实体集B具有1:1的联系。</p></blockquote><ul><li>案例：用户与用户详情</li><li>关系：一对一关系，<strong>多用于单表拆分</strong>，<strong>将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</strong>。</li><li>实现：在<strong>任意一方</strong>加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</li></ul><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220516200441820.png" alt="image-20220516200441820"></p><h2 id="9-2-多表查询"><a href="#9-2-多表查询" class="headerlink" title="9.2 多表查询"></a>9.2 多表查询</h2><p>多表查询就是指从多张表中查询数据。我们要执行多表查询,就只需要<strong>使用逗号分隔多张表</strong>即可。默认的查询结果为多个表的合并查询（笛卡尔积）：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1,table2;</span><br></pre></td></tr></table></figure><blockquote><p>笛卡尔积：两个集合A集合和B集合的<strong>所有组合</strong>情况（在多表查询时，需要消除无效的笛卡尔积）</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220517110257276.png" alt="image-20220517110257276"></p></blockquote><p>我们需要的结果肯定不u是以上的结果，我们是需要消除无效的笛卡尔积的,只保留两张表关联部分的数据，消除无效笛卡尔积。通过给给多表查询<strong>加上连接查询的条件</strong>即可消除无效的笛卡尔积：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1, table2 <span class="keyword">where</span> table1.id <span class="operator">=</span> table2.tid;</span><br></pre></td></tr></table></figure><p>多表查询可以分为如下3种类型：</p><ol><li>内连接</li><li>外连接</li><li>自连接</li></ol><h2 id="9-3-内连接查询"><a href="#9-3-内连接查询" class="headerlink" title="9.3 内连接查询"></a>9.3 内连接查询</h2><p>内连接查询的是两张表交集的部分，即下图中的绿色部分。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220517111527656.png" alt="image-20220517111527656"></p><ul><li>隐式内连接</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">where</span> 条件 ...;</span><br></pre></td></tr></table></figure><ul><li>显式内连接</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>  <span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件 ...;</span><br></pre></td></tr></table></figure><p>例子: 查询员工姓名，及关联的部门的名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 隐式</span><br><span class="line">select e.name, d.name from employee as e, dept as d where e.dept = d.id;</span><br><span class="line">-- 显式</span><br><span class="line">select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure><blockquote><p><strong>显式性能比隐式高</strong></p></blockquote><h2 id="9-4-外连接查询"><a href="#9-4-外连接查询" class="headerlink" title="9.4 外连接查询"></a>9.4 外连接查询</h2><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220517112614905.png" alt="image-20220517112614905"></p><p>外连接分为两种,分别是:左外连接 和 右外连接。具体的语法结构为</p><ul><li><strong>左外连接</strong>: 查询<strong>左</strong>表<strong>所有数据</strong>，以及两张表交集部分数据。相当于查询<strong>表1的所有数据</strong>，包含<strong>表1和表2交集部分</strong>数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure><ul><li><strong>右外连接</strong>：查询<strong>右</strong>表<strong>所有数据</strong>，以及两张表交集部分数据。相当于查询<strong>表2(右表)的所有数据</strong>,当然也包含<strong>表1和表2交集部分</strong>的数据。<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">right</span>  <span class="keyword">outer</span>  <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件 ...;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure><blockquote><p><strong>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</strong>。</p><p>注意内连接和外连接的区别！</p></blockquote><h2 id="9-5-自连接查询"><a href="#9-5-自连接查询" class="headerlink" title="9.5 自连接查询"></a>9.5 自连接查询</h2><p>当前表与自身的连接查询，也就是把一张表连接查询多次。需要强调的是<strong>自连接必须使用表别名</strong>，,要不然我们不清楚所指定的条件、返回的字段,到底<br>是哪一张表的字段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表A as 别名A join 表A 别名B on 条件 ...;</span><br></pre></td></tr></table></figure><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工及其所属领导的名字</span><br><span class="line">select a.name, b.name from employee a, employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name, b.name from employee a left join employee b on a.manager = b.id;</span><br></pre></td></tr></table></figure><h2 id="9-6-联合查询"><a href="#9-6-联合查询" class="headerlink" title="9.6 联合查询"></a>9.6 联合查询</h2><p>对于union查询,就是把多次查询的结果合并起来,形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B ...</span><br></pre></td></tr></table></figure><blockquote><ul><li>UNION ALL 会有重复结果<strong>，UNION 不会</strong></li><li><strong>联合查询比使用or效率高，不会使索引失效</strong></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>当我们使用<code>union all</code>查询出来结果过有重复的时候，我们可以将<code>union all</code>关键字替换为<code>union</code>。或者对原本的数据进行去重操作。</p><blockquote><p><code>使用union [all] 关键字</code>进行联合查询时，两条查询语句所查询的字段需必须相同，否则会报错：</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520100755424.png" alt="image-20220520100755424"></p></blockquote><h2 id="9-7-嵌套查询"><a href="#9-7-嵌套查询" class="headerlink" title="9.7  嵌套查询"></a>9.7  嵌套查询</h2><p>SQL语句中嵌套SELECT语句，称谓<strong>嵌套查询</strong>，又称<strong>子查询</strong>。子查询外部的语句可以是<code>INSERT / UPDATE / DELETE / SELECT</code> 的任何一个。子查询语句的位置可以是<code>where之后</code>、<code>from之后</code>、<code>select之后</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> ( <span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure><p>根据子查询<strong>返回的结果</strong>可以分为：</p><ul><li>标量子查询:子查询结果为单个值</li><li>列子查询:  子查询结果为一列</li><li>行子查询:  子查询结果为一行</li><li>表子查询:  子查询结果为多行多列</li></ul><h3 id="9-7-1-标量子查询"><a href="#9-7-1-标量子查询" class="headerlink" title="9.7.1 标量子查询"></a>9.7.1 标量子查询</h3><p>子查询返回的结果是<strong>单个值</strong>（数字、字符串、日期等）。常用操作符有：<code>-</code> 、<code>&lt;</code> 、<code>&gt;</code> 、<code>&gt;</code> 、<code>&gt;</code>、<code>=</code> 、<code>&lt;</code> 、<code>&lt;</code>、<code>=</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询 &quot;销售部&quot; 的所有员工信息</span><br><span class="line">select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 查询xxx入职之后的员工信息</span><br><span class="line">select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure><h3 id="9-7-2-列子查询"><a href="#9-7-2-列子查询" class="headerlink" title="9.7.2 列子查询"></a>9.7.2 列子查询</h3><p>返回的结果是<strong>一列</strong>（可以是多行），常用操作符如下：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围<strong>内</strong>，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有<strong>任意一个满足</strong>即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值<strong>都</strong>必须满足</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询销售部和市场部的所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure><h3 id="9-7-3-行子查询"><a href="#9-7-3-行子查询" class="headerlink" title="9.7.3 行子查询"></a>9.7.3 行子查询</h3><p>返回的结果是一行（可以是多列）。常用操作符有：<code>=</code>,<code> &lt;</code>,<code> &gt;</code>,<code> IN</code>, <code>NOT IN</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary, manager) = (12500, 1);</span><br><span class="line">select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);</span><br></pre></td></tr></table></figure><h3 id="9-7-4-表子查询"><a href="#9-7-4-表子查询" class="headerlink" title="9.7.4 表子查询"></a>9.7.4 表子查询</h3><p>返回的结果是多行多列。常用操作符有：<code>IN</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br></pre></td></tr></table></figure><h2 id="9-8-多表查询练习"><a href="#9-8-多表查询练习" class="headerlink" title="9.8 多表查询练习"></a>9.8 多表查询练习</h2><h3 id="9-8-1-数据准备"><a href="#9-8-1-数据准备" class="headerlink" title="9.8.1 数据准备"></a>9.8.1 数据准备</h3><p>在这个案例中，我们涉及到的表有三个:<code>emp员工表</code>、<code>dept部门表</code>、<code>salgrade薪资等级表</code>。其构建语句和数据插入语句如下：</p><ul><li>dept部门表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- 创建dept表,并插入数据</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">     id <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;部门名称&#x27;</span></span><br><span class="line">     )comment <span class="string">&#x27;部门表&#x27;</span>;</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (id, name) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;研发部&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;市场部&#x27;</span>),(<span class="number">3</span>, <span class="string">&#x27;财务部&#x27;</span>), (<span class="number">4</span>,</span><br><span class="line"><span class="string">&#x27;销售部&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;总经办&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;人事部&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>emp员工表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    id <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age</span><br><span class="line">     <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">    salary <span class="type">int</span> comment <span class="string">&#x27;薪资&#x27;</span>,</span><br><span class="line">    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">    managerid <span class="type">int</span> comment <span class="string">&#x27;直属领导ID&#x27;</span>,</span><br><span class="line">    dept_id <span class="type">int</span> comment <span class="string">&#x27;部门ID&#x27;</span></span><br><span class="line">    )comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id, name, age, job,salary, entrydate, managerid, dept_id) <span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;金庸&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;总裁&#x27;</span>,<span class="number">20000</span>, <span class="string">&#x27;2000-01-01&#x27;</span>, <span class="keyword">null</span>,<span class="number">5</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;张无忌&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;项目经理&#x27;</span>,<span class="number">12500</span>, <span class="string">&#x27;2005-12-05&#x27;</span>, <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&#x27;杨逍&#x27;</span>, <span class="number">33</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">8400</span>,<span class="string">&#x27;2000-11-03&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="number">48</span>, <span class="string">&#x27;开发&#x27;</span>,<span class="number">11000</span>, <span class="string">&#x27;2002-02-05&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="string">&#x27;常遇春&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;开发&#x27;</span>,<span class="number">10500</span>, <span class="string">&#x27;2004-09-07&#x27;</span>, <span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="string">&#x27;小昭&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;程序员鼓励师&#x27;</span>,<span class="number">6600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">&#x27;灭绝&#x27;</span>, <span class="number">60</span>, <span class="string">&#x27;财务总监&#x27;</span>,<span class="number">8500</span>, <span class="string">&#x27;2002-09-12&#x27;</span>, <span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="string">&#x27;周芷若&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;会计&#x27;</span>,<span class="number">48000</span>, <span class="string">&#x27;2006-06-02&#x27;</span>, <span class="number">7</span>,<span class="number">3</span>),</span><br><span class="line">    (<span class="number">9</span>, <span class="string">&#x27;丁敏君&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;出纳&#x27;</span>,<span class="number">5250</span>, <span class="string">&#x27;2009-05-13&#x27;</span>, <span class="number">7</span>,<span class="number">3</span>),</span><br><span class="line">    (<span class="number">10</span>, <span class="string">&#x27;赵敏&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;市场部总监&#x27;</span>,<span class="number">12500</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="string">&#x27;鹿杖客&#x27;</span>, <span class="number">56</span>, <span class="string">&#x27;职员&#x27;</span>,<span class="number">3750</span>, <span class="string">&#x27;2006-10-03&#x27;</span>, <span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    (<span class="number">12</span>, <span class="string">&#x27;鹤笔翁&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;职员&#x27;</span>,<span class="number">3750</span>, <span class="string">&#x27;2007-05-09&#x27;</span>, <span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    (<span class="number">13</span>, <span class="string">&#x27;方东白&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;职员&#x27;</span>,<span class="number">5500</span>, <span class="string">&#x27;2009-02-12&#x27;</span>, <span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    (<span class="number">14</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="number">88</span>, <span class="string">&#x27;销售总监&#x27;</span>,<span class="number">14000</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">    (<span class="number">15</span>, <span class="string">&#x27;俞莲舟&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;销售&#x27;</span>,<span class="number">4600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">14</span>,<span class="number">4</span>),</span><br><span class="line">    (<span class="number">16</span>, <span class="string">&#x27;宋远桥&#x27;</span>, <span class="number">40</span>, <span class="string">&#x27;销售&#x27;</span>,<span class="number">4600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">14</span>,<span class="number">4</span>),</span><br><span class="line">    (<span class="number">17</span>, <span class="string">&#x27;陈友谅&#x27;</span>, <span class="number">42</span>, <span class="keyword">null</span>,<span class="number">2000</span>, <span class="string">&#x27;2011-10-12&#x27;</span>, <span class="number">1</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><ul><li>salgrade 薪资等级表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建薪资等级表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> salgrade(</span><br><span class="line">     grade <span class="type">int</span>,</span><br><span class="line">     losal <span class="type">int</span>,</span><br><span class="line">     hisal <span class="type">int</span></span><br><span class="line">     ) comment <span class="string">&#x27;薪资等级表&#x27;</span>;</span><br><span class="line"> <span class="comment">-- 插入数据    </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">0</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">2</span>,<span class="number">3001</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">3</span>,<span class="number">5001</span>,<span class="number">8000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">4</span>,<span class="number">8001</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">5</span>,<span class="number">10001</span>,<span class="number">15000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">6</span>,<span class="number">15001</span>,<span class="number">20000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">7</span>,<span class="number">20001</span>,<span class="number">25000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salgrade <span class="keyword">values</span> (<span class="number">8</span>,<span class="number">25001</span>,<span class="number">30000</span>);</span><br></pre></td></tr></table></figure><h3 id="9-8-2-案例练习"><a href="#9-8-2-案例练习" class="headerlink" title="9.8.2 案例练习"></a>9.8.2 案例练习</h3><ul><li>查询员工的姓名、年龄、职位、部门信息 (隐式内连接)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">       e.name,</span><br><span class="line">       e.age,</span><br><span class="line">       e.job,</span><br><span class="line">       d.id <span class="keyword">as</span> did,</span><br><span class="line">       d.name <span class="keyword">as</span> dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">     emp <span class="keyword">as</span> e,</span><br><span class="line">     dept <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">where</span> e.dept_id<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure><blockquote><p>注意：原本的emp员工共有17人，但是这样查询出来的数据却只有16人。原因是因为，emp中有一条数据的dept.id的值为null。</p></blockquote><ul><li>查询年龄小于30岁的员工的姓名、年龄、职位、部门信息(显式内连接)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    e.name,</span><br><span class="line">    e.age,</span><br><span class="line">    e.job,</span><br><span class="line">    d.name <span class="keyword">as</span> dname,</span><br><span class="line">    d.id <span class="keyword">as</span> did</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept_id<span class="operator">=</span>d.id</span><br><span class="line"><span class="keyword">where</span> e.age <span class="operator">&lt;</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure><ul><li>查询所有年龄大于40岁的员工, 及其归属的部门名称; <strong>如果员工没有分配部门, 也需要展示出来(外连接)</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">       e.<span class="operator">*</span>,</span><br><span class="line">       d.name</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d</span><br><span class="line">    <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">where</span> e.age<span class="operator">&gt;</span><span class="number">40</span>;</span><br></pre></td></tr></table></figure><ul><li>查询拥有员工的部门ID、部门名称</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span></span><br><span class="line">    d.id,</span><br><span class="line">    d.name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">     dept <span class="keyword">as</span> d,</span><br><span class="line">     emp <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><ul><li>查询所有员工的工资等级</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,</span><br><span class="line">       s.grade</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> salgrade <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> (e.salary<span class="operator">&gt;</span>s.losal <span class="keyword">and</span> e.salary<span class="operator">&lt;</span>s.hisal);</span><br></pre></td></tr></table></figure><ul><li>查询 “研发部” 所有员工的信息及工资等级</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,</span><br><span class="line">       s.grade</span><br><span class="line"><span class="keyword">from</span> dept <span class="keyword">as</span> d,</span><br><span class="line">     emp <span class="keyword">as</span> e,</span><br><span class="line">     salgrade <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> d.name <span class="operator">=</span><span class="string">&#x27;研发部&#x27;</span></span><br><span class="line">     <span class="keyword">and</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line">     <span class="keyword">and</span>  e.salary<span class="operator">&gt;</span> s.losal</span><br><span class="line">     <span class="keyword">and</span>  e.salary <span class="operator">&lt;</span>s.hisal;</span><br></pre></td></tr></table></figure><ul><li>查询 “研发部” 员工的平均工资</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(e.salary)</span><br><span class="line"><span class="keyword">from</span> dept <span class="keyword">as</span> d,</span><br><span class="line">     emp <span class="keyword">as</span> e,</span><br><span class="line">     salgrade <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> d.name <span class="operator">=</span><span class="string">&#x27;研发部&#x27;</span></span><br><span class="line">     <span class="keyword">and</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><ul><li>查询工资比 “灭绝” 高的员工信息。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.name,</span><br><span class="line">       e.salary</span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> e.salary <span class="operator">&gt;</span> (<span class="keyword">select</span> e.salary <span class="keyword">from</span> emp <span class="keyword">as</span> e <span class="keyword">where</span> e.name <span class="operator">=</span> <span class="string">&#x27;灭绝&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>查询比平均薪资高的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> e.salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(e.salary) <span class="keyword">from</span> emp <span class="keyword">as</span> e);</span><br></pre></td></tr></table></figure><ul><li>查询低于本部门平均工资的员工信息(<strong>重要</strong>)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> e.salary <span class="operator">&lt;</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">avg</span>(emp.salary) <span class="keyword">from</span> emp <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> e.dept_id);</span><br></pre></td></tr></table></figure><ul><li>查询所有的部门信息, 并统计部门的员工人数（<strong>重要</strong>）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">       d.<span class="operator">*</span>,</span><br><span class="line">       (<span class="keyword">select</span> <span class="built_in">count</span>(emp.name) <span class="keyword">from</span> emp <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> d.id) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> dept <span class="keyword">as</span> d;</span><br></pre></td></tr></table></figure><h1 id="10-事务"><a href="#10-事务" class="headerlink" title="10 事务"></a>10 事务</h1><p><strong>事务是一组操作的集合，</strong>事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么<strong>同时成功</strong>，要么<strong>同时失败</strong>。</p><p>就比如: 张三给李四转账1000块钱,张三银行账户的钱减少1000,而李四银行账户的钱要增加1000。 这一组操作就必须在一个事务的范围内,要么都成功,要么都失败。正常情况下，转账这个操作,需要分为以下这么三步来完成 ：<code>查询张三账户</code>、<code>张三减少1000</code>、 <code>而李四增加1000</code>, 转账成功。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520174100758.png" alt="image-20220520174100758"></p><p> 若是转账操作在执行<strong>第三步</strong>是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520174244966.png" alt="image-20220520174244966"></p><p>为了解决上述的问题,就需要通过数据的事务来完成,我们只需要<strong>在业务逻辑执行之前开启事务,执行完毕后提交事务</strong>。如果执行过程中<strong>报错,则回滚事务</strong>,把数据恢复到<strong>事务开始之前</strong>的状态。 MySQL<strong>默认</strong>的事务是<strong>自动</strong>提交的,也就是说,当执行完一条DML语句时,MySQL会立即隐式的提交事务。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520174333054.png" alt="image-20220520174333054"></p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1. 查询张三账户余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2. 将张三账户余额-1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">-- 此语句出错后张三钱减少但是李四钱没有增加</span><br><span class="line">模拟sql语句错误</span><br><span class="line"></span><br><span class="line">-- 3. 将李四账户余额+1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查看事务提交方式，设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">SET @@AUTOCOMMIT = 0;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置手动提交后上面代码改为：</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h2 id="10-1-四大特性ACID"><a href="#10-1-四大特性ACID" class="headerlink" title="10.1 四大特性ACID"></a>10.1 四大特性ACID</h2><ol><li><p><code>原子性(Atomicity)</code>：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</p></li><li><p><code>一致性(Consistency)</code>：事务完成时，必须使所有数据都保持一致状态</p></li><li><p><code>隔离性(Isolation)</code>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p></li><li><p><code>持久性(Durability)</code>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ol><h2 id="10-2-并发事务"><a href="#10-2-并发事务" class="headerlink" title="10.2 并发事务"></a>10.2 并发事务</h2><p>当程序存在并发时，就可能会同时存在多个事务对数据库操作，从而引发数据安全问题。</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="10-2-1-脏读"><a href="#10-2-1-脏读" class="headerlink" title="10.2.1 脏读"></a>10.2.1 脏读</h3><p>一个事务读到另一个事务还没提交的数据。如下面的事务B读取到了事务A未提交的更新数据。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520182634696.png" alt="image-20220520182634696"></p><h3 id="10-2-2-幻读"><a href="#10-2-2-幻读" class="headerlink" title="10.2.2 幻读"></a>10.2.2 幻读</h3><p>个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在。事务A第一次查询数据库时数据库中没有该记录，随后事务B执行了insert操作，含有了该数据。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520183042182.png" alt="image-20220520183042182"></p><h3 id="10-2-3-不可重复读"><a href="#10-2-3-不可重复读" class="headerlink" title="10.2.3 不可重复读"></a>10.2.3 不可重复读</h3><p>一个事务先后读取同一条记录，但两次读取的数据不同。如事务A先后两次读取数据库的同一条数据，而在这两次中间，事务B提交了update操作，导致两次查询的数据不相同。</p><p><img src="/img/MySQL%E7%AC%94%E8%AE%B0/image-20220520182845191.png" alt="image-20220520182845191"></p><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p><h2 id="10-3-并发事务的隔离级别"><a href="#10-3-并发事务的隔离级别" class="headerlink" title="10.3 并发事务的隔离级别"></a>10.3 并发事务的隔离级别</h2><p>为了解决并发事务所引发上面的问题,在数据库中引入了事务隔离级别。主要有以下几个事物隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed（Oricle默认）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(MySQL默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</p><blockquote><p> √表示在当前隔离级别下该问题会出现</p></blockquote><ul><li>查看事务隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION</span>_ISOLATION;</span><br></pre></td></tr></table></figure><ul><li>设置事务隔离级别：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> REPEATABLE READ <span class="operator">|</span> SERIALIZABLE &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级篇</title>
      <link href="/article/a63b7bb5.html"/>
      <url>/article/a63b7bb5.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h1><p>MySQL体系结构：</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h1 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h1><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>    # 开启慢查询日志开关<br>    slow_query_log&#x3D;1<br>    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>    long_query_time&#x3D;2<br>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain &#x2F; desc<br>    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user (phone);</span><br><span class="line">-- 为profession, age, status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession, age, status);</span><br><span class="line">-- 为email建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on tb_user;</span><br></pre></td></tr></table></figure><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="覆盖索引-amp-回表查询"><a href="#覆盖索引-amp-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="单列索引-amp-联合索引"><a href="#单列索引-amp-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h1 id="4-SQL-优化"><a href="#4-SQL-优化" class="headerlink" title="4. SQL 优化"></a>4. SQL 优化</h1><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE|Java网络编程.md</title>
      <link href="/article/8d2c916c.html"/>
      <url>/article/8d2c916c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-计算机网络"><a href="#1-1-计算机网络" class="headerlink" title="1.1 计算机网络"></a>1.1 计算机网络</h2><p>所谓计算机网络,就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统,从而使众多的计算机可以方便地互相传递信息,共享硬件、软件、数据信息等资源。</p><p>计算机网络通常是按照规模大小和延伸范围来分类的,常见的划分为**:局域网(LAN**)、<strong>城域网(MAN</strong>)、<strong>广域网(WAN</strong>)。<code>Internet</code>可以视为世界上最大的广域网。</p><p>如果按照<strong>网络的拓扑结构</strong>来划分,可以分为星型网络、总线型网络、环型网络、树型网络、星型环型网络等;如果按照<strong>网络的传输介质</strong>来划分,可以分为双绞线网、同轴电缆网、光纤网和卫星网等。</p><h2 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h2><p><strong>IP地址用于唯一地标识网络中的一个通信实体</strong>,这个通信实体既可以是一台主机,也可以是一台打印机,或者是路由器的某一个端口。</p><p>IP地址是数字型的,IP地址是一个3<strong>2位(32bit)整数</strong>,但通常为了便于记忆,通常把它分成<strong>4个8位的二进制数</strong>,<strong>每8位之间用圆点隔开</strong>,<strong>每个8位整数可以转换成一个0~255的十进制整数</strong>,因此日常看到的IP地址常常是这种形式:202.9.128.88。</p><p>IP地址被分成了A、B、C、D、E五类,每个类别的网络标识和主机标识各有规则。</p><ul><li>➢ A类:10.0.0.0~10.255.255.255</li><li>➢ B类:172.16.0.0~172.31.255.255</li><li>➢ C类:192.168.0.0~192.168.255.255</li></ul><h2 id="1-3-端口号"><a href="#1-3-端口号" class="headerlink" title="1.3 端口号"></a>1.3 端口号</h2><p>IP地址用于唯一地标识网络上的一个通信实体,但一个通信实体可以<strong>有多个通信程序同时提供网络服务</strong>,此时还需要使用<strong>端口</strong>。</p><p>端口是一个<strong>16位的整数</strong>, 用于表示数据交给哪个通信<strong>程序</strong>处理。因此,端口就是应用程序与外界交流的出入口。,端口号可以从0到65535，共分为3类：</p><ul><li>➢ <strong>公认端口</strong>(Well Known Ports):从<strong>0到102</strong>3,它们紧密绑定(Binding)一些特定的服务。</li><li>➢ <strong>注册端口</strong>(Registered Ports):从<strong>1024到49151</strong>,它们松散地绑定一些服务。应用程序通常应该使用这个范围内的端口。</li><li>➢ <strong>动态和&#x2F;或私有端口</strong>(Dynamic and&#x2F;or Private Ports):从49152到65535,这些端口是应用程序使用的动态端口,应用程序一般不会主动使用这些端口。</li></ul><blockquote><p>如果把IP地址理解为某个人所在地方的地址(包括街道和门牌号),但仅有地址还是找不到这个人,还需要知道他所在的房号才可以找到这个人。</p><p>ip: 这个人的家庭地址</p><p>端口：这个人的房间号</p></blockquote><h2 id="1-4-通信协议"><a href="#1-4-通信协议" class="headerlink" title="1.4 通信协议"></a>1.4 通信协议</h2><p>为了让两个节点之间能进行对话,必须在它们之间建立通信的规则,使彼此之间能进行信息交换。而这些规则就是<strong>通讯协议</strong>。</p><p>通信协议通常由三部分组成:一是<strong>语义部分</strong>,用于决定双方对话的类型;二是<strong>语法部分</strong>,用于决定双方对话的格式;三是<strong>变换规则</strong>,用于决定通信双方的应答关系，常见的通信协议模型有两种：</p><ul><li>开放系统互连参考模型OSI。</li><li>TCP&#x2F;IP协议模型</li></ul><h3 id="1-4-1-开放系统互连参考模型"><a href="#1-4-1-开放系统互连参考模型" class="headerlink" title="1.4.1 开放系统互连参考模型"></a>1.4.1 开放系统互连参考模型</h3><p>开放系统互连参考模型把计算机网络分成<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code>七层。</p><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220508172847373.png" alt="image-20220508172847373"></p><h3 id="1-4-2-TCP-x2F-IP协议模型"><a href="#1-4-2-TCP-x2F-IP协议模型" class="headerlink" title="1.4.2 TCP&#x2F;IP协议模型"></a>1.4.2 TCP&#x2F;IP协议模型</h3><blockquote><p><strong>IP(Internet Protocol)协议</strong>又称互联网协议,是支持网间互联的数据报协议。它提供网间连接的完善功能,包括IP数据报规定互联网络范围内的地址格式。</p><p><strong>TCP ( Transmission ControlProtocol)协议</strong>,即传输控制协议,它规定一种可靠的数据信息传递服务。</p></blockquote><p>按TCP&#x2F;IP协议模型,网络通常被分为一个四层模型,这个四层模型和前面的OSI七层模型有大致的对应关系。</p><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220508172908564.png" alt="image-20220508172908564"></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>邮件：</p><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621210829596.png" alt="在这里插入图片描述"></p><ul><li>计算机网络： 计算机网络是指将<a href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86">地理</a>位置不同的具有独立功能的多台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>及其外部设备，通过通信线路连接起来，在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997">网络操作系统</a>，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078">网络管理软件</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611">网络通信协议</a>的管理和协调下，实现<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480">资源共享</a>和信息传递的计算机系统。</li><li>网络编程的目的：无线电台…传播交流信息，数据交换，通信。</li><li>想要达到这个效果需要什么：<ol><li>如何让准确的定位网络上的一台主机 192.168.16.124：端口， 定位上这个计算机上的某个资源。</li><li>找到了这个主机，如何传输数据呢？</li></ol></li><li>Javaweb:网页编程 、 B&#x2F;S架构</li><li>网络编程：TCP&#x2F;IP 、 C&#x2F;S</li></ul><h2 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2.网络通信要素"></a>2.网络通信要素</h2><p><strong>如何实现网络的通信？</strong></p><ul><li>通信双方的地址：<ul><li>ip：192.168.16.124</li><li>端口：5900</li></ul></li><li><strong>规则：网络通信的协议</strong>：TCP&#x2F;IP</li></ul><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2021062121084476.png" alt="在这里插入图片描述"></p><blockquote><p>小结：</p></blockquote><ol><li>网络编程中有两个主要的问题：<ul><li>如何让准确的定位到网络上的一台或多台主机；</li><li>找到主机之后如何通信；</li></ul></li><li>网络编程中的要素：<ul><li>IP和端口号：IP</li><li>网络通信协议：UDP、TCP</li></ul></li><li>万物皆对象</li></ol><h2 id="3-IP"><a href="#3-IP" class="headerlink" title="3.IP"></a>3.IP</h2><p>IP 地址：InetAddress</p><ul><li><p>唯一定位一台网络上的计算机</p></li><li><p>127.0.0.1： 本机localhost</p></li><li><p>ip地址的父类</p><ul><li>IPV4： 127.0.0.1 ,4个字节组成。，0<del>255， 42亿</del>；30亿都在北美，亚洲4亿。2011年就用尽；</li><li>IPV6： fe80::f0e0:7383:ad8e:f32f%3 ，128位。8个无符号整数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2406</span>:da18:ddf:<span class="number">4000</span>:67d5:b226:cad7:125b</span><br></pre></td></tr></table></figure></li><li><p>公网（互联网）–私网（局域网）</p><ul><li><a href="https://www.jb51.net/network/579228.html">ABCD地址</a></li><li>192.168.xx.xx,专门给组织内部使用。</li></ul></li><li><p>域名：记忆IP问题！</p><ul><li>IP：<a href="http://www.vip.com/">www.vip.com</a></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 10:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 查询本机地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress1);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress2);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress3</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inetAddress3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询网站IP地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.taobao.com&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">//            System.out.println(inetAddress.getAddress());   // 返回的是一个字节数组  无用</span></span><br><span class="line">            System.out.println(inetAddress.getCanonicalHostName());    <span class="comment">// 规范的名字</span></span><br><span class="line">            System.out.println(inetAddress.getHostAddress());  <span class="comment">// IP</span></span><br><span class="line">            System.out.println(inetAddress.getHostName()); <span class="comment">// 域名，或者自己电脑的名字</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-端口"><a href="#4-端口" class="headerlink" title="4.端口"></a>4.端口</h2><ul><li>端口表示计算机上一个程序的进程；</li><li>不同的进程有不同的端口号！用来区分软件！</li><li>被规定0~65535</li><li>TCP，UDP：65535*2个端口 tcp：80 udp：80 单个协议下，端口号不能冲突</li><li>端口分类<ul><li>共有端口 0~1023 内置的进程使用<ul><li>HTTP：80</li><li>HTTP：443 如访问https：&#x2F;&#x2F;<a href="http://www.baidu.com:443/">www.baidu.com:443</a> 访问的还是百度</li><li>FTP：21</li><li>TELENT：23</li></ul></li><li>程序注册端口：1014-49151，分配给用户和程序<ul><li>Tomcat：8080</li><li>MySql：3306</li><li>Oracle：1521</li></ul></li><li>动态、私有端口：49152~65535</li></ul></li></ul><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netstat -ano #查看所有的端口</span><br><span class="line">netstat -nao|<span class="built_in">findstr</span> &quot;<span class="number">7808</span>&quot; #查看指定的端口</span><br><span class="line">tasklist|<span class="built_in">findstr</span> &quot;<span class="number">8696</span>&quot;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621210906576.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 10:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetSocketAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">socketAddress2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        System.out.println(socketAddress);</span><br><span class="line">        System.out.println(socketAddress2);</span><br><span class="line"></span><br><span class="line">        System.out.println(socketAddress.getAddress());</span><br><span class="line">        System.out.println(socketAddress.getHostName());    <span class="comment">// 地址</span></span><br><span class="line">        System.out.println(socketAddress.getPort());    <span class="comment">// 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621210919531.png" alt="在这里插入图片描述"></p><h2 id="5-通信协议"><a href="#5-通信协议" class="headerlink" title="5.通信协议"></a>5.通信协议</h2><p>协议：约定，就好比中国人交流说的是普通话</p><p><strong>网络通信协议：</strong> 速率，传输码率，代码结构，传输控制…</p><p><strong>问题</strong>：非常的复杂</p><p>大事化小：分层</p><p><strong>TCP&#x2F;IP协议簇：实际上是一组协议</strong></p><p>重要：</p><ul><li>TCP：用户传输协议</li><li>UDP：用户数据报协议</li></ul><p>出名的协议：</p><ul><li>TCP：</li><li>IP：网络互联协议</li></ul><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621210931769.png" alt="在这里插入图片描述"></p><p><strong>TCP UDP 对比</strong></p><ul><li><p>TCP：打电话</p><ul><li><p>连接，稳定</p></li><li><p>三次握手，四次挥手</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">最少需要三次，保证稳定连接！</span><br><span class="line">A：你瞅啥？</span><br><span class="line">B：瞅你咋地？</span><br><span class="line">A：干一场</span><br><span class="line"></span><br><span class="line">A：我要分手了</span><br><span class="line">B：我知道你要分手了</span><br><span class="line">B：你真的要分手吗？</span><br><span class="line">A：我真的要分手了</span><br></pre></td></tr></table></figure></li><li><p>客户端、服务器</p></li><li><p>传输完成，释放连接，效率低</p></li></ul></li><li><p>UDP;发短信</p><ul><li>不连接，不稳定</li><li>客户端、服务端：没有明确的解现</li><li>不管有没有准备好，都可以发给你</li><li>DDOS：洪水攻击！ 发垃圾包 堵塞线路 （饱和攻击）</li></ul></li></ul><h2 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h2><blockquote><p><strong>先启动服务端，再启动客户端！！！！</strong></p></blockquote><p><strong>客户端</strong></p><ul><li>连接服务器 Socket</li><li>发送消息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.要知道服务器的地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">// 2.创建一个socket链接</span></span><br><span class="line">            accept = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress,port);</span><br><span class="line">            <span class="comment">// 3.发送信息IO流</span></span><br><span class="line">            os = accept.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;就这吧，什么鬼？&quot;</span>.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accept != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器端</strong></p><ul><li>建立服务的端口 ServerSocket</li><li>等待的用户的连接 accept</li><li>接收用户的消息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1.有一个地址</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">// 2.等待客户端连接过来</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 3.读取客户端的消息</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           //弃用 会有中文乱码</span></span><br><span class="line"><span class="comment">           byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">            int len = 0;</span></span><br><span class="line"><span class="comment">            while ((len = is.read(bytes)) != -1)&#123;</span></span><br><span class="line"><span class="comment">                String s = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 管道流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1.文件上传"></a>1.文件上传</h3><ul><li>客户端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 13:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClientDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">// 2.创建输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;subei.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 4.输出测试文件</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = stream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.通知服务器已发送完成</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">// 6.确定服务器已经收到，断开连接</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len2 = stream.read(buffer2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            byteArrayOutputStream.write(buffer2,<span class="number">0</span>,len2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.关闭流</span></span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        stream.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 13:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个服务器地址</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">// 2.监听客户连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> socket.accept();    <span class="comment">// 阻塞式监听，能等待用户连进来</span></span><br><span class="line">        <span class="comment">// 3.获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="comment">// 4.确定存放文件的位置</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;resort.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.写入文件</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.通知客户端收集完毕</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器已经收集成功，请断开连接！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.关闭流</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621212202445.png" alt="在这里插入图片描述"></p><h3 id="2-初识Tomcat"><a href="#2-初识Tomcat" class="headerlink" title="2.初识Tomcat"></a>2.初识Tomcat</h3><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><blockquote><p>Tomcat乱码： conf\logging.properties 把UTF-8改为GBK</p></blockquote><p>服务端</p><ul><li>自定义 S</li><li>Tomcat服务器 S ：Java后台开发</li></ul><p>客户端</p><ul><li>自定义 C</li><li>浏览器 B</li></ul><h2 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h2><p>发短信：不用连接，需要知道对方的地址</p><h3 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 13:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 不需要连接服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1.建立一个Socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2.建个包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;服务器，你好！&quot;</span>;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localhost</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据，数据的长度起始，要发送给谁</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(msg.getBytes(), <span class="number">0</span>,msg.getBytes().length,localhost,port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> github.Web.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 还是需要客户端的链接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1.开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">// 2.接收数据包</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">        socket.receive(packet); <span class="comment">// 阻塞接受</span></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData()));</span><br><span class="line">        <span class="comment">// 3.关闭连接</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-循环发送消息"><a href="#2-循环发送消息" class="headerlink" title="2.循环发送消息"></a>2.循环发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 14:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSenderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备数据：控制台读取</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="type">byte</span>[] buffer = data.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送包</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> github.Web.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 14:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiveDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备接收包裹</span></span><br><span class="line">            <span class="type">byte</span>[] container = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(container, <span class="number">0</span>, container.length);</span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] data = packet.getData();</span><br><span class="line">            <span class="type">String</span> <span class="variable">receiveData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">            System.out.println(receiveData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (receiveData.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621212220521.png" alt="在这里插入图片描述"></p><blockquote><p>在线咨询： <strong>两个人都可以是发送方，也可以是接收方(配合多线程)</strong></p></blockquote><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621212230346.png" alt="在这里插入图片描述"></p><ul><li>发信端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkSend</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    formPort;</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>    toPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkSend</span><span class="params">(<span class="type">int</span> formPort, String hostname, <span class="type">int</span> toPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.formPort = formPort;</span><br><span class="line">        <span class="built_in">this</span>.hostname = hostname;</span><br><span class="line">        <span class="built_in">this</span>.toPort = toPort;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(formPort);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">                <span class="type">byte</span>[] buffer = s.getBytes();</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostname, toPort));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送包</span></span><br><span class="line">                socket.send(packet);</span><br><span class="line">                <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkReceive</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkReceive</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket =  <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//开放端口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收包</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] container = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(container,<span class="number">0</span>,container.length);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收</span></span><br><span class="line">                socket.receive(packet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">byte</span>[] data = packet.getData();</span><br><span class="line">                <span class="type">String</span> <span class="variable">receiveData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + receiveData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (receiveData.equals(<span class="string">&quot;bye&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>教师端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-11 18:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TalkSend</span>(<span class="number">7777</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">8900</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TalkReceive</span>(<span class="number">9999</span>),<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>学生端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-11 18:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TalkSend</span>(<span class="number">5555</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TalkReceive</span>(<span class="number">8900</span>),<span class="string">&quot;学生&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2021062121224818.png" alt="在这里插入图片描述"></p><h2 id="8-URL"><a href="#8-URL" class="headerlink" title="8.URL"></a>8.URL</h2><ul><li><a href="https://www.baidu.com/">https://www.baidu.com</a></li><li>统一资源定位符：定位互联网上的某一个资源</li><li>DNS域名解析 <a href="http://www.baidu.com/">www.baidu.com</a> —&gt; xxx.xxx.xxxx.xxx…xxx</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">协议：<span class="comment">// ip地址：端口号/项目名/资源</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/helloworld/insex&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.jsp?username=subeily&amp;password=123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(url.getProtocol());  <span class="comment">// 协议</span></span><br><span class="line">        System.out.println(url.getHost());  <span class="comment">// 主机IP</span></span><br><span class="line">        System.out.println(url.getPort());  <span class="comment">// 端口</span></span><br><span class="line">        System.out.println(url.getPath());  <span class="comment">// 路径</span></span><br><span class="line">        System.out.println(url.getFile());  <span class="comment">// 文件名</span></span><br><span class="line">        System.out.println(url.getQuery()); <span class="comment">// 参数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>下载网页上的文件</strong><ul><li>1.启动tomcat服务器；</li><li>2.在tomcat中放好文件；</li></ul></li></ul><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621212303606.png" alt="在这里插入图片描述"></p><ul><li>3.进行相关测试。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.Web.Demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subeiLY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.下载地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/subei/hello.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.连接到这个资源 HTTP</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;same.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            stream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        urlConnection.disconnect();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20210621212333948.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -javaSE,网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux记一次裸机安装Ubuntu的过程.md</title>
      <link href="/article/19cd5c15.html"/>
      <url>/article/19cd5c15.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期实验室进了一个的服务器主机（以下简称<code>机器</code>），机器的主体配置如下：</p><ol><li>CPU： i7-11700f</li><li>主板: 华硕z590-p</li><li>内存：海盗船32G×2</li><li>固态：西数1T</li><li>机械：西数4T</li><li>GPU：3080Ti</li></ol><p>要求：</p><ol><li>分配<code>500G固态</code>为机器安装<code>Ubutu18.04LTS</code>系统，剩余的作为存储用途。</li><li>同时将4T机械进行分区。</li><li>为系统装配anconda环境</li><li>搭建tensorflow、pytorch环境（要求都装配在conda虚拟环境中）。</li></ol></blockquote><h1 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h1><h2 id="1-1-制作启动盘"><a href="#1-1-制作启动盘" class="headerlink" title="1.1 制作启动盘"></a>1.1 制作启动盘</h2><p>这里制作启动盘的工具是<code>UltraISO</code>。官网地址：<a href="https://www.ultraiso.com/%E3%80%82UtlraISO">https://www.ultraiso.com/。UtlraISO</a> 是款收费软件，不过下载安装好以后给我们试用的机会，所以如果你是装机的话足够了。安装好以后打开软件，点击 <code>继续使用</code>：</p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/aHR0cHM6Ly9saXV3eW5uLmdpdGh1Yi5pby9pbWFnZXMvMjAxOTA3MTIvMS0xLnBuZw" alt="1-1"></p><p>点击 <code>文件 -&gt; 打开</code>，选择下载好的<code> ISO</code> 镜像文件，然后打开：</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430214940827.png" alt="image-20220430214940827"></p><p>点击 <code>启动-</code>&gt; <code>写入硬盘映像</code>：</p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/aHR0cHM6Ly9saXV3eW5uLmdpdGh1Yi5pby9pbWFnZXMvMjAxOTA3MTIvMS00LnBuZw" alt="1-4"></p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/aHR0cHM6Ly9saXV3eW5uLmdpdGh1Yi5pby9pbWFnZXMvMjAxOTA3MTIvMS01LnBuZw" alt="1-5"></p><p>选项都确定没问题以后可以点击 <code>写入</code> 按钮，此时会提示你会格式化U盘，选择 <strong>yes</strong>，然后静静的等待刻录完成即可。</p><h2 id="1-2-配置bios"><a href="#1-2-配置bios" class="headerlink" title="1.2 配置bios"></a>1.2 配置bios</h2><h3 id="1-bois简介"><a href="#1-bois简介" class="headerlink" title="1. bois简介"></a>1. bois简介</h3><p><strong>BIOS</strong>(Basic Input Output System),直译过来后中文名称就是”<strong>基本输入输出系统</strong>“。BIOS是个人电脑启动时加载的<strong>第一个软件</strong>。</p><p>其实，它是一组固化到计算机内<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9D%BF">主板</a>上一个<a href="https://baike.baidu.com/item/ROM">ROM</a><a href="https://baike.baidu.com/item/%E8%8A%AF%E7%89%87">芯片</a>上的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F">程序</a>，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从<a href="https://baike.baidu.com/item/CMOS/428167">CMOS</a>中<strong>读写系统设置</strong>的具体信息。 其主要功能是<strong>为计算机提供最底层的、最直接的硬件设置和控制</strong>。此外，BIOS还向作业系统提供一些<strong>系统参数</strong>。</p><p>系统硬件的变化是由BIOS隐藏，程序使用BIOS功能而不是直接控制硬件。现代作业系统会忽略BIOS提供的抽象层并直接控制硬件组件。</p><blockquote><p>以上内容引至**<a href="https://baike.baidu.com/item/bios/91424">百度百科</a>**。</p></blockquote><h3 id="2-如何进入BIOS"><a href="#2-如何进入BIOS" class="headerlink" title="2. 如何进入BIOS"></a>2. 如何进入BIOS</h3><p>进入bios的方式会因主板的不而不同，不同的主板厂商设定的方式不同的。一般在主机刚刚开机出现厂商<code>logo</code>的时候，通常会在下面有一行小字说明按什么键进入BIOS，这时候按相应的按键就行了。一般为<code>f2</code>、<code>del</code>、<code>f12</code>这些键。也可以去网络上查询当前主板对应的按键。不同主板的bios界面不大相同，但是主体功能是一样的。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430215006199.png" alt="image-20220430215006199"></p><h3 id="3-关闭安全引导（secure-boot）"><a href="#3-关闭安全引导（secure-boot）" class="headerlink" title="3. 关闭安全引导（secure boot）"></a>3. 关闭安全引导（secure boot）</h3><blockquote><p>这一步骤是重中之中，<strong>是必须的操作</strong>！！！操作方式<strong>基本如下</strong>，不同的主板关闭安全引导的方式可能会略有不同。</p></blockquote><p><strong>Security Boot</strong>（安全引导），如果只使用Windows操作系统不打算使用Linux的话，这项默认开启就可以了。如果有要安装Linux需求的话，最好还是关闭（<strong>disabled</strong>）这个选项，否则无法引导。后续将会导致各种各样的问题，如<strong>网络驱动无法安装、系统内核无法修改、驱动丢失</strong>等等。</p><p><strong>Boot Mode</strong>（启动模式），有<code>UEFI</code>和<code>BIOS</code>两种。如果需要扩展到XP等就操作系统的话，需要将<code>SATA模式</code>设置为<strong>Legacy</strong>，并在这里将启动模式设置为BIOS。而如果要安装Win8、Win10、Linux等比较新的操作系统的话，最好使用<strong>UEFI</strong>，可以整体提高系统引导速度和安全性。</p><blockquote><p>SATA Mode：SATA模式，有Legacy和AHCI两种。在安装XP系统的时候，需要Legacy模式才能安装。而现在安装最新的Win10等系统的时候，改成AHCI模式更好并能提高硬盘的性能。</p></blockquote><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220426091340822.png" alt="image-20220426091340822"></p><h2 id="1-3-使用启动盘安装系统"><a href="#1-3-使用启动盘安装系统" class="headerlink" title="1.3 使用启动盘安装系统"></a>1.3 使用启动盘安装系统</h2><blockquote><p>这里是以<code>Ubuntu18.04LTS</code>作为将要安装的系统。</p></blockquote><p>将装好的启动盘插入机器，重启，并在出现logo界面时根据logo下的提示进入<code>开机引导</code>。选择选择U盘，我这里是金士顿的，如图。然后回车，便进入了ubuntu安装界面。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430215026926.png" alt="image-20220430215026926"></p><p>选择第二项安装ubuntu，即<code>install ubuntu</code></p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220426092836484.png" alt="image-20220426092836484"></p><p>接下来就是选择语言的部分，可以选择中文或英文（这里以中文为例）&#x3D;&#x3D;&gt; 安装ubuntu。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430215045976.png" alt="image-20220430215045976"></p><p>下一步的键盘布局（默认即可），再接下来是选择连接网络，这里先不连接。</p><p>接下来的这一步选择正常安装即可（有的版本没有正常安装这一选项，那就全都不选），因为会消耗大量的时间！建议在安装系统后手动进行更新。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430215103906.png" alt="image-20220430215103906"></p><p> 选择安装类型，强烈建议选择“<strong>其他选项</strong>”，通过这个选项我们可以自定义磁盘分区，可操作行比较强。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430215121720.png" alt="image-20220430215121720"></p><p><strong>接下来是<code>分区</code>，也是装机部分最重要，最难的地方！</strong>以下部分的图片是我用网图，当时装机时忘记拍照了（原理是相同的）。</p><p>我们使用提前处理好的1T固态，由于是裸机状态，我们这里显示应该就只有一个<strong>空闲</strong>设备（<code>dev/sd*</code>），大小在1T左右。点击这个设备，选择新建分区表，按照我下面的方式进行分区：</p><blockquote><p>这里我们就使用”<strong>懒人分区法</strong>“，优点是快速简单，缺点是由于没有进行精细的分区，若该磁盘中的某个磁道损坏，系统的修复难度会增加。再进行正式分区之前，我们先来了解几个概念，以便后续操作：</p><ol><li><code>swap</code>：也叫交换分区、交换空间。作用是在系统的物理<strong>内存不够用</strong>的时候，把<strong>硬盘内存</strong>中的一部分空间释放出来，以供当前运行的程序使用。在window中称之为<code>虚拟内存</code>。</li><li><code>efi</code>：</li><li><code>/</code>：</li></ol></blockquote><ol><li><p>配置交换分区</p><p>随着内存技术的发展，对于大多数电脑来说，交换分区存在的一一并不大，就拿笔者个人的双系统（运行内存为16G）来说，当时为linux 划定了8G的交换分区，然后就没然后了……，因为笔者的16G内存基本满足日常需要，因此这个分区一直没有用到。</p><p>网络上有许多”swap为内存的2倍“也不过是一种<strong>以讹传讹</strong>的说法。如果交换分区的使用都超过4GB以上了，可想而知服务器的性能应该差很多了。</p><p>但是对于一些大型主机来说，运行数据较为庞大，还是为其划定交换分区好一些。笔者查阅了许多资料，大体给定了以下分区<strong>建议</strong>：</p><table><thead><tr><th>物理内存大小</th><th>建议swap大小</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;4G</code></td><td>swap &#x3D; 物理内存大小 x 2</td><td>内存较小，运行程序较多时，物理内存出现容量不足的可能性大些。</td></tr><tr><td><code>4-8G</code></td><td>swap &#x3D; 物理内存大小</td><td>无</td></tr><tr><td><code>8-64G</code></td><td>swap &#x3D; 8G</td><td>无</td></tr><tr><td><code>&gt; 64G</code></td><td>swap &#x3D; 16G</td><td>64G以上的交换空间，很少出现物理内存不足的情况了。</td></tr></tbody></table><p>选择<code>空闲</code>的磁盘，点击<code>新建分区表</code>，然后就会弹窗，首先需要将<code>用于</code>设置为<code>交换空间</code>然后根据根据上方的建议设置交换空间即可。</p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220427173802396.png" alt="image-20220427173802396"></p></li><li><p>这里我们使用”<strong>懒人分区法</strong>“，即直接给<code>/</code>划分空间，不再手动给其子目录分配空间。即将空间交给最大的<code>根目录</code>，让系统自动的管理各个子目录的空间大小。该区域的最小空间为<code>20G</code>。根据需求，作者这里给<code>/</code>分配了500G的空间。（以下网图，选择<code>主分区、空间起始位置、EXT4、/</code>）：<img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220429152240269.png" alt="image-20220429152240269"></p></li><li><p>按照往常的装机过程，仅划分这两个区域即可，进行下一步的装机。但是作者这里在完成这一步后，点击安装时却出现了警告，如下图所示。后来发现是因为系统为裸机，没有efi这个分区（EFI是GPT硬盘分区模式中的系统启动分区），从而会报错。</p><p>解决办法是为系统划分一个大约<code>最大1G</code>的efi分区，操作步骤同上，将<code>用于</code>这个地方改为<code>efi分区</code>即可。</p><p>​<img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220429153316915.png" alt="image-20220429153316915"></p><p>最后完成的效果如下（网图）： </p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220427165129607.png" alt="image-20220427165129607"></p></li><li><p>之后就是输入一下个人信息和密码之类的简单操作了，这里不再赘述了。完成这些后等待安装即可。</p></li><li><p>安装完成后需要重启机器，不出意外的话，你就可以正常进入系统了。</p></li></ol><h2 id="1-4-安装网卡驱动"><a href="#1-4-安装网卡驱动" class="headerlink" title="1.4 安装网卡驱动"></a>1.4 安装网卡驱动</h2><p>不出意外的话，作者这里出现了意外…… 当我重启机器，兴高采烈的进入系统后发现竟然没有网络！甚至连网络图标都没有！（后来才想起来是因为没有关闭<code>安全启动</code>导致的，唉～）</p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220429155332280.png" alt="image-20220429155332280"></p><p>第一时间想到了是否机器的网卡损坏了？于是在终端执行一下命令查看网卡是否能够检测到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i net</span><br></pre></td></tr></table></figure><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/2039513-20211109205358031-404031072.png" alt="img"></p><p> 到这里，可以发现系统能够检测到网卡（网卡型号：<code>Realtek PCIe FE Family Controller</code>），说明硬件没有问题。那么是否是网卡驱动没有安装？于是赶紧打开终端输入了以下命令，果然，是没有安装网卡驱动导致的（正常情况下应该有多个ip）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/2039513-20211109204121009-1270281083.png" alt="img"></p><p>于是，作者根据上一步检测到的网卡型号（<code>Realtek PCIe FE Family Controller</code>），利用另外一台机器到其对应的官网（Realtek ）上下了网卡驱动，要注意驱动版本以及系统版本。</p><p><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/2039513-20211109210038614-248006278.png" alt="img"></p><p>下载驱动后，将驱动文件导入到U盘内，并copy到我们的机器上。采用<code>dkms</code>工具安装驱动，但是在这之前，我们需要安装一些依赖项，否则，dkms无法安装。这些依赖在启动盘的<code>/pool/main/</code>下的都存在，因此我们通过启动盘安装这些依赖即可，不必在额外去下载。安装依赖时按照我下面的顺序来即可：</p><blockquote><ol><li>进入<code>/g/gcc-8/</code>目录</li><li>进入<code>/l/linux/</code>目录</li><li>进入<code>/g/glibc/</code>目录</li><li>进入<code>/g/gcc-default/</code>目录</li><li>进入<code>/g/gcc-7/</code>目录</li><li>进入<code>/m/make-dfsg/</code>目录</li><li>进入<code>/d/dpkg-dev/</code>目录</li><li>进入<code>/d/dkms</code>目录（这一步为安装dkms，因此放到最后执行）</li></ol></blockquote><p>进入以上目录后，执行以下命令进行安装。若出现报错，便根据报错提示的缺失包的首字符到对应的包内安装即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i ./*.deb</span><br></pre></td></tr></table></figure><p>至此，我们完成了所有依赖，包括dkms的安装工作。接下来，我们对网卡驱动下手，先将其解压到指定目录<code>/usr/src</code>下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar xvf r8125-9.003.02.tar.bz2 -C /usr/src</span><br></pre></td></tr></table></figure><p>在解压后的文件夹中添加一个<strong>dkms的配置文件</strong>：<code>dkms.conf</code>（文件所在目录：&#x2F;usr&#x2F;src&#x2F;8125-9.006.04&#x2F;dkms.conf）（注意这个目录的名字、下面的配置文件内容、编译驱动时的命令中涉及到驱动版本的地方，<strong>要根据自己的驱动版本进行修改</strong> &lt;我这里是8125-9.006.04&gt; ）</p><p>配置文件的内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PACKAGE_NAME=Realtek_r8125</span><br><span class="line">PACKAGE_VERSION=9.006.04</span><br><span class="line"></span><br><span class="line">DEST_MODULE_LOCATION=/updates/dkms</span><br><span class="line">BUILT_MODULE_NAME=r8125</span><br><span class="line">BUILT_MODULE_LOCATION=src/</span><br><span class="line"></span><br><span class="line">MAKE=<span class="string">&quot;&#x27;make&#x27; -C src/ all&quot;</span></span><br><span class="line">CLEAN=<span class="string">&quot;&#x27;make&#x27; -C src/ clean&quot;</span></span><br><span class="line">AUTOINSTALL=<span class="string">&quot;yes&quot;</span></span><br></pre></td></tr></table></figure><p>接下来使用dkms工具编译驱动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dkms add -m r8125 -v 9.006.04</span><br><span class="line">sudo dkms build -m r8125 -v 9.006.04</span><br><span class="line">sudo dkms install -m r8125 -v 9.006.04</span><br><span class="line">sudo depmod -a</span><br><span class="line">sudo modprobe r8125</span><br></pre></td></tr></table></figure><p>完成以上命令，网卡驱动就安装成功了，如果顺利的话，屏幕右上角也出现了网络的标志。再次输入命令<code>ip a</code>，可以看到出现了新的ip地址。</p><blockquote><p>以上为正常安装所需要执行的过程，但是作者在执行到<code>sudo modprobe r8125</code>时，出现了权限不允许，但是作者已经是使用<code>root（sudo）</code>身份执行的命令啊？于是作者根据报错的关键词去网络上查找。大多数的回答都是**<code>linux内核</code>不允许修改<strong>！原来如此，这里的权限不允许，所指的是内核权限！那么管理内核权限的位置之一就是<code>安全引导</code>这一部分了，于是作者抓紧时间重启机器，进入bios，</strong>将安全引导关闭**！再次启动机器，发现开机就直接有网络标识了！所以，装机时一定要仔细，不要像作者一样粗心大意！</p></blockquote><h2 id="1-5-更换国内源"><a href="#1-5-更换国内源" class="headerlink" title="1.5 更换国内源"></a>1.5 更换国内源</h2><p>网络问题解决了，接下了第一间要做的事情就是将apt源更换为国内的源了（默认为国外的，网速太慢）。</p><h3 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak </span><br></pre></td></tr></table></figure><h3 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将source.list文件内容替换成下面的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># deb cdrom:[Ubuntu 20.04.2.0 LTS _Focal Fossa_ - Release amd64 (20210209.1)]/ focal main restricted</span><br><span class="line"></span><br><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal universe</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal universe</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to use the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal multiverse</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal multiverse</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide useful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#x27;s</span><br><span class="line">## &#x27;partner&#x27; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu users.</span><br><span class="line"># deb http://archive.canonical.com/ubuntu focal partner</span><br><span class="line"># deb-src http://archive.canonical.com/ubuntu focal partner</span><br><span class="line"></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu focal-security main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security universe</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu focal-security universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security multiverse</span><br></pre></td></tr></table></figure><h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3. 更新"></a>3. 更新</h3><p>更新软件源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>更新软件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><blockquote><p><strong>小插曲：</strong></p><p>在执行完软件更新后，作者想通过网络浏览器登录邮箱下载一些配置文件，却发现机器又变成了无网络状态。执行<code>ip a</code>命令，发现又变成了只有一个本地地址的状态。怀疑是由于软件更新，导致网络驱动的一些版本依赖发生问题，因此，又执行命令将网络驱动卸载，并重新挂载，<strong>至此，网络问题才完全解决。</strong></p><p>卸载网络驱动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dkms remove r8125/9.006.04 --all</span><br></pre></td></tr></table></figure><p>重新安装网卡驱动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dkms add -m r8125 -v 9.006.04</span><br><span class="line">sudo dkms build -m r8125 -v 9.006.04</span><br><span class="line">sudo dkms install -m r8125 -v 9.006.04</span><br><span class="line">sudo depmod -a</span><br><span class="line">sudo modprobe r8125</span><br></pre></td></tr></table></figure></blockquote><h1 id="2-磁盘分区和挂载"><a href="#2-磁盘分区和挂载" class="headerlink" title="2. 磁盘分区和挂载"></a>2. 磁盘分区和挂载</h1><h2 id="2-1-图形化分区工具"><a href="#2-1-图形化分区工具" class="headerlink" title="2.1 图形化分区工具"></a>2.1 图形化分区工具</h2><blockquote><p>由于我安装的是桌面版的Ubuntu，因此可以借助图形化工具来进行分区，这里使用的是<strong>GParted分区管理工具</strong>。</p></blockquote><p>GParted是一个<a href="https://so.csdn.net/so/search?q=%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2&spm=1001.2101.3001.7020">图形界面</a>的分区管理工具。传统的 Linux分区工具是FDisk，它需要输入很多的命令，非常的繁琐。而GParted则提供了直观的图形界面，功能也非常的强大。支持多种硬盘分区格式，如FAT、FAT32、NTFS、EXT2、EXT3等。可以建立、删除分区，可以对于分区的空间进行调整等等。</p><p>在使用之前，需要通过简单的安装命令安装<code>GParted</code>，安装完成后，可以通过命令<code>sudo gprted</code>来启动该程序。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/v2-5c634cf47d70cde390ea91e224e9c178_r.jpg" alt="preview"></p><p>图形操作节目就非常简单了，这就不再赘述了，注意以下几点事项即可：</p><ol><li>已经挂载的分区，必须首先卸载，才能进行分区操作（如删除、变更大小等操作）。</li><li>新的磁盘需要格式化后才能使用。</li></ol><h2 id="2-2-设置开机自动挂载"><a href="#2-2-设置开机自动挂载" class="headerlink" title="2.2 设置开机自动挂载"></a>2.2 设置开机自动挂载</h2><p>这一部分我使用的是通过命令行的模式进行磁盘开机自动挂挂载（永久挂载）。当然，Ubuntu18+提供的图形化磁盘管理工具<code>disk</code>同样能够完成该任务。但是作者想用命令行模式（因为熟悉了……）。</p><p>首先，通过如下命令查看系统上所有磁盘列表及其信息，选项-f是可以输出磁盘的UUID。UUID是全局唯一标识符，Linux会将系统内所有的设置都给予一个独一无二的标识符，通过该UUID我们就可以挂载或使用这个设备了。</p><blockquote><p>说明：这里使用的是我的双系统笔记本作为演示，当时操作时没有记录，原理是相同的。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有磁盘列表及UUID</span></span><br><span class="line">lsblk -l</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME        FSTYPE   LABEL       UUID                                 FSAVAIL FSUSE% MOUNTPOIN</span><br><span class="line">sda                                                                                  </span><br><span class="line">├─sda1                                                                               </span><br><span class="line">├─sda2      ntfs     Study       565A92215A91FDC5                      308.3G     7% </span><br><span class="line">├─sda3      ntfs     Works       AA4A3B404A3B0919                      239.8G    20% </span><br><span class="line">└─sda4      ntfs     Tools       F89C42889C42417C                      190.3G    37% </span><br><span class="line">nvme0n1                                                                              </span><br><span class="line">├─nvme0n1p1 vfat     ESP         F28C-8779                             539.4M    17% /boot/efi</span><br><span class="line">├─nvme0n1p2                                                                          </span><br><span class="line">├─nvme0n1p3 ntfs     OS          6EC6DBF8C6DBBE91                                    </span><br><span class="line">├─nvme0n1p4 ntfs     Software    9CB41C16B41BF20E                                    </span><br><span class="line">├─nvme0n1p5 swap                 eaba7c3d-9974-403e-871d-12291214dfc4                [SWAP]</span><br><span class="line">├─nvme0n1p6 ntfs     WINRETOOLS  12DC1249DC12278D                                    </span><br><span class="line">├─nvme0n1p7 ntfs     Image       5C621288621266D4                                    </span><br><span class="line">├─nvme0n1p8 ntfs     DELLSUPPORT 38BC6490BC644B08                                    </span><br><span class="line">└─nvme0n1p9 ext4                 3289a99c-5da3-40de-8a06-726e18bb25a7   81.8G    38% /</span><br></pre></td></tr></table></figure><p>输出结果如上。其中，系统共有两块磁盘，一块为sda（机械），另外一块为nvme01（固态）。先来说明一其中的参数：</p><ul><li><code>NAME</code> ：设备名称，这里会省略<code>dev/</code>等前导目录，即原目录为<code>/dev/sda</code>……</li><li><code>FSTYPE</code>：磁盘&#x2F;分区的文件类型</li><li><code>LABEL</code>：该磁盘&#x2F;分区的标签名称</li><li><code>UUID</code>：全局唯一标识符</li><li><code>FSAVAIL </code>：磁盘&#x2F;分区剩余空间</li><li><code>FSUSE% </code>：磁盘&#x2F;分区的使用率</li><li><code>MOUNTPOIN</code>：磁盘&#x2F;分区的挂载点</li></ul><p>这里我们要挂载的分区为<code>sda2-4</code>分别挂在到以下位置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sda2 挂载到 /media/coderxc/Study</span><br><span class="line">sda3 挂载到 /media/coderxc/Works</span><br><span class="line">sda4 挂载到 /media/coderxc/Tools</span><br></pre></td></tr></table></figure><p>需要注意的是：挂载磁盘前我们需要保证挂载点的目录是<strong>空</strong>的，且<strong>不能重复</strong>。若目录不是空的，则挂载磁盘后，原本的数据将会被隐藏，直到该磁盘卸载后才会出现。</p><p>对于启动时挂载，我们只需将磁盘&#x2F;分区信息注册到<code>/etc/fstab</code>即可。<code>fstab</code>文件的格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">设备文件名/UUID/LABEL挂载点文件系统文件系统参数dump  fsck pass</span><br></pre></td></tr></table></figure><p>说明如下：</p><ol><li><code>设备文件名/UUID/LABEL</code>：用于指定要挂载设备，该标识必须唯一，建议使用UUID。<ul><li>UUID&#x3D;xxxxx</li><li>LABEL&#x3D;xxx</li><li>&#x2F;dev&#x2F;xxxx</li></ul></li><li><code>挂载点</code>：将设备挂载到的系统位置，必须是空目录！</li><li><code>文件系统</code>：即文件系统的类型，如ext4、ntfs等等</li><li><code>文件系统参数</code>：默认情况下使用<code>defaults</code>即可，其参数可去百度一下。</li><li><code>dump </code>：是否支持dump备份，直接输入0即可，因为现在有太多的备份方案。</li><li><code>fsck</code>：开机时自动检测，功能需要支持dump备份，直接输入0即可。</li><li><code>pass</code>：若该文件系统无需在启动时扫描则设置该字段为0.被fsck程序所使用来确定进行在系统重启进行文件系统检查时的顺序，对于根系统&#x2F;引导分区这个值应设为1，其它文件系统可以设为2。</li></ol><p>好了，了解完以上内容，我们就通vim打开文件，并配置好三块分区的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure><p>在文件末尾添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># &lt;file system&gt;                  &lt;mount point&gt;           &lt;type&gt;          &lt;options&gt;          &lt;dump&gt;       &lt;pass&gt;</span><br><span class="line"># add disk</span><br><span class="line">UUID=565A92215A91FDC5           /media/coderxc/Study/     ntfs          defaults            0            2</span><br><span class="line">UUID=AA4A3B404A3B0919           /media/coderxc/Works/     ntfs          defaults            0            2</span><br><span class="line">UUID=F89C42889C42417C           /media/coderxc/Tools/     ntfs          defaults            0            2</span><br></pre></td></tr></table></figure><p>重启电脑，完活～</p><blockquote><p>为了写这篇文章，作者将笔记本的三个分区卸载，然后重新配置了一次。在此之前，作者的开机速度特别慢，尤其是在挂载磁盘后！当时能够猜测出是因为磁盘挂载的缘故，但是没有深入去研究。碰巧这次需要，作者打开了fstab，竟然发现，里面的一条数据配置错了！于是抓紧时间更改过来了。现在想想，因为这条错误数据导致系统启动慢还是比较乐观的结果，万一导致系统无法启动，那就亏大了！</p></blockquote><h1 id="3-内网穿透"><a href="#3-内网穿透" class="headerlink" title="3. 内网穿透"></a>3. 内网穿透</h1><p>由于疫情原因，不能总是在实验室的环境下面对面的使用机器，因此便想着通过<strong>内网穿透</strong>技术，从而能够通过公网访问。</p><p>内网穿透工具有很多，而且大部分收费，当然，保障性也好。碰巧作者之前通过腾讯云的活动，购买了一个轻量级的云服务器。因此，我选择了开源的内网穿透工具<code>frp</code>，通过frp工具和云服务器自己搭建一个私有的内网穿透平台。通frp搭建内网穿透，需要有一定的Linux基础，相信大家能看到这里，这点就毋庸置疑了。</p><blockquote><p>补充，写完这部分内容后发现，读者可能会将<code>客户端</code>、<code>服务器端</code>、<code>机器</code>以及我最后测试使用的另外一台电脑这几着搞混。因此在这里提前说明一下，后面不懂之处回来查阅即可：</p><ol><li><code>客户端</code>：这里指的是frp客户端，也就是我们要访问处于内网的那台机器。</li><li><code>服务器端</code>：这里指的是frp服务器端，也就是处于公网的云服务器。</li><li><code>机器</code>：也就是我们要访问处于内网的那台机器。</li><li><code>测试电脑</code>：我们通过该电脑访问frp服务，从而访问处于内网的那台机器。</li></ol></blockquote><h2 id="3-1-frp简介"><a href="#3-1-frp简介" class="headerlink" title="3.1 frp简介"></a>3.1 frp简介</h2><p>frp 是一个开源项目， 采用 C&#x2F;S 模式，将服务端部署在具有公网 IP 的机器上，客户端部署在内网或防火墙内的机器上，通过访问暴露在服务器上的端口，反向代理到处于内网的服务。 在此基础上，frp 支持 TCP, UDP, HTTP, HTTPS 等多种协议，提供了加密、压缩，身份认证，代理限速，负载均衡等众多能力。</p><p>项目地址：<a href="https://link.zhihu.com/?target=https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>文档地址：<a href="https://link.zhihu.com/?target=https://gofrp.org/docs">https://gofrp.org/docs</a></p><p>项目下载，下面是通过wget方式直接在服务器端下载，也可以在客户机下载然后传输到服务器端。下载时注意下载对应的平台和版本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>项目的目录结构如下。该项目包含客户端和服务器端的配置文件和启动工具。以<code>frpc</code>开头的是客户端（client）相关; 以<code>frps</code>开头的是服务器端相关。</p><ul><li><code>frpc</code>和<code>frps</code>是客户端&#x2F;服务器端启动程序的可执行文件。</li><li>frpc.ini和frps.ini是客户端&#x2F;服务器端的配置文件</li><li>systemd是已经配置好的系统工具，可以通过简单配置完成全局配置、开机自启动的等功能。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── frpc</span><br><span class="line">├── frpc_full.ini</span><br><span class="line">├── frpc.ini</span><br><span class="line">├── frps</span><br><span class="line">├── frps_full.ini</span><br><span class="line">├── frps.ini</span><br><span class="line">├── LICENSE</span><br><span class="line">└── systemd</span><br><span class="line">    ├── frpc.service</span><br><span class="line">    ├── frpc@.service</span><br><span class="line">    ├── frps.service</span><br><span class="line">    └── frps@.service</span><br></pre></td></tr></table></figure><h2 id="3-2-frp工作原理"><a href="#3-2-frp工作原理" class="headerlink" title="3.2 frp工作原理"></a>3.2 frp工作原理</h2><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220501154917936.png" alt="image-20220501154917936"></p><ol><li><p>frps服务端运行，监听一个端口((bind_port))，等待客户端的连接</p></li><li><p>frpc客户端运行，连接到服务端的端口(bind_port)，同时告诉服务端要监听的端口(remote_port)和转发类型</p></li><li><p>服务端fork新的进程监听客户端指定的端口(remote_port)</p></li><li><p>外网用户连接到客户端指定的端口(remote_port)，服务端通过和客户端的连接将数据转发到客户端</p></li><li><p>客户端进程再将数据转发到本地服务，从而实现内网对外暴露服务的能力。</p></li></ol><h2 id="3-3-服务器端配置"><a href="#3-3-服务器端配置" class="headerlink" title="3.3 服务器端配置"></a>3.3 服务器端配置</h2><p>这里所指的服务器端也就是指我的云服务器了。第一步就是<strong>下载</strong>程序并解压。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo tar -axvf frp_0.42.0_linux_amd64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压后的目录</span></span><br><span class="line"><span class="built_in">cd</span> frp_0.42.0_linux_amd64</span><br></pre></td></tr></table></figure><p>通过vim更改服务器端配置文件<code>sudo vim frps.ini</code>，注意这里的<code>s</code>：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 绑定的客户段地址，这里设置任意地址</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment"># 服务器端与客户端互相绑定的端口，需要防火墙放行该端口</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">55555</span></span><br><span class="line"><span class="comment"># frp管理后台的访问端口，通过ip:port,你可以进入frp的后台管理界面</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">55556</span>，需要防火墙放行该端口</span><br><span class="line"><span class="comment"># frp管理后台的登录用户名</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="comment"># frp管理后台的登录密码，这里以xxx代替，自行更换为复杂的密码</span></span><br><span class="line"><span class="attr">dashboard_pwd</span> = xxxx</span><br><span class="line"><span class="comment"># 客户端与服务器端的验证方式，这里指定的token</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="comment"># token密码，这里以xxx代替，自行更换为复杂的密码</span></span><br><span class="line"><span class="attr">token</span> = xxxx</span><br><span class="line"><span class="comment"># frp日志配置，日志类别：trace, debug, info, warn, error</span></span><br><span class="line"><span class="attr">log_file</span> = /var/log/frps.log</span><br><span class="line"><span class="attr">log_level</span> = info </span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>我使用的云服务器，因此我通过平台提供的工具，放行了<code>5555</code>端口和<code>5556</code>端口。</p></blockquote><p>设置和启动服务器端的frp服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将相关文件移动到合理位置</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/frp</span><br><span class="line">sudo <span class="built_in">cp</span> frps.ini /etc/frp</span><br><span class="line">sudo <span class="built_in">cp</span> frps /usr/bin</span><br><span class="line">sudo <span class="built_in">cp</span> systemd/frps.service /usr/lib/systemd/system/</span><br><span class="line"><span class="comment"># 重新加载 systemctl</span></span><br><span class="line">sudo systemctl daemon-reload </span><br><span class="line"><span class="comment"># 设置开启自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frps</span><br><span class="line"><span class="comment"># 开启frp服务</span></span><br><span class="line">sudo systemctl start frps</span><br></pre></td></tr></table></figure><p>此时，服务器端的frp已经配置完成，你可以通过访问<code>ip:55556</code>来查看运行状态，如下图所示：</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220501124804602.png" alt="image-20220501124804602"></p><h2 id="3-3-客户端配置"><a href="#3-3-客户端配置" class="headerlink" title="3.3 客户端配置"></a>3.3 客户端配置</h2><p>客户端的操作基本和服务器端相同，但是需要注意配置的文件名称！ 同样是下载相同的程序，你也可以将刚才下载的程序copy过来，解压到家目录即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo tar -axvf frp_0.42.0_linux_amd64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压后的目录</span></span><br><span class="line"><span class="built_in">cd</span> frp_0.42.0_linux_amd64</span><br></pre></td></tr></table></figure><p>通过vim更改配置文件<code>sudo vim frpc.ini</code>，注意这里的c，即client：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 服务器端的ip地址</span></span><br><span class="line"><span class="attr">server_addr</span> = ip</span><br><span class="line"><span class="comment"># 服务器端与客户端互相绑定的端口，需要防火墙放行该端口，即服务器端配置的 bind_port = 55555</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">55555</span></span><br><span class="line"><span class="comment"># 客户端与服务器端的验证方式，这里指定为token，需要和服务器端相同</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="comment"># token密码，需要和服务器端相同</span></span><br><span class="line"><span class="attr">token</span> = xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本机配置，[sshx]若为多台机器，则该x的编号不能重复</span></span><br><span class="line"><span class="section">[ssh5]</span></span><br><span class="line"><span class="comment"># 通信方式，因为目前仅仅需要通过ssh的方式登录，因此只开通tcp即可</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="comment"># 本地ip，一般写127.0.0.1即可</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># ssh端口号</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="comment"># 自定义远程登录的端口号，你可以通过访问服务器端的IP:该端口号 登录该服务器，</span></span><br><span class="line"><span class="comment"># 注意服务器的防火墙需要放行该端口</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">10005</span></span><br></pre></td></tr></table></figure><p>若客户端为多台的话，需要更改的位置有<code>[sshx]</code>分组名称和最后的<code>remote_port</code>端口号。接下来就是文件分配和启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将相关文件移动到合理位置</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/frp</span><br><span class="line">sudo <span class="built_in">cp</span> frpc.ini /etc/frp</span><br><span class="line">sudo <span class="built_in">cp</span> frpc /usr/bin</span><br><span class="line">sudo <span class="built_in">cp</span> systemd/frpc.service /usr/lib/systemd/system/</span><br><span class="line"><span class="comment"># 重新加载 systemctl</span></span><br><span class="line">sudo systemctl daemon-reload </span><br><span class="line"><span class="comment"># 设置开启自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frpc</span><br><span class="line"><span class="comment"># 开启frp服务</span></span><br><span class="line">sudo systemctl start frpc</span><br></pre></td></tr></table></figure><p>到此位置，frp就都配置完毕了，以下为登录测试阶段，使用ssh等一系列远程登录的软件，假设我们要登录的机器上已经存在帐号C。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 10005 C@服务端ip</span><br></pre></td></tr></table></figure><p>输入密码，若登录成功，就说明大功告成了！</p><h1 id="4-用户管理"><a href="#4-用户管理" class="headerlink" title="4. 用户管理"></a>4. 用户管理</h1><p>目前机器上需要3个用户帐号，分別供3个人使用。其中一个用户需要拥有管理员权限，另外两人无管理员权限。同时对于挂载在<code>/media/data</code>分区，所有人都拥有进行<strong>读写执行</strong>(rwx)权限。同时， 为保证用户数据安全，每个用户之间不能互相访问家目录。</p><h2 id="4-1-用户配置"><a href="#4-1-用户配置" class="headerlink" title="4.1 用户配置"></a>4.1 用户配置</h2><p>这里我们假设拥有管理员权限的用户为A，另外两个普通用户为B、C。为方便管理，我们3个用户都放置在stdents用户组中。<strong>注意，以下操作均是使用<code>root</code>用户。</strong></p><ol><li>新建用户组</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -r students</span><br></pre></td></tr></table></figure><ol start="2"><li>增加用户</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -g students -md /media/jixie1/A -c <span class="string">&quot;用户A，拥有管理员权限&quot;</span> -s /bin/bash A</span><br><span class="line">useradd -g students -md /media/jixie1/B -c <span class="string">&quot;用户B&quot;</span> -s /bin/bash B</span><br><span class="line">useradd -g students -md /media/jixie1/C -c <span class="string">&quot;用户C&quot;</span> -s /bin/bash C</span><br></pre></td></tr></table></figure><ol start="3"><li>为用户设置登录密码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo “xxxx” | passwd --stdin A</span><br><span class="line">echo “xxxx” | passwd --stdin C</span><br><span class="line">echo “xxxx” | passwd --stdin C</span><br></pre></td></tr></table></figure><blockquote><p>该方式不用重复输入密码，比较方便。但是会将记录保存在history中，因此，在操作完成后记得<strong>清空</strong>history。</p></blockquote><ol start="3"><li>为用户A增加管理员权限</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="comment"># 在文件末尾添加如下内容</span></span><br><span class="line">A ALL=(ALL:ALL) ALL</span><br><span class="line"><span class="comment"># 保存并退出文件</span></span><br></pre></td></tr></table></figure><ol start="4"><li>设置各个用户家目录权限，其它用户不可以访问</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 A</span><br><span class="line"><span class="built_in">chmod</span> 700 B</span><br><span class="line"><span class="built_in">chmod</span> 700 C</span><br></pre></td></tr></table></figure><h2 id="4-2-共享空间Data盘配置"><a href="#4-2-共享空间Data盘配置" class="headerlink" title="4.2 共享空间Data盘配置"></a>4.2 共享空间Data盘配置</h2><p>配置data盘，保证所有人都具有读写执行权限，参数-R为递归执行，既包含设置子文件的权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 770 /media/data</span><br><span class="line"><span class="comment"># s权限是保证新添加的文件/目录也会拥有相同权限</span></span><br><span class="line"><span class="built_in">chmod</span> +s /media/data</span><br></pre></td></tr></table></figure><h2 id="4-3-关闭密码登录"><a href="#4-3-关闭密码登录" class="headerlink" title="4.3 关闭密码登录"></a>4.3 关闭密码登录</h2><p>首先，我们在个人笔记本上生成3个不同的密钥和公钥，用于稍后的分发密钥并指定其文件的存放位置和文件名。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;user A&quot;</span> -f ~/.ssh/A/A_id_rsa</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;user B&quot;</span> -f ~/.ssh/B/B_id_rsa</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;user C&quot;</span> -f ~/.ssh/C/C_id_rsa</span><br></pre></td></tr></table></figure><p>在我的个人笔记本上含有多个密钥，因此需要创建ssh的配置文件来管理这些密钥。通过<code>vim ~/.ssh/config</code>创建配置文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 远程主机别名</span><br><span class="line">HostName 远程主机的域名或ip</span><br><span class="line">Port 远程主机的端口号（可选，默认22）</span><br><span class="line">User 登录的用户名（若没有指定，则默认使用当前执行用户的用户名）</span><br><span class="line">    PreferredAuthentications publickey 验证方式</span><br><span class="line">    IdentityFile ~/.ssh/A/A_id_rsa  密钥存放位置</span><br></pre></td></tr></table></figure><p>如下是我config中的配置，可做参考：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 实验室server05 A</span><br><span class="line">Host aServer05</span><br><span class="line">        HostName 123.123.123.123</span><br><span class="line">        Port 10005</span><br><span class="line">        User A</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/A/A_id_rsa</span><br><span class="line"></span><br><span class="line"># 实验室server05 B</span><br><span class="line">Host bServer05</span><br><span class="line">        HostName 123.123.123.123</span><br><span class="line">        Port 10005</span><br><span class="line">        User B</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/B/B_id_rsa</span><br><span class="line"></span><br><span class="line"># 实验室server05 c</span><br><span class="line">Host cServer05</span><br><span class="line">        HostName 123.123.123</span><br><span class="line">        Port 10005</span><br><span class="line">        User C</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/C/C_id_rsa</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">        HostName github.com</span><br><span class="line">        User git</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/github/github_id_rsa</span><br></pre></td></tr></table></figure><p>分别登录对应用户，并将<strong>公钥</strong>写入到对应用户家目录下的<code>authorized_keys</code>文件中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ssh</span><br><span class="line">└── authorized_keys</span><br></pre></td></tr></table></figure><p>设置该文件的权限为仅拥有者具有读写执行权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 authorized_keys</span><br></pre></td></tr></table></figure><p>由于服务器暴露在公网上，使用密码登录有大概率被暴力破解，因此为保证安全性，作者将服务器禁止了密码登录和root用户登录。该部分的配置文件是在<code>/etc/ssh/sshd_config</code>，我们首先通过vim打开配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#禁止使用密码验证登录</span></span><br><span class="line">PasswordAuthentication no    </span><br><span class="line">ChallengeResponseAuthentication no </span><br><span class="line"><span class="comment"># 启RSA验证</span></span><br><span class="line">RSAAuthentication <span class="built_in">yes</span>  </span><br><span class="line"><span class="comment">#是否使用公钥验证</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span>   </span><br><span class="line"><span class="comment">#公钥的保存位置</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line"><span class="comment"># 禁止root用户登录</span></span><br><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><p>配置完文件后，保存并退出，重启ssh服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>ok，该部分完成，可自行进行测试。</p><h1 id="5-搭建anaconda环境"><a href="#5-搭建anaconda环境" class="headerlink" title="5. 搭建anaconda环境"></a>5. 搭建anaconda环境</h1><p>Ubuntu虽然有自带的python程序，但是对于大数据和机器学习来说，需要大量的第三方库，且这些第三方库需要手动下载。而<strong>Anaconda是一个开源的python集成开发环境，包含有大量常用的第三方库</strong>，极大的方便了开发人员。</p><p>搭建Anaconda环境的方式有两种，一种是全局搭建，即所有用户都可以使用同一个Anaconda，另外一种方式是为每个用户单独搭建Anaconda环境。每种方式各有利弊，这里作者都记录一下，自取所需即可。</p><h2 id="5-1-全局搭建"><a href="#5-1-全局搭建" class="headerlink" title="5.1 全局搭建"></a>5.1 全局搭建</h2><h3 id="1-下载Anaconda3"><a href="#1-下载Anaconda3" class="headerlink" title="1. 下载Anaconda3"></a>1. 下载Anaconda3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash Anaconda3-2020.02-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><ul><li>指定安装路径为<code>/usr/local/anaconda3</code></li></ul><h3 id="3-修改权限"><a href="#3-修改权限" class="headerlink" title="3. 修改权限"></a>3. 修改权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 -R /usr/local/anaconda3</span><br></pre></td></tr></table></figure><h3 id="4-初始化conda"><a href="#4-初始化conda" class="headerlink" title="4. 初始化conda"></a>4. 初始化conda</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(/usr/local/anaconda3/bin/conda shell.bash hook)</span>&quot;</span> &amp;&amp; conda init bash</span><br></pre></td></tr></table></figure><h3 id="5-更换conda国内源"><a href="#5-更换conda国内源" class="headerlink" title="5. 更换conda国内源"></a>5. 更换conda国内源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda -V <span class="comment"># 显示coda版本</span></span><br></pre></td></tr></table></figure><h2 id="5-2-私有用户搭建"><a href="#5-2-私有用户搭建" class="headerlink" title="5.2 私有用户搭建"></a>5.2 私有用户搭建</h2><p>执行以下命令时切换到对应用户，请保证处于家目录(~)下：</p><h3 id="1-下载Anaconda3-1"><a href="#1-下载Anaconda3-1" class="headerlink" title="1. 下载Anaconda3"></a>1. 下载Anaconda3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -<span class="comment"># -O https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh</span></span><br></pre></td></tr></table></figure><h3 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2. 安装"></a>2. 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash ./Anaconda3-2020.02-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><ul><li>路径默认即可，默认为用户家目录</li></ul><h3 id="3-初始化conda"><a href="#3-初始化conda" class="headerlink" title="3. 初始化conda"></a>3. 初始化conda</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(/usr/local/anaconda3/bin/conda shell.bash hook)</span>&quot;</span> &amp;&amp; conda init bash</span><br></pre></td></tr></table></figure><h3 id="4-更换conda国内源"><a href="#4-更换conda国内源" class="headerlink" title="4. 更换conda国内源"></a>4. 更换conda国内源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda -V <span class="comment"># 显示coda版本</span></span><br></pre></td></tr></table></figure><h1 id="6-机器学习环境搭建"><a href="#6-机器学习环境搭建" class="headerlink" title="6. 机器学习环境搭建"></a>6. 机器学习环境搭建</h1><p>当前最流行的机器学习框架有很多种，最流行的框架有是tensorflow和pytorch两种。因此这里记录了这两种框架的搭建。为了便于安装和删除，以及统一管理和互相隔离，作者选择了在conda虚拟环境中搭建两种框架的环境。</p><blockquote><p>什么是acaconda的虚拟环境：</p><ul><li>虚拟环境：每个环境之间是隔离的，都可以设定不同的python版本以及各种包，不和系统的冲突，可以随便切换，要删除也是整个一起清理。</li><li>可以简单理解为acaconda是一个环境管理工具，可以通过它创建多个相互隔离的、互不影响的、版本不同的python环境。</li><li>conda： 一个anaconda的工具管理器，它的作用和pip类似，但是比pip更强大。pip能做的conda也能做。</li></ul></blockquote><h2 id="6-1-tensorflow2-2-GPU"><a href="#6-1-tensorflow2-2-GPU" class="headerlink" title="6.1 tensorflow2.2-GPU"></a>6.1 tensorflow2.2-GPU</h2><ol><li>创建虚拟环境并激活该环境</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个python版本为3.7的环境，环境名称可以自定义</span></span><br><span class="line">conda create -n your_env_name python=3.7</span><br><span class="line"><span class="comment"># 激活并进入该虚拟环境</span></span><br><span class="line">conda activate your_env_name</span><br></pre></td></tr></table></figure><ol start="2"><li>安装CUDA10.1</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install cudatoolkit=10.1 </span><br></pre></td></tr></table></figure><ol start="3"><li>安装cudnn7.6</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install cudnn=7.6.5</span><br></pre></td></tr></table></figure><ol start="4"><li>安装tensorflow-gpu</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install tensorflow-gpu==2.2.0 -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><ol start="5"><li>测试conda环境。完成以上步骤后请<strong>关闭终端并重新进入该虚拟环境</strong>！在控制台输入<code>python3</code>激活并进入Ipython：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">version = tf.__version__</span><br><span class="line">gpu_ok = tf.test.is_gpu_available()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tf version:&quot;</span>,version,<span class="string">&quot;\nuse GPU&quot;</span>,gpu_ok)</span><br><span class="line"><span class="comment"># 输出True即为安装成功。</span></span><br></pre></td></tr></table></figure><blockquote><p>提供删除虚拟环境命令:</p><p>conda env remove –name your_env_name</p></blockquote><h2 id="6-2-pytorch-GPU"><a href="#6-2-pytorch-GPU" class="headerlink" title="6.2 pytorch-GPU"></a>6.2 pytorch-GPU</h2><h3 id="1-创建虚拟环境"><a href="#1-创建虚拟环境" class="headerlink" title="1. 创建虚拟环境"></a>1. 创建虚拟环境</h3><p>首先在uubuntu界面打开终端：输入以下命令来创建一个新的python环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n your_env_name python=3.7</span><br></pre></td></tr></table></figure><ul><li><code>create</code>：python虚拟环境的创建命令</li><li><code>-n</code>：指定创建虚拟环境的名称</li><li><code>python=3.x</code>：指定虚拟环境中python的版本，x可以为[6,7,……]</li><li>安装过程中会有提示，输入<code>y</code>或<code>yes</code>即可。</li></ul><p>这里以<code>pytorch_test</code>作为虚拟python环境的名称，执行成功后终端的提示符前会增加一个<code>（base）</code>的标志，这说明当前正处在base虚拟环境下：</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220410164442193.png" alt="image-20220410164442193"></p><h3 id="2-安装-2"><a href="#2-安装-2" class="headerlink" title="2. 安装"></a>2. 安装</h3><blockquote><p>以下教程都是在新建的虚拟环境中执行，即通过以下命令激活我们刚刚创建的python虚拟环境。我们所下载和安装的各种包都会保存在该虚拟环境中，如果真的出现问题且无法修复，我们可以删除该python虚拟环境再次创建一个新的虚拟环境进行测试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate pytorch_test</span><br></pre></td></tr></table></figure><ul><li>当命令行开头变为(pytorch_test)……时，说明我们已经进入该虚拟环境了</li></ul></blockquote><h4 id="2-1-安装cudatoolkit10-1"><a href="#2-1-安装cudatoolkit10-1" class="headerlink" title="2.1 安装cudatoolkit10.1"></a>2.1 安装cudatoolkit10.1</h4><blockquote><p>安装CUDA，CUDA是英伟达专门为GPU计算推出的计算平台</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install cudatoolkit=10.1 </span><br></pre></td></tr></table></figure><h4 id="2-2-安装cudnn7-6"><a href="#2-2-安装cudnn7-6" class="headerlink" title="2.2 安装cudnn7.6"></a>2.2 安装cudnn7.6</h4><blockquote><p>安装cuDNN，cuDNN是英伟达为CUDA加速运算推出的加速库</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install cudnn=7.6.5</span><br></pre></td></tr></table></figure><h4 id="2-3-安装pytorch-GPU"><a href="#2-3-安装pytorch-GPU" class="headerlink" title="2.3 安装pytorch-GPU"></a>2.3 安装pytorch-GPU</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.4.0 torchvision==0.5.0 cudatoolkit=10.1</span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>关闭终端，重新进入该环境，并输入<code>python3</code>进入python的交互模式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><ul><li><p>输出True即为安装成功。</p><p><img src="/img/Linux%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220410183208084.png" alt="image-20220410183208084"></p></li></ul><p>提供删除虚拟环境命令</p><blockquote><p>提供删除虚拟环境命令: 使用<code>exit</code>命令退出当前环境后，执行<code>conda env remove --name your_env_name</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发手册初始Git.md</title>
      <link href="/article/cd73afd4.html"/>
      <url>/article/cd73afd4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1. Git简介"></a>1. Git简介</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>git官网：<a href="https://git-scm.com/">https://git-scm.com</a></p><blockquote><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本控制就是一种用于管理项目、文件、目录等的一种技术手段，他可以实现对内容<code>历史控制</code>，就如同下图中的手动版本控制。通过版本控制技术，我们可以有效的实现对内容的查看历史记录、备份以及恢复文件等操作。可以简单的认为是一个版本管理器。</p></blockquote><p>通过版本控制可以实现以下功能：</p><ul><li>对文件的备份、历史记录的操作，起到保护作用</li><li>跨区域协同开发，协同办公，减轻负担</li><li>跟踪和记录项目开发过程</li></ul><h2 id="2-Git-amp-SVN"><a href="#2-Git-amp-SVN" class="headerlink" title="2. Git&amp;SVN"></a>2. Git&amp;SVN</h2><h3 id="2-1-Git"><a href="#2-1-Git" class="headerlink" title="2.1 Git"></a>2.1 Git</h3><p>git就是分布式的版本控制系统。<code>所有</code>的版本信息仓库都同步到了<code>本地</code>，用户可以离线查看左右版本记录，也可以离线在本地提交，工作时直接在本地编辑，联网时再推送至云端。</p><p><img src="/img/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%88%9D%E5%A7%8BGit/image-20210817175632159.png" alt="image-20210817175632159"></p><h3 id="2-2-SVN"><a href="#2-2-SVN" class="headerlink" title="2.2 SVN"></a>2.2 SVN</h3><p>SVN是集中式版本控制的代表。项目的<code>所有版本</code>数据都保存在<code>服务器</code>上，开发者工作时需要从服务器获得最新版本到本地，然后进行修改或编辑。开发者离线时不能查看历史版本或在不同不同分支工作。</p><p><img src="/img/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%88%9D%E5%A7%8BGit/image-20210817175700405.png" alt="image-20210817175700405"></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>linux系列安装git很简单，执行一条命令即可。更多其它版本安装请查看官方文档：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h3 id="Debian-x2F-Ubuntu"><a href="#Debian-x2F-Ubuntu" class="headerlink" title="Debian&#x2F;Ubuntu"></a>Debian&#x2F;Ubuntu</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line"> sudo apt update; apt install git</span><br></pre></td></tr></table></figure><h3 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git           # (up to Fedora 21)</span><br><span class="line">dnf install git             # (Fedora 22 and later)</span><br></pre></td></tr></table></figure><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S git</span><br></pre></td></tr></table></figure><h3 id="openSUSE"><a href="#openSUSE" class="headerlink" title="openSUSE"></a>openSUSE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zypper install git </span><br></pre></td></tr></table></figure><h3 id="centos-x2F-RHEL"><a href="#centos-x2F-RHEL" class="headerlink" title="centos&#x2F;RHEL"></a>centos&#x2F;RHEL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install  -y git</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>直接下载（淘宝镜像），傻瓜式安装即可。</p><h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h2><h3 id="3-1-设置用户信息"><a href="#3-1-设置用户信息" class="headerlink" title="3.1 设置用户信息"></a>3.1 设置用户信息</h3><p>用户信息包括用户名和用户邮箱，这将会在用户提交时使用到。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xcy.小相&quot;</span></span><br><span class="line"><span class="comment"># 邮箱</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xc2532800855@163.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-查看配置信息"><a href="#3-2-查看配置信息" class="headerlink" title="3.2 查看配置信息"></a>3.2 查看配置信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看系统git配置信息</span></span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户git配置信息</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h2 id="4-Git工作区域"><a href="#4-Git工作区域" class="headerlink" title="4.Git工作区域"></a>4.Git工作区域</h2><p>git含有4个工作区域，3个本地工作区域（<code>工作目录</code>、<code>暂存区</code>、<code>资源库</code>）和一个远程工作区域（远程仓库）。</p><ul><li>工作目录：平时存放代码的位置</li><li>暂存区：用与存放临时改动的文件</li><li>资源库：本地存放所有版本数据的地方</li><li>远程仓库：托管d代码的服务器</li></ul><p><img src="/img/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%88%9D%E5%A7%8BGit/image-20210817185744439.png" alt="image-20210817185744439"></p><ul><li>Directory：使用git管理的一个目录，也就是一个仓库，包含我们的工作空间和git的管理空间。</li><li>Workspace：通过git管理的目录和文件，即工作空间。</li><li>.git：存放git管理信息的目录，初始化仓库是自动创建。</li><li>Index&#x2F;stage：暂存区（待提交区）在提交进入repository前，我们可以将所有的更新放在暂存区。</li><li>Local Repository:本地仓库，存放在本地的版本库；head会只是当前的开发分支。</li><li>stash：隐藏，是一个工作状态保存栈，用户保存或恢复workspace中的临时状态。</li></ul><p><img src="/img/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%88%9D%E5%A7%8BGit/image-20210817202849817.png" alt="image-20210817202849817"></p><p>git的工作流程：</p><ol><li>在工作目录中添加、修改文件</li><li>将需要进行版本管理的文件放入暂存区（git add .）</li><li>将詹存区的文件提交到本地git仓库(git commit)</li><li>将文件推送到远程仓库（git push）</li></ol><h2 id="5-Git命令"><a href="#5-Git命令" class="headerlink" title="5. Git命令"></a>5. Git命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>使用当前目录做为工作目录,首先要初始化当前目录。初始化后，会在当前工作目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>复制一个远程仓库做为本地项目。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程仓库地址 本地仓库名称</span><br></pre></td></tr></table></figure><blockquote><p>若不加本地仓库名称，则默认与仓库同名。</p></blockquote><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>添加文件至暂存区。</p><p>常用命令为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment"># 添加当前目录下所有文件至暂存区</span></span><br><span class="line">git add file <span class="comment"># 添加指定文件至暂存区</span></span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>提交暂存区文件至本地仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m “文件描述信息” </span><br></pre></td></tr></table></figure><h3 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add"></a>git remote add</h3><p>配置远程仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;名称&gt; &lt;地址&gt;</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>推送本地仓库至远程仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;名称&gt;</span><br></pre></td></tr></table></figure><h2 id="6-项目搭建"><a href="#6-项目搭建" class="headerlink" title="6. 项目搭建"></a>6. 项目搭建</h2><h3 id="6-1-创建本地仓库"><a href="#6-1-创建本地仓库" class="headerlink" title="6.1 创建本地仓库"></a>6.1 创建本地仓库</h3><ol><li><p>创建一个项目目录，切换到项目根目录下执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>执行之后可以看到文件根目录下有一个.git目录，该目录包含关于版本等的所有信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/Study/Git » <span class="built_in">mkdir</span> gitCode                                                  </span><br><span class="line">~/Study/Git » <span class="built_in">cd</span> gitCode  </span><br><span class="line"></span><br><span class="line">~/Study/Git/gitCode » git init                                               </span><br><span class="line">已初始化空的 Git 仓库于 /media/xioaxiang/Study/Git/gitCode/.git/</span><br><span class="line"></span><br><span class="line">~/Study/Git/gitCode(master) » tree -a .                                     </span><br><span class="line">└── .git</span><br><span class="line">    ├── branches</span><br><span class="line">    ├── config</span><br><span class="line">    ├── description</span><br><span class="line">    ├── HEAD</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── applypatch-msg.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-merge-commit.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   └── update.sample</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── info</span><br><span class="line">    │   └── pack</span><br><span class="line">    └── refs</span><br><span class="line">        ├── heads</span><br><span class="line">        └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 16 file                                     </span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-克隆远程仓库"><a href="#6-2-克隆远程仓库" class="headerlink" title="6.2 克隆远程仓库"></a>6.2 克隆远程仓库</h3><ol><li><p>克隆一个项目和它的整个代码历史（版本信息）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git项目url</span><br></pre></td></tr></table></figure></li><li><p>&#96;&#96;&#96;bash<br>&#x2F;Study&#x2F;Git&#x2F;gitCode(master) » git clone <a href="https://gitee.com/lizhivscaomei/docker_learning_notes.git">https://gitee.com/lizhivscaomei/docker_learning_notes.git</a><br>正克隆到 ‘docker_learning_notes’…<br>remote: Enumerating objects: 110, done.<br>remote: Counting objects: 100% (110&#x2F;110), done.<br>remote: Compressing objects: 100% (90&#x2F;90), done.<br>remote: Total 110 (delta 26), reused 0 (delta 0), pack-reused 0<br>接收对象中: 100% (110&#x2F;110), 12.47 KiB | 911.00 KiB&#x2F;s, 完成.<br>处理 delta 中: 100% (26&#x2F;26), 完成.</p><p>~&#x2F;Study&#x2F;Git&#x2F;gitCode(master*) » ls<br>docker_learning_notes</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7. Git文件操作</span><br><span class="line"></span><br><span class="line">### 7.1 文件的四种状态</span><br><span class="line"></span><br><span class="line">![image-20210817220020750](/img/开发手册初始Git/image-20210817220020750.png)</span><br><span class="line"></span><br><span class="line">1. Untracked：**未跟踪**状态。表示该文件存在于工作目录中，但是并没有添加到git库，不参与版本控制。通过`git add`命令将文件添加到暂存区中，即状态变为`staged`。</span><br><span class="line">2. Unmodify:**文件已入库但未修改**状态。该文件最终有两种去处：被修改（Modified），通过`git rm`移出版本库（Untracked）。</span><br><span class="line">3. Modified：**文件已修改**状态。该文件最终有两种去处：通过`git add`进入暂存（staged）状态，使用`git checkout`命令丢弃修改返回到unmodify状态。</span><br><span class="line">4. staged：暂存状态，执行`git commit`命令则将修改同步到库中。这时库中的文件和本地文件又变为一致，文件状态变为Unmodify状态。</span><br><span class="line"></span><br><span class="line">### 7.2 查看文件状态</span><br><span class="line"></span><br><span class="line">- 查看单个文件状态：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  git status 文件名</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>查看全部文件状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新文件</span></span><br><span class="line">~/Study/Git/gitCode(master) » <span class="built_in">touch</span> newFile.txt                   </span><br><span class="line">~/Study/Git/gitCode(master*) » <span class="built_in">ls</span>                                 </span><br><span class="line">newFile.txt</span><br><span class="line"><span class="comment"># 查看文件状态</span></span><br><span class="line">~/Study/Git/gitCode(master*) » git status                         </span><br><span class="line">位于分支 master</span><br><span class="line">尚无提交</span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 <span class="string">&quot;git add &lt;文件&gt;...&quot;</span> 以包含要提交的内容）</span><br><span class="line">newFile.txt</span><br><span class="line">提交为空，但是存在尚未跟踪的文件（使用 <span class="string">&quot;git add&quot;</span> 建立跟踪）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件添加至暂存区</span></span><br><span class="line">~/Study/Git/gitCode(master*) » git add .                         <span class="comment"># 将文件添加到本地仓库 -m 表示备注信息</span></span><br><span class="line">~/Study/Git/gitCode(master*) » git commit -m <span class="string">&quot;new file&quot;</span>                    </span><br><span class="line">[master （根提交） 5b9223d] new file</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 newFile.txt</span><br><span class="line"></span><br><span class="line">~/Study/Git/gitCode(master) » git status                                   </span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-3-忽略文件"><a href="#7-3-忽略文件" class="headerlink" title="7.3 忽略文件"></a>7.3 忽略文件</h3><p>git默认是将本地工作目录中的<strong>所有文件</strong>都提交，即将所有文件都纳入版本控制中。但有时因为部分原因我们<strong>需要忽略部分文件</strong>，不纳入版本控制之中。这时，我们就可以通过<code>.gitignore</code>文件来进行忽略设置。</p><p>在主目录下下创建.gitignore文件：</p><ol><li><p>#号开头的内容会被忽略掉，相当于注释内容</p></li><li><p>可以使用linux通配符。</p></li><li><p>以！开头表示例外规则，将不会被忽略</p></li><li><p>名称最前面添加路分隔符<code>/</code>，表示忽略根路径下的某文件</p></li><li><p>名称的最后面天添加路径分隔符<code>/</code>，表示忽略所有文件名为该名称的文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的后缀名为md的文件</span><br><span class="line">*.md   </span><br><span class="line"></span><br><span class="line"># readme.md除外的文件全部被忽略</span><br><span class="line">！readme.md  </span><br><span class="line"></span><br><span class="line"># 忽略路径为/files文件及其子目录中的内容</span><br><span class="line">/files  </span><br><span class="line"></span><br><span class="line"># 忽略所有名为files下的所有文件</span><br><span class="line">files/ </span><br></pre></td></tr></table></figure><blockquote><p>idea中使用.gitignore</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Created by .ignore support plugin (hsz.mobi)</span><br><span class="line">### Java template</span><br><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line"># other more</span><br><span class="line">.idea/</span><br><span class="line">target/</span><br><span class="line">*.iml</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="8-Git分支"><a href="#8-Git分支" class="headerlink" title="8. Git分支"></a>8. Git分支</h2><h3 id="8-1-查看所有分支"><a href="#8-1-查看所有分支" class="headerlink" title="8.1 查看所有分支"></a>8.1 查看所有分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -r </span><br></pre></td></tr></table></figure><h3 id="8-2-新建分支"><a href="#8-2-新建分支" class="headerlink" title="8.2 新建分支"></a>8.2 新建分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch branchName</span><br></pre></td></tr></table></figure><h3 id="8-3-切换分支"><a href="#8-3-切换分支" class="headerlink" title="8.3 切换分支"></a>8.3 切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b branchName</span><br></pre></td></tr></table></figure><h3 id="8-4-合并到指定分支"><a href="#8-4-合并到指定分支" class="headerlink" title="8.4 合并到指定分支"></a>8.4 合并到指定分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge branchName</span><br></pre></td></tr></table></figure><h3 id="8-5-删除分支"><a href="#8-5-删除分支" class="headerlink" title="8.5  删除分支"></a>8.5  删除分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d branchName</span><br></pre></td></tr></table></figure><h3 id="8-6-删除远程分支"><a href="#8-6-删除远程分支" class="headerlink" title="8.6 删除远程分支"></a>8.6 删除远程分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete branchName</span><br><span class="line">git branch -dr remote/branch</span><br></pre></td></tr></table></figure><h2 id="9-使用码云"><a href="#9-使用码云" class="headerlink" title="9. 使用码云"></a>9. 使用码云</h2><ol><li><p>生成本地秘钥：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xc2532800855@163.com&quot;</span> -f ~/.ssh/git_rsa</span><br></pre></td></tr></table></figure></li><li><p>配置多秘钥管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ vim cofig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入以下内容</span></span><br><span class="line">Host gitee</span><br><span class="line">HostName gitee.com</span><br><span class="line">User git</span><br><span class="line">Identityfile ~/.ssh/git_rsa</span><br><span class="line"></span><br><span class="line">$ sudo <span class="built_in">chmod</span> +600 ./config</span><br></pre></td></tr></table></figure></li><li><p>在gitee 中创建仓库</p></li><li><p>克隆仓库到本地</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/Study/Git/gitCode » git <span class="built_in">clone</span> https://gitee.com/xcyxiaoxiang/git-study.git</span><br><span class="line">正克隆到 <span class="string">&#x27;git-study&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">展开对象中: 100% (6/6), 13.26 KiB | 905.00 KiB/s, 完成.</span><br><span class="line"></span><br><span class="line">~/Study/Git/gitCode » <span class="built_in">ls</span>                                                  </span><br><span class="line">git-study</span><br><span class="line"></span><br><span class="line">~/Study/Git/gitCode » <span class="built_in">cd</span> git-study                                        </span><br><span class="line">~/Study/Git/gitCode/git-study(master) » <span class="built_in">ls</span>                                </span><br><span class="line">LICENSE  README.en.md  README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python|常用的Python技巧[更新中].md</title>
      <link href="/article/5ac4dcbc.html"/>
      <url>/article/5ac4dcbc.html</url>
      
        <content type="html"><![CDATA[<h1 id="按行保存数据"><a href="#按行保存数据" class="headerlink" title="按行保存数据"></a>按行保存数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if row.all() == None:</span><br><span class="line">    continue</span><br><span class="line">with open(&quot;.path&quot;, &quot;a&quot;, newline=&#x27;&#x27;, encoding=&#x27;utf-8&#x27;) as file:</span><br><span class="line">    writer = csv.writer(file, delimiter=&#x27;,&#x27;)</span><br><span class="line">    writer.writerow(row)</span><br></pre></td></tr></table></figure><h1 id="显示当前时间"><a href="#显示当前时间" class="headerlink" title="显示当前时间"></a>显示当前时间</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(time.strftime(&#x27;%Y-%m-%d-%H:%M:%S&#x27;, time.localtime(time.time())))</span><br></pre></td></tr></table></figure><h1 id="手机号正则表达式"><a href="#手机号正则表达式" class="headerlink" title="手机号正则表达式"></a>手机号正则表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;^(1[3|4|5|6|7|8|9])\d&#123;9&#125;$&#x27;</span><br></pre></td></tr></table></figure><h1 id="根据大小筛选"><a href="#根据大小筛选" class="headerlink" title="根据大小筛选"></a>根据大小筛选</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_n1 = df1.loc[df1[<span class="string">&quot;lam_snrr&quot;</span>].values&gt;=<span class="number">5</span>]</span><br><span class="line">df_n2 = df1.loc[df1[<span class="string">&quot;lam_snrr&quot;</span>].values&gt;=<span class="number">10</span>]</span><br><span class="line">df_n3 = df1.loc[df1[<span class="string">&quot;lam_snrr&quot;</span>].values&gt;=<span class="number">20</span>]</span><br><span class="line">df_n4 = df1.loc[df1[<span class="string">&quot;lam_snrr&quot;</span>].values&gt;=<span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>多条数据结合在一起</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datas = zip(fitsname, Hb, OIII5008, Ha, NII6585)</span><br><span class="line">return list(datas)  # 得到的datas为迭代器，使用list来转换成列表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueVue入门教程.md</title>
      <link href="/article/ed11a8ed.html"/>
      <url>/article/ed11a8ed.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Vue是什么？"><a href="#1-Vue是什么？" class="headerlink" title="1. Vue是什么？"></a>1. Vue是什么？</h2><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注<strong>视图层</strong>，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://v3.cn.vuejs.org/guide/single-file-component.html">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#components--libraries">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><ul><li>开发者：尤雨溪</li><li>目前版本：3.0</li><li>官方文档：<a href="https://v3.cn.vuejs.org/guide/introduction.html">https://v3.cn.vuejs.org/guide/introduction.html</a></li><li>官网：<a href="https://v3.cn.vuejs.org/">https://v3.cn.vuejs.org</a></li></ul><p>Vue具有以下特点：</p><ul><li>轻量级：20kb左右</li><li>开源</li><li>吸收了Angular（模块化）和React（虚拟DOM）的优点</li></ul><h2 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2. MVVM"></a>2. MVVM</h2><p>Model:模型层，即数据模型。泛指后端进行的各种业务逻辑和数据操控。</p><p>View：视图层,也就是用户界面。前端主要由HTML和CSS来构建。</p><p>ViewModel：连接视图的数据的中间件。能够观察到数据的变化，并对视图内的数据进行同步更新；同时，ViewModel也能观察到视图的变化，并通知数据发生变化。即将View和Model进行双向绑定。</p><p><img src="/img/VueVue%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20220109130525506-1651760871632.png" alt="image-20220109130525506"></p><p>MVVM的主要作用是分离视图和模型，且具有以下特点：</p><ul><li><code>低耦合</code>：降低了Model和View的耦合性。</li><li><code>复用性</code></li><li><code>独立开发</code></li><li><code>可测试</code></li></ul><h2 id="3-第一个Vue程序"><a href="#3-第一个Vue程序" class="headerlink" title="3. 第一个Vue程序"></a>3. 第一个Vue程序</h2><blockquote><p>导入Vue的CDN:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个Vue程序<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue的cdn--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--model层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>:<span class="string">&quot;hello Vue!&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/VueVue%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20220109125618029-1651760871631.png" alt="image-20220109125618029"></p><p>我们已经成功创建了第一个 Vue 应用！</p><p>现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 vm.message&#96; 的值，你将看到上例相应地更新。这其实是ViewModel在发挥作用。</p><h2 id="4-Vue基础语法"><a href="#4-Vue基础语法" class="headerlink" title="4. Vue基础语法"></a>4. Vue基础语法</h2><h3 id="1-元素属性绑定"><a href="#1-元素属性绑定" class="headerlink" title="1. 元素属性绑定"></a>1. 元素属性绑定</h3><ul><li><code>v-bind</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>  <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        hello Vue!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--model层--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">message</span>:<span class="string">&quot;hello Vue!&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>为当前标签绑定<code>title</code>属性，且值等于名称为<code>message</code>的值。</p><p>这里的 <code>v-bind</code> attribute 被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊 attribute。它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 <code>title</code> attribute 和 Vue 实例的 <code>message</code> property 保持一致”。</p><p>如果你再次打开浏览器的 JavaScript 控制台，输入 <code>mv.message = &#39;新消息&#39;</code>，就会再一次看到这个绑定了 <code>title</code> attribute 的 HTML 已经进行了更新。</p><h3 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h3><ul><li><code>v-if</code></li><li><code>v-else-if</code></li><li><code>v-else</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>条件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo03&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;message===&#x27;v1&#x27;&quot;</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;message===&#x27;v2&#x27;&quot;</span>&gt;</span>v2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>=<span class="string">&quot;message===&#x27;v3&#x27;&quot;</span>&gt;</span>v3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入vue的cdn--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--model--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#demo03&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;<span class="attr">message</span>:<span class="string">&quot;v1&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序可以发现，在页面显示v1。</p><p>继续在控制台输入 <code>vm.message = ‘v2’</code>，你会发现之前显示的消息变为了v2。</p><p>继续在控制台输入 <code>vm.message = ‘asdfdsa</code>，你会发现之前显示的消息变为了v3。</p><p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM <strong>结构</strong>。</p><h3 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h3><ul><li><code>v-for(item in items)</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo04<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo04&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.message&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--model--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入vue的cdn--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#demo04&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;<span class="attr">items</span>: [</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">message</span>:<span class="string">&quot;value1&quot;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">message</span>:<span class="string">&quot;value2&quot;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">message</span>:<span class="string">&quot;value3&quot;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">            &#123;<span class="attr">message</span>:<span class="string">&quot;value4&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">        ]&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/VueVue%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20220109134830235-1651760871632.png" alt="image-20220109134830235"></p><p>在控制台里，输入 <code>vm.items.push(&#123; message: &#39;新项目&#39; &#125;)</code>，你会发现列表最后添加了一个新项目。</p><h3 id="4-事件绑定和事件监听"><a href="#4-事件绑定和事件监听" class="headerlink" title="4. 事件绑定和事件监听"></a>4. 事件绑定和事件监听</h3><ul><li><code>v-on:事件=‘绑定的方法’</code></li><li><code>method:</code> <code>&#123;方法名： function ()&#123;&#125;&#125;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件绑定和事件监听<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo05&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--model--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#demo05&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;<span class="attr">message</span>: <span class="string">&quot;未点击&quot;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">a</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">message</span>=<span class="string">&quot;你已经点击了&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法必须定义在Vue对象中的<code>Methods</code>中，并通过<code>v-on</code>调用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p><code>v-bind</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>  <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-if</code></p></li><li><p><code>v-else-if</code></p></li><li><p><code>v-else</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;message===&#x27;v1&#x27;&quot;</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;message===&#x27;v2&#x27;&quot;</span>&gt;</span>v2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>=<span class="string">&quot;message===&#x27;v3&#x27;&quot;</span>&gt;</span>v3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-for</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>=</span><br></pre></td></tr></table></figure></li><li><p><code>v-on</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;a&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-双向绑定"><a href="#5-双向绑定" class="headerlink" title="5. 双向绑定"></a>5. 双向绑定</h2><p>Vue 提供了 <code>v-model</code> 指令，它能轻松实现<code>表单输入</code>和<code>应用状态</code>之间<strong>数据</strong>的双向绑定。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>双向绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo06&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--model--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#demo06&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;<span class="attr">message</span>:<span class="string">&quot;&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当在输入框中输入内容时，旁边也会跟着显示输入的内容。   </p><h2 id="6-Vue组件"><a href="#6-Vue组件" class="headerlink" title="6. Vue组件"></a>6. Vue组件</h2><p>Vue 组件非常类似于<strong>自定义元素</strong>。</p><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：</p><img src="/../../gitBiji/web前端/Vue/.images/1.简介/components.png" alt="Component Tree" style="zoom: 50%;" /><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。</p><p>定义一个Vue组件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义名为 todo  的新组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;todo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;li&gt;这是个待办项&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用该组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建一个 todo 组件的实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span>&gt;</span>自定义组件<span class="tag">&lt;/<span class="name">todo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/img/VueVue%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20220109173649559-1651760871631.png" alt="image-20220109173649559"></p><p>向组件内传递值：</p><ul><li>通过props指定传递的值的名称，并通过bind进行绑定传递.</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;todo&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// todo-item 组件现在接受一个</span></span><br><span class="line">  <span class="comment">// &quot;prop&quot;，类似于一个自定义 attribute。</span></span><br><span class="line">  <span class="comment">// 这个 prop 名为 todo。</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;item&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;li&gt;&#123;&#123; item.text &#125;&#125;&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中。</p><h2 id="7-网络通信"><a href="#7-网络通信" class="headerlink" title="7. 网络通信"></a>7. 网络通信</h2><h3 id="7-1-axios-是什么"><a href="#7-1-axios-是什么" class="headerlink" title="7.1 axios 是什么?"></a>7.1 axios 是什么?</h3><ol><li>前端最流行的 ajax 请求库</li><li>react&#x2F;vue 官方都推荐使用 axios 发 ajax 请求。</li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ol><h3 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h3><ol><li>从浏览器发起 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a> 请求</li><li>从 node.js 发起 <a href="https://nodejs.org/api/http.html">http</a> 请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换为 JSON 数据</li><li>客户端支持防御 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="#特性"></a><a href="https://getaxios.cn/intro.html#%E7%89%B9%E6%80%A7">#</a>特性</h3><ul><li>从浏览器创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests(opens new window)</a></li><li>从 node.js 创建 <a href="http://nodejs.org/api/http.html">http (opens new window)</a>请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise (opens new window)</a>API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF(opens new window)</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="#安装"></a><a href="https://getaxios.cn/intro.html#%E5%AE%89%E8%A3%85">#</a>安装</h1><p>使用 npm:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure><p>使用 bower:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure><p>使用 yarn:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add axios</span><br></pre></td></tr></table></figure><p>使用 jsDelivr CDN:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 unpkg CDN:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了在CommonJS中使用 <code>require（）</code> 导入时获得TypeScript类型推断（智能感知&#x2F;自动完成），请使用以下方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios.&lt;method&gt; 能够提供自动完成和参数类型推断功能</span></span><br></pre></td></tr></table></figure><h1 id="用例"><a href="#用例" class="headerlink" title="#用例"></a><a href="https://getaxios.cn/example.html#%E7%94%A8%E4%BE%8B">#</a>用例</h1><p>发起一个 <code>GET</code> 请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向给定ID的用户发起请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理成功情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述请求也可以按以下方式完成（可选）</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 由于<code>async/await</code> 是ECMAScript 2017中的一部分，而且在IE和一些旧的浏览器中不支持，所以使用时务必要小心。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python|数据分析三剑客之Pandas.md</title>
      <link href="/article/387e4c14.html"/>
      <url>/article/387e4c14.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面的话： 开始之前请确保已经配置好python环境，并安装好第三方库pandas和numpy。</p></blockquote><h2 id="1-pandas库介绍"><a href="#1-pandas库介绍" class="headerlink" title="1. pandas库介绍"></a>1. pandas库介绍</h2><p>什么是pandas？pandas是提供高性能易用数据类型和数据分析工具的<strong>第三方库</strong>。简单讲，pandas主要作用有两个：提供了简易高效的数据类型、提供了数据分析的工具。pandas基于numpy，常和numpy、matplotlib一起使用。 关于数据类型，python中自带的数据类型远远不能满足于数据分析。可以说在数据分析中numpy中的数据类型是基础数据类型，关注的是数据的结构表达，体现在数据间的关系（维度）；pandas中的数据类型是基于numpy的扩展数据类型，关注的是数据的应用表达，体现在数据与索引之间的关系上。我们再学习pandas时最重要的是<strong>理解如何去操作索引</strong>，从某种程度上来说，操作索引就是操作数据。</p><h2 id="2-pandas库的series类型"><a href="#2-pandas库的series类型" class="headerlink" title="2. pandas库的series类型"></a>2. pandas库的series类型</h2><p>pandas主要有两种数据类型，一维度的<code>Series</code>数据类型，二维及高维的<code>DataFrame</code>类型。我们先来看一下第一种，series类型。</p><h4 id="2-1-什么是series类型？"><a href="#2-1-什么是series类型？" class="headerlink" title="2.1 什么是series类型？"></a>2.1 什么是series类型？</h4><p>series类型由一组数据及与之相关的数据索引组成。我们来看几行代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">    </span><br><span class="line">     a = pd.Series([7,8,9,10])</span><br><span class="line">     print(a)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     0     7</span><br><span class="line">     1     8</span><br><span class="line">     2     9</span><br><span class="line">     3    10</span><br><span class="line">     dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>观察输出代码，我们可以发现Series对象一共由3部分组成：左侧<strong>自动索引部分</strong>，右侧<strong>数据部分</strong>，底部<strong>数据类型</strong>（numpy中的数据类型）部分。</p><p>除了自动添加索引外，我们还可以对其索引进行自定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     </span><br><span class="line">     a =pd.Series([7,8,9,10],index=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])  # index指定索引</span><br><span class="line">     print(a)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     a     7</span><br><span class="line">     b     8</span><br><span class="line">     c     9</span><br><span class="line">     d    10</span><br><span class="line">     dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可见，索引部分变为了我们自定义的<code>abcd</code>。</p><h4 id="2-2-如何创建series类型？"><a href="#2-2-如何创建series类型？" class="headerlink" title="2.2 如何创建series类型？"></a>2.2 如何创建series类型？</h4><p>创建Series类型的方法有很多种，主要以 以下几种为主：</p><ol><li>从<strong>标量</strong>创建</li><li>从<strong>字典</strong>创建</li><li>从<strong>ndarray</strong>类型创建</li><li>从<strong>列表</strong>创建</li></ol><p><strong>下面进行具体讲解：</strong></p><p>（1）从标量值创建</p><p>即指定一个标量生成一个series类型，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     </span><br><span class="line">     a = pd.Series(5,index=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;])</span><br><span class="line">     print(a)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a    5</span><br><span class="line"> b    5</span><br><span class="line"> c    5</span><br><span class="line"> d    5</span><br><span class="line"> e    5</span><br><span class="line"> f    5</span><br><span class="line"> dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意的是，此时的index参数不能省略（因为需要index来指定生成元素的个数和索引）。 （2）从字典类型创建 传入一个参数字典，字典的键为series类型的索引，字典的值为series类型的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> </span><br><span class="line"> my_dir=&#123;</span><br><span class="line">     &quot;a&quot;:1,</span><br><span class="line">     &quot;b&quot;:2,</span><br><span class="line">     &quot;c&quot;:3</span><br><span class="line"> &#125;</span><br><span class="line"> b = pd.Series(my_dir)</span><br><span class="line"> print(b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a    1</span><br><span class="line"> b    2</span><br><span class="line"> c    3</span><br><span class="line"> dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此外，利用字典构造series类型时，我们同样可以使用index来指定其索引或改变其结构，这个索引会覆盖字典中的“键索引”。</p><p>（3）从ndarray类型创建 ndarray类型是numpy中的数据类型，我们可以直接传入ndarray类型进行创建：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     c = np.arange(4)</span><br><span class="line">     d = pd.Series(c)</span><br><span class="line">     print(d)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     0    0</span><br><span class="line">     1    1</span><br><span class="line">     2    2</span><br><span class="line">     3    3</span><br><span class="line">     dtype: int32</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>同样，也可以使用index参数自定义索引。</p><p>（4）也可以从python列表创建，见2.1中的小例。</p><h4 id="2-3-series类型的基本使用"><a href="#2-3-series类型的基本使用" class="headerlink" title="2.3 series类型的基本使用"></a>2.3 series类型的基本使用</h4><p>Series对象包括index和values两部分，所以主要是这两部分操作。我们先看一下下面的案例：</p><ul><li>a.index:获取索引</li><li>a.values: 获取数据</li><li>a[‘a’]: 获取索引为a的元素</li><li>a[0]：获取索引为0的元素，注意！自动索引和自定义索引并存但不能混合使用</li></ul><p>因为series是基于ndarray类型的，所以对Series的操作类似于ndarray类型的操作：</p><ul><li>numpy中运算和操作可用于series类型</li><li>可以通过自动索引或自定义索引对其进行切片</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">      </span><br><span class="line">     a = pd.Series([1,2,3,4,5,6],index=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;])</span><br><span class="line">     </span><br><span class="line">     print(&quot;a的值：&quot;,a.values)</span><br><span class="line">     print(&quot;a的索引：&quot;,a.index)</span><br><span class="line">     print(&quot;a[0]：&quot;,a[0])</span><br><span class="line">     print(&quot;a[&#x27;a&#x27;]:&quot;,a[&quot;a&quot;])</span><br><span class="line">     print(&quot;a切片：\n&quot;,a[::-1])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     a的值： [1 2 3 4 5 6]</span><br><span class="line">     a的索引： Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;], dtype=&#x27;object&#x27;)</span><br><span class="line">     a[0]： 1</span><br><span class="line">     a[&#x27;a&#x27;]: 1</span><br><span class="line">     a切片：</span><br><span class="line">      f    6</span><br><span class="line">     e    5</span><br><span class="line">     d    4</span><br><span class="line">     c    3</span><br><span class="line">     b    2</span><br><span class="line">     a    1</span><br><span class="line">     dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此外，series类型具备<strong>对齐</strong>操作。如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     a = pd.Series([1,2,3],index=[&quot;c&quot;,&quot;d&quot;,&quot;e&quot;])</span><br><span class="line">     b = pd.Series([4,5,6,7,8],index=[&quot;a&quot;,&quot;b&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;])</span><br><span class="line">     c = a+b</span><br><span class="line">     print(c)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     a    NaN</span><br><span class="line">     b     NaN</span><br><span class="line">     c    NaN</span><br><span class="line">     d     NaN</span><br><span class="line">     e     9.0</span><br><span class="line">     f     NaN</span><br><span class="line">     g     NaN</span><br><span class="line">     dtype: float64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们让两个series类型相加。观察输出结果可以发现，只有当a、b两者中有相同索引（包括位置）时，他们才会相加，而其余值则不会相加。这就对是series的对齐操作。这也同时验证了pandas是基于索引的运算。</p><p>Series类型还有一个name属性，即series对象和索引都可以被赋予一个名称。我们可以使用.name来获取或定义其名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas  as pd</span><br><span class="line"> </span><br><span class="line">  a = pd.Series([1,2,3],index=[&quot;c&quot;,&quot;d&quot;,&quot;e&quot;])</span><br><span class="line">  </span><br><span class="line"> print(a.name)   # 初始是没有名称的</span><br><span class="line"> a.name = &quot;mySeries&quot;</span><br><span class="line"> print(a.name)</span><br><span class="line">   </span><br><span class="line"> print(a.index.name)</span><br><span class="line"> a.index.name = &quot;索引列&quot;</span><br><span class="line"> print(a.index.name)</span><br><span class="line"> print(&quot;*&quot;*20)</span><br><span class="line"> print(a)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  None</span><br><span class="line"> mySeries</span><br><span class="line"> None</span><br><span class="line"> 索引列</span><br><span class="line"> ********************</span><br><span class="line"> 索引列</span><br><span class="line"> c    1</span><br><span class="line"> d    2</span><br><span class="line"> e    3</span><br><span class="line"> Name: mySeries, dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="3-pandas库的DataFrame类型"><a href="#3-pandas库的DataFrame类型" class="headerlink" title="3. pandas库的DataFrame类型"></a>3. pandas库的DataFrame类型</h2><p>介绍完Series类型，再然我们来看一下二维及多维的DataFrame类型。</p><h4 id="3-1-什么是DataFrame类型？"><a href="#3-1-什么是DataFrame类型？" class="headerlink" title="3.1 什么是DataFrame类型？"></a>3.1 什么是DataFrame类型？</h4><p>DataFrame类型是由共用相同索引的一组列数据组成的数据类型。即DataFrame类型是一个类似于表格型的数据类型，每列值类型可以不同，同一行的多列数据都共用同一个索引。我们先看一个小例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     a = np.arange(10).reshape(2,5)</span><br><span class="line">     b = pd.DataFrame(a)</span><br><span class="line">     print(b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过numpy生成一个二维的ndarray数组，并将其作为参数传给DataFrame，从而生成DataFrame类型的数据。输出如下：</p><p><img src="/_posts/Python/04%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/.images/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BPandas/2.png" alt="2"></p><p>从输出结果中，可以发现，输出结果一共由三部分组成：左侧(纵向)<strong>行索引index(红色区,为轴axis&#x3D;0)</strong> 、顶部(横向)<strong>列索引column(黄色区，为轴axis&#x3D;1)</strong> 以及数据部分(蓝色区)。 DataFrame常用于表达二维数据，但也可以表达多维数据。</p><h4 id="3-2-如何创建DataFrame类型？"><a href="#3-2-如何创建DataFrame类型？" class="headerlink" title="3.2 如何创建DataFrame类型？"></a>3.2 如何创建DataFrame类型？</h4><p>dataFrame可以由以下4种方法创建：</p><ol><li>二维ndarray对象</li><li>字典</li><li>Series类型</li><li>其它DataFrame类型</li></ol><p>接下来，我们进行详细介绍：</p><p>（1）由二维ndarray对象创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     a = np.arange(16).reshape(4,4)</span><br><span class="line">     print(&#x27;ndarray类型:\n&#x27;,a)</span><br><span class="line">     b = pd.DataFrame(a)</span><br><span class="line">     print(&#x27;转换后的DataFrame类型：\n&#x27;,b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过numpy生成一个4*4的ndarray类型，然后作为参数转换成DataFrame类型，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     ndarray类型:</span><br><span class="line">      [[ 0  1  2  3]</span><br><span class="line">      [ 4  5  6  7]</span><br><span class="line">      [ 8  9 10 11]</span><br><span class="line">      [12 13 14 15]]</span><br><span class="line">     转换后的DataFrame类型：</span><br><span class="line">          0   1   2   3</span><br><span class="line">     0   0   1   2   3</span><br><span class="line">     1   4   5   6   7</span><br><span class="line">     2   8   9  10  11</span><br><span class="line">     3  12  13  14  15</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）由多个一维Series组成的字典生成 我们首先创建一个字典，并将其作为采参数传给DataFrame：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> a = &#123;</span><br><span class="line">     &quot;小明&quot;:pd.Series([100,99,98,100,95,99],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小红&quot;:pd.Series([100,99,98,100,95,99],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小蓝&quot;:pd.Series([100,99,98,100,95,99],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小黄&quot;:pd.Series([100,99,98,100,95,99],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小绿&quot;:pd.Series([100,99,98,100,95,99],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;])&#125;</span><br><span class="line"> b = pd.DataFrame(a)</span><br><span class="line"> print(b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      小明   小红   小蓝   小黄   小绿</span><br><span class="line"> 语文  100    100   100   100   100</span><br><span class="line"> 数学   99     99    99    99    99</span><br><span class="line"> 英语   98     98    98    98    98</span><br><span class="line"> 物理  100    100   100   100   100</span><br><span class="line"> 化学   95     95    95    95    95</span><br><span class="line"> 生物   99     99    99    99    99</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，键名变成了列标签，键值索引变成了行标签。</p><h4 id="3-3-DataFrame与Series的关系"><a href="#3-3-DataFrame与Series的关系" class="headerlink" title="3.3 DataFrame与Series的关系"></a>3.3 DataFrame与Series的关系</h4><p>可以发现当我们从DataFrame中取出一行或一列时，所得结果是Series类型。也就是说<strong>DataFrame是Series类型的容器。</strong></p><h2 id="4-pandas库的数据操作"><a href="#4-pandas库的数据操作" class="headerlink" title="4. pandas库的数据操作"></a>4. pandas库的数据操作</h2><p>在上文中，我们提到pandas的两种数据类型是series类型和DataFrame类型。接下来，我们主要针对这两种数据类型的操作进行讲解。</p><h4 id="4-1-Dataframe的基本属性"><a href="#4-1-Dataframe的基本属性" class="headerlink" title="4.1 Dataframe的基本属性"></a>4.1 Dataframe的基本属性</h4><ul><li><p>df.shape：行数和列数</p></li><li><p>df.dtype：列数据类型</p></li><li><p>df.ndim：数据维度</p></li><li><p>df.index：行索引</p></li><li><p>df.columns：列索引</p></li><li><p>df.values：值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> df = pd.DataFrame(np.arange(16).reshape(4,4),index=list(&quot;abcd&quot;),columns=list(&quot;ABCD&quot;))</span><br><span class="line"> print(df)</span><br><span class="line"> </span><br><span class="line"> print(&quot;行数和列数：&quot;,df.shape)</span><br><span class="line"> print(&quot;列数据类型：\n&quot;,df.dtypes)</span><br><span class="line"> print(&quot;数据维度：&quot;,df.ndim)</span><br><span class="line"> print(&quot;行索引：&quot;,df.index,&quot;数据类型：&quot;,type(df.index))</span><br><span class="line"> print(&quot;列索引：&quot;,df.columns,&quot;数据类型：&quot;,type(df.columns))</span><br><span class="line"> print(&quot;对象值：\n&quot;,df.values,&quot;数据类型：&quot;,type(df.values))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">     A   B   C   D</span><br><span class="line"> </span><br><span class="line"> a   0   1   2   3</span><br><span class="line"> b   4   5   6   7</span><br><span class="line"> c   8   9  10  11</span><br><span class="line"> d  12  13  14  15</span><br><span class="line"> </span><br><span class="line"> 行数和列数： (4, 4)</span><br><span class="line"> </span><br><span class="line"> 列数据类型：</span><br><span class="line">  A    int32</span><br><span class="line"> B    int32</span><br><span class="line"> C    int32</span><br><span class="line"> D    int32</span><br><span class="line"> dtype: object</span><br><span class="line"> </span><br><span class="line"> 数据维度： 2</span><br><span class="line"> </span><br><span class="line"> 行索引： Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], dtype=&#x27;object&#x27;) 数据类型： &lt;class &#x27;pandas.core.indexes.base.Index&#x27;&gt;</span><br><span class="line"> 列索引： Index([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;], dtype=&#x27;object&#x27;) 数据类型： &lt;class &#x27;pandas.core.indexes.base.Index&#x27;&gt;</span><br><span class="line"> </span><br><span class="line"> 对象值：</span><br><span class="line">  [[ 0  1  2  3]</span><br><span class="line">  [ 4  5  6  7]</span><br><span class="line">  [ 8  9 10 11]</span><br><span class="line">  [12 13 14 15]] 数据类型： &lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-2-dataFrame整体情况查询"><a href="#4-2-dataFrame整体情况查询" class="headerlink" title="4.2 dataFrame整体情况查询"></a>4.2 dataFrame整体情况查询</h4><ul><li><p>df.head(n): 显示前n行，默认前五行</p></li><li><p>df.tail(n)：显示末尾n行，默认后五行</p></li><li><p>df.info()：基本信息：行列数，列索引，列非空值个数，列类型行类型，内存占用等</p></li><li><p>df.describe()： 统计信息：行数，列数，均值，标准差，最大值，最小值，四分位数等</p></li><li><p>df.sort_values(by&#x3D;”列标签”，ascending&#x3D;True)：升序排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> df = pd.DataFrame(np.arange(16).reshape(4,4),index=list(&quot;abcd&quot;),columns=list(&quot;ABCD&quot;))</span><br><span class="line"> print(df)</span><br><span class="line"> </span><br><span class="line"> print(&quot;前3行：\n&quot;,df.head(3))</span><br><span class="line"> print(&quot;-&quot;*50)</span><br><span class="line"> print(&quot;后3行：\n&quot;,df.tail(3))</span><br><span class="line"> print(&quot;-&quot;*50)</span><br><span class="line"> print(&quot;基本信息:&quot;)</span><br><span class="line"> print(df.info())</span><br><span class="line"> print(&quot;-&quot;*50)</span><br><span class="line"> print(&quot;统计信息：&quot;,df.describe())</span><br><span class="line"> print(&quot;降序排序：&quot;)</span><br><span class="line"> print(df.sort_values(by=&quot;B&quot;, ascending=False))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">      A   B   C   D</span><br><span class="line"> </span><br><span class="line"> a   0   1   2   3</span><br><span class="line"> b   4   5   6   7</span><br><span class="line"> c   8   9  10  11</span><br><span class="line"> d  12  13  14  15</span><br><span class="line"> </span><br><span class="line"> 前3行：</span><br><span class="line">     A  B   C   D</span><br><span class="line"> a  0  1   2   3</span><br><span class="line"> b  4  5   6   7</span><br><span class="line"> c  8  9  10  11</span><br><span class="line"> --------------------------------------------------</span><br><span class="line"> </span><br><span class="line"> 后3行：</span><br><span class="line">      A   B   C   D</span><br><span class="line"> b   4   5   6   7</span><br><span class="line"> c   8   9  10  11</span><br><span class="line"> d  12  13  14  15</span><br><span class="line"> --------------------------------------------------</span><br><span class="line"> </span><br><span class="line"> 基本信息:</span><br><span class="line"> &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;  # 数据类型</span><br><span class="line"> Index: 4 entries, a to d               # 行数 4行</span><br><span class="line"> Data columns (total 4 columns):        # 列数 4列</span><br><span class="line"> </span><br><span class="line">  #   Column  Non-Null Count  Dtype</span><br><span class="line"> ---  ------  --------------  -----    # 列标签 列非空值个数  列数据类型</span><br><span class="line">  0   A       4 non-null      int32</span><br><span class="line">  1   B       4 non-null      int32</span><br><span class="line">  2   C       4 non-null      int32</span><br><span class="line">  3   D       4 non-null      int32</span><br><span class="line"> dtypes: int32(4)</span><br><span class="line"> memory usage: 96.0+ bytes            # 内存占用大小</span><br><span class="line"> </span><br><span class="line"> None</span><br><span class="line"> --------------------------------------------------</span><br><span class="line"> </span><br><span class="line"> 统计信息：  # 以下结果也为DataFrame类型</span><br><span class="line">         A          B          C          D</span><br><span class="line"> count   4.000000   4.000000   4.000000   4.000000  #包含的行数</span><br><span class="line"> mean    6.000000   7.000000   8.000000   9.000000  # 均值</span><br><span class="line"> std     5.163978   5.163978   5.163978   5.163978  # 标准差 </span><br><span class="line"> min     0.000000   1.000000   2.000000   3.000000  # 最小值</span><br><span class="line"> 25%     3.000000   4.000000   5.000000   6.000000  # 前25%中位数</span><br><span class="line"> 50%     6.000000   7.000000   8.000000   9.000000  # 中位数</span><br><span class="line"> 75%     9.000000  10.000000  11.000000  12.000000  # 前75%中位数</span><br><span class="line"> max    12.000000  13.000000  14.000000  15.000000  # 最大值</span><br><span class="line"> </span><br><span class="line"> 降序排序：</span><br><span class="line">     A   B   C   D</span><br><span class="line"> d  12  13  14  15</span><br><span class="line"> c   8   9  10  11</span><br><span class="line"> b   4   5   6   7</span><br><span class="line"> a   0   1   2   3</span><br><span class="line"> </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-3-取值操作"><a href="#4-3-取值操作" class="headerlink" title="4.3 取值操作"></a>4.3 取值操作</h4><p>取值操作是pandas中的一个基本操作，我们先生成一个100行3列的数据，用于下面操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> df = pd.DataFrame(np.arange(16).reshape(4,4),index=list(&quot;abcd&quot;),columns=list(&quot;ABCD&quot;))</span><br><span class="line"> print(df)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     A   B   C   D</span><br><span class="line"> </span><br><span class="line"> a   0   1   2   3</span><br><span class="line"> b   4   5   6   7</span><br><span class="line"> c   8   9  10  11</span><br><span class="line"> d  12  13  14  15</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>pandas中有较多的取值方法，但是最常用最好用的方法是以下两种，这里也将详细介绍这两种方法：</p><ul><li><p>df.loc[]: 通过<strong>标签索引</strong>获取行数据</p></li><li><p>df.iloc[]: 通过<strong>位置</strong>获取行数据</p><p>（1）先来看一下 df.loc[]:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> print(&quot;取a行A列的数据：&quot;,df.loc[&quot;a&quot;,&quot;A&quot;],&quot;数据类型：&quot;,type(df.loc[&quot;a&quot;,&quot;A&quot;]))</span><br><span class="line"> print(&quot;取A B列的数据：\n&quot;,df.loc[:,[&quot;A&quot;,&quot;B&quot;]],&quot;数据类型：&quot;,type(df.loc[:,[&quot;A&quot;,&quot;B&quot;]]))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 取a行A列的数据： 0 数据类型： &lt;class &#x27;numpy.int32&#x27;&gt;</span><br><span class="line"> 取A B列的数据：</span><br><span class="line">      A   B</span><br><span class="line"> a   0   1</span><br><span class="line"> b   4   5</span><br><span class="line"> c   8   9</span><br><span class="line"> d  12  13 数据类型： &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>loc[]可以<strong>通过自定义的索引</strong>进行查找也可以通过位置索引进行查找。值得注意的是，这里我们用到了 [ : ]，这里是<strong>前闭后闭</strong>的，即会选择冒号后面的数据。</p><p>（2）接着 来看一下df.iloc[]:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> print(&quot;取前两行前两列：\n&quot;,df.iloc[:2,:2])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 取前两行前两列：</span><br><span class="line">    A  B</span><br><span class="line"> a  0  1</span><br><span class="line"> b  4  5</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）布尔索引</p><p>我们通过通常范围筛选数值，或通过判断进行筛选数值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> print(&quot;选取df中数值大于7小于13的行：\n&quot;,(df.loc[(df[&quot;B&quot;]&gt;7)&amp;(df[&quot;B&quot;]&lt;13)]))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 选取df中数值大于7小于13的行：</span><br><span class="line">    A  B   C   D</span><br><span class="line"> c  8  9  10  11</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里选取多个条件时，需要用（）括起来。</p><h4 id="4-4-改变数据类型"><a href="#4-4-改变数据类型" class="headerlink" title="4.4 改变数据类型"></a>4.4 改变数据类型</h4><p>这里所谓的改变数据类型的结构就是对数据类型进行索引重排或增删 。主要操作如下：</p><p>（1） .reindex(index&#x2F;columns):重排数据，通过改变数据的索引来对数据进行重新排序。 我们依旧拿上述的成绩单作为例子来进行讲解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> a = &#123;</span><br><span class="line">     &quot;小明&quot;:pd.Series([100,99,91,90,85,69],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小红&quot;:pd.Series([100,93,92,100,65,93],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小蓝&quot;:pd.Series([100,94,93,70,55,92],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小黄&quot;:pd.Series([100,95,88,80,85,89],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;]),</span><br><span class="line">     &quot;小绿&quot;:pd.Series([100,92,78,89,75,79],index=[&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;])&#125;</span><br><span class="line"> b = pd.DataFrame(a)</span><br><span class="line"> print(b)</span><br><span class="line"> </span><br><span class="line"> c = b.reindex(columns=[&quot;小红&quot;,&quot;小明&quot;,&quot;小蓝&quot;,&quot;小黄&quot;,&quot;小绿&quot;])</span><br><span class="line"> print(&quot;对换小明和小红：\n&quot;,c)</span><br><span class="line"> </span><br><span class="line"> d = b.reindex(index=[&quot;数学&quot;,&quot;语文&quot;,&quot;英语&quot;,&quot;物理&quot;,&quot;化学&quot;,&quot;生物&quot;])</span><br><span class="line"> print(d)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输入如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      小明   小红   小蓝   小黄   小绿</span><br><span class="line"> 语文  100   100   100   100   100</span><br><span class="line"> 数学   99    93    94    95    92</span><br><span class="line"> 英语   91    92    93    88    78</span><br><span class="line"> 物理   90   100    70    80    89</span><br><span class="line"> 化学   85    65    55    85    75</span><br><span class="line"> 生物   69    93    92    89    79</span><br><span class="line"> 对换小明和小红：</span><br><span class="line">       小红   小明   小蓝   小黄   小绿</span><br><span class="line"> 语文  100    100    100   100   100</span><br><span class="line"> 数学   93    99     94    95    92</span><br><span class="line"> 英语   92    91     93    88    78</span><br><span class="line"> 物理  100    90     70    80    89</span><br><span class="line"> 化学   65    85     55    85    75</span><br><span class="line"> 生物   93    69     92    89    79</span><br><span class="line">  对换数学和语文：</span><br><span class="line">      小明   小红   小蓝   小黄   小绿</span><br><span class="line"> 数学   99     93     94   95    92</span><br><span class="line"> 语文  100    100    100   100   100</span><br><span class="line"> 英语   91     92     93    88    78</span><br><span class="line"> 物理   90    100     70    80    89</span><br><span class="line"> 化学   85     65     55    85    75</span><br><span class="line"> 生物   69     93     92    89    79</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可见，通过columns调换了列数据，通过index调换了行数据。 下面补充一下.index()方法的其余参数：</p><ul><li>index,columns:新的行列自定义索引</li><li>fill_value：重新索引中，用于填充缺失位置（NaN）的值</li><li>limit： 最大填充量</li><li>method：填充方法 ffill向前填充，bfill向后填充</li><li>copy：默认True，生成新的对象</li></ul><p>(2)另外，对于缺失值还有另一种处理方法:</p><ul><li><p>pd.isnull(df): 是否为空值，空值标为True</p></li><li><p>pd.isnotnull(df)：是否为非空值，非空值标为True</p></li><li><p>df.dropna(axis&#x3D;0&#x2F;1,how&#x3D;”all&#x2F;any”,inplace&#x3D;True&#x2F;False)： 删除nan所在的行&#x2F;列</p></li><li><p>df.fiullan(n):将空值填充为n</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> df = pd.DataFrame(np.arange(16).reshape(4,4),columns=list(&quot;ABCD&quot;))</span><br><span class="line"> df.loc[3,&quot;C&quot;] = None</span><br><span class="line"> df.loc[2,&quot;C&quot;] = None</span><br><span class="line"> print(df)</span><br><span class="line"> </span><br><span class="line"> print(df.isnull())</span><br><span class="line"> print(df.notnull())</span><br><span class="line"> print(df.dropna(axis=0,inplace=False))</span><br><span class="line"> print(df.fillna(df.mean()))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     A   B    C   D</span><br><span class="line"> </span><br><span class="line"> 0   0   1  2.0   3</span><br><span class="line"> 1   4   5  6.0   7</span><br><span class="line"> 2   8   9  NaN  11</span><br><span class="line"> 3  12  13  NaN  15</span><br><span class="line"> </span><br><span class="line">        A      B      C      D</span><br><span class="line"> 0  False  False  False  False</span><br><span class="line"> 1  False  False  False  False</span><br><span class="line"> 2  False  False   True  False</span><br><span class="line"> 3  False  False   True  False</span><br><span class="line"> </span><br><span class="line">       A     B      C     D</span><br><span class="line"> 0  True  True   True  True</span><br><span class="line"> 1  True  True   True  True</span><br><span class="line"> 2  True  True  False  True</span><br><span class="line"> 3  True  True  False  True</span><br><span class="line"> </span><br><span class="line">    A  B    C  D</span><br><span class="line"> 0  0  1  2.0  3</span><br><span class="line"> 1  4  5  6.0  7</span><br><span class="line"> </span><br><span class="line">     A   B    C   D</span><br><span class="line"> 0   0   1  2.0   3</span><br><span class="line"> 1   4   5  6.0   7</span><br><span class="line"> 2   8   9  4.0  11</span><br><span class="line"> 3  12  13  4.0  15</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4-5-索引操作"><a href="#4-5-索引操作" class="headerlink" title="4.5 索引操作"></a>4.5 索引操作</h4><p>对于索引，也有下常用的方法：</p><ul><li>.append()连接另一个index对象，产生新的index对象</li><li>.diff(idx):计算差集，产生新的index对象</li><li>intersection(idx):计算交集</li><li>union（idx）：吉计算并集</li><li>delete(loc): 删除loc位置处的元素</li><li>insert(loc,c):在loc位置增加一个元素c</li></ul><h4 id="4-6-删除指定索引对象"><a href="#4-6-删除指定索引对象" class="headerlink" title="4.6 删除指定索引对象"></a>4.6 删除指定索引对象</h4><p>.drop()可以删除series和DataFrame指定的行或列索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> </span><br><span class="line"> a = pd.Series([4,5,6,7],index=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])</span><br><span class="line"> print(a)</span><br><span class="line"> </span><br><span class="line"> b = a.drop([&quot;b&quot;,&quot;d&quot;])</span><br><span class="line"> print(b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a    4</span><br><span class="line"> b    5</span><br><span class="line"> c    6</span><br><span class="line"> d    7</span><br><span class="line"> dtype: int64</span><br><span class="line"> a    4</span><br><span class="line"> c    6</span><br><span class="line"> dtype: int64</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对于DataFrame对象，.drop()默认操作0轴上的对象，当我们要操作1轴上的对象时，需要添加参数指定是1轴：axis&#x3D;1。</p><h2 id="5-pandas库的数据类型运算"><a href="#5-pandas库的数据类型运算" class="headerlink" title="5. pandas库的数据类型运算"></a>5. pandas库的数据类型运算</h2><h4 id="5-1-算数运算"><a href="#5-1-算数运算" class="headerlink" title="5.1 算数运算"></a>5.1 算数运算</h4><p>pandas的数据类型在进行算数运算时，根据行列索引，补齐后运算，即只有当索引相同时才进行运算，不同索引之间不进行运算而是补齐NaN。默认结果为浮点型。不同维度的数据类型之间的运算采用广播运算，即对应索引之间进行运算。 我们先来看一下相同维度的运算：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> a = np.arange(10).reshape(2,5)</span><br><span class="line"> b = np.arange(15).reshape(3,5)</span><br><span class="line"> a = pd.DataFrame(a)</span><br><span class="line"> b = pd.DataFrame(b)</span><br><span class="line"> print(a)</span><br><span class="line"> print(b)</span><br><span class="line"> print(a*b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    0  1  2  3  4</span><br><span class="line"> 0  0  1  2  3  4</span><br><span class="line"> 1  5  6  7  8  9</span><br><span class="line">     0   1   2   3   4</span><br><span class="line"> 0   0   1   2   3   4</span><br><span class="line"> 1   5   6   7   8   9</span><br><span class="line"> 2  10  11  12  13  14</span><br><span class="line">       0     1     2     3     4</span><br><span class="line"> 0   0.0   1.0   4.0   9.0  16.0</span><br><span class="line"> 1  25.0  36.0  49.0  64.0  81.0</span><br><span class="line"> 2   NaN   NaN   NaN   NaN   NaN</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不同维度的运算如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> a = pd.Series([1,2,3,4,5])</span><br><span class="line"> b = np.arange(10).reshape(2,5)</span><br><span class="line"> b = pd.DataFrame(b)</span><br><span class="line"> </span><br><span class="line"> print(a)</span><br><span class="line"> print(b)</span><br><span class="line"> </span><br><span class="line"> print(&quot;________&quot;)</span><br><span class="line"> c = b-a</span><br><span class="line"> print(c)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们生成一个一维series对象a，一个二DataFrame对象b,然后用b-a，得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0    1</span><br><span class="line"> 1    2</span><br><span class="line"> 2    3</span><br><span class="line"> 3    4</span><br><span class="line"> 4    5</span><br><span class="line"> dtype: int64</span><br><span class="line">    0  1  2  3  4</span><br><span class="line"> 0  0  1  2  3  4</span><br><span class="line"> 1  5  6  7  8  9</span><br><span class="line"> ________</span><br><span class="line">    0  1  2  3  4</span><br><span class="line"> 0 -1 -1 -1 -1 -1</span><br><span class="line"> 1  4  4  4  4  4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>观察结果可以发现，b中的1轴都减去了a，即b中的每一行都对应减去了a中的元素。所以，对于不同维度的数据类型运算来说，默认的是高纬度的对series进行1轴运算。</p><h4 id="5-2-比较运算"><a href="#5-2-比较运算" class="headerlink" title="5.2 比较运算"></a>5.2 比较运算</h4><p>比较运算只能比较相同索引的元素，需要注意的是这里不进行补齐。二维和一维，一维和零维之间为广播运算，结果产生由布尔值组成的对象。</p><p>相同纬度：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     a = np.arange(16).reshape(4,4)</span><br><span class="line">     a = pd.DataFrame(a)</span><br><span class="line">     </span><br><span class="line">     b = np.arange(4,20).reshape(4,4)</span><br><span class="line">     b = pd.DataFrame(b)</span><br><span class="line">     </span><br><span class="line">     print(a,&quot;\n&quot;)</span><br><span class="line">     print(b,&quot;\n&quot;)</span><br><span class="line">     </span><br><span class="line">     print(a == b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         0   1   2   3</span><br><span class="line">     0   0   1   2   3</span><br><span class="line">     1   4   5   6   7</span><br><span class="line">     2   8   9  10  11</span><br><span class="line">     3  12  13  14  15 </span><br><span class="line">     </span><br><span class="line">         0   1   2   3</span><br><span class="line">     0   4   5   6   7</span><br><span class="line">     1   8   9  10  11</span><br><span class="line">     2  12  13  14  15</span><br><span class="line">     3  16  17  18  19 </span><br><span class="line">     </span><br><span class="line">            0      1      2      3</span><br><span class="line">     0  False  False  False  False</span><br><span class="line">     1  False  False  False  False</span><br><span class="line">     2  False  False  False  False</span><br><span class="line">     3  False  False  False  False</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>相同维度进行比较时，要求两个数据的尺寸必须相同，否则会报错。那么不同维度的相比较会是怎样的结果呢？让我们来看一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     a = pd.Series([1,2,3,4])</span><br><span class="line">     </span><br><span class="line">     b = np.arange(1,17).reshape(4,4)</span><br><span class="line">     b = pd.DataFrame(b)</span><br><span class="line">     </span><br><span class="line">     print(a,&quot;\n&quot;)</span><br><span class="line">     print(b,&quot;\n&quot;)</span><br><span class="line">     </span><br><span class="line">     print(a==b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     0    1</span><br><span class="line">     1    2</span><br><span class="line">     2    3</span><br><span class="line">     3    4</span><br><span class="line">     dtype: int64 </span><br><span class="line">     </span><br><span class="line">         0   1   2   3</span><br><span class="line">     0   1   2   3   4</span><br><span class="line">     1   5   6   7   8</span><br><span class="line">     2   9  10  11  12</span><br><span class="line">     3  13  14  15  16 </span><br><span class="line">     </span><br><span class="line">            0      1      2      3</span><br><span class="line">     0   True   True   True   True</span><br><span class="line">     1  False  False  False  False</span><br><span class="line">     2  False  False  False  False</span><br><span class="line">     3  False  False  False  False</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以发现，不同维度相比较，进行广播运算，默认是1轴。 此外，除了直接利用运算符进行运算外，我们还可以利用函数进行运算。</p><ul><li>.add(d,**argws):加法</li><li>.sub(d,**argws)：减法</li><li>.mul(d,**argws)：乘法</li><li>.div(d,**argws)：除法</li></ul><p>通过这些函数我们不仅可以进行基本运算，而且带有可选参数的它，为我们提供了更加强大的功能，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     import pandas as pd</span><br><span class="line">     import numpy as np</span><br><span class="line">     </span><br><span class="line">     a = np.arange(16).reshape(4,4)</span><br><span class="line">     a = pd.DataFrame(a)</span><br><span class="line">     </span><br><span class="line">     b = np.arange(20).reshape(5,4)</span><br><span class="line">     b = pd.DataFrame(b)</span><br><span class="line">     </span><br><span class="line">     print(a)</span><br><span class="line">     print(b)</span><br><span class="line">     </span><br><span class="line">     c = b.add(a,fill_value=100)</span><br><span class="line">     print(c)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         0   1   2   3</span><br><span class="line">     0   0   1   2   3</span><br><span class="line">     1   4   5   6   7</span><br><span class="line">     2   8   9  10  11</span><br><span class="line">     3  12  13  14  15</span><br><span class="line">     </span><br><span class="line">         0   1   2   3</span><br><span class="line">     0   0   1   2   3</span><br><span class="line">     1   4   5   6   7</span><br><span class="line">     2   8   9  10  11</span><br><span class="line">     3  12  13  14  15</span><br><span class="line">     4  16  17  18  19</span><br><span class="line">            0      1      2      3</span><br><span class="line">     0    0.0    2.0    4.0    6.0</span><br><span class="line">     1    8.0   10.0   12.0   14.0</span><br><span class="line">     2   16.0   18.0   20.0   22.0</span><br><span class="line">     3   24.0   26.0   28.0   30.0</span><br><span class="line">     4  116.0  117.0  118.0  119.0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以发现，ab是相同维度，但是尺寸不同，按照上文中直接使用加法运算程序会报错。但是在这里，我们传入了一个参数，在进行先进行补齐操作，然后进行运算。</p><h2 id="6-pandas操作CSV"><a href="#6-pandas操作CSV" class="headerlink" title="6. pandas操作CSV"></a>6. pandas操作CSV</h2><h3 id="6-1-pandas读取CSV文件"><a href="#6-1-pandas读取CSV文件" class="headerlink" title="6.1 pandas读取CSV文件"></a>6.1 pandas读取CSV文件</h3><p>我们先创建一个15行4列的a.csv文件，用于下列案例之用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> import pandas as pd</span><br><span class="line"> import numpy as np</span><br><span class="line"> </span><br><span class="line"> # 创建一个csv文件</span><br><span class="line"> a = np.arange(60).reshape(15,4)</span><br><span class="line"> a = pd.DataFrame(a,columns=(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;))</span><br><span class="line"> print(a,&quot;\n&quot;)</span><br><span class="line"> a.to_csv(&quot;./a.csv&quot;,index=False)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>文件内容如下：</p><p><img src="/_posts/Python/04%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/.images/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BPandas/3.png" alt="3"></p><p><strong>pd.read_csv()的常用参数如下：</strong></p><ul><li>filepath_or_buffer：**– str** 文件路径，可以是本地路径，也可以是url路径</li><li>sep:指定分隔符，默认”,”</li><li>header: <strong>–int</strong> 指定列名:header&#x3D;0为默认值，表示数据第一行为列名；header&#x3D;None表示数据没有列名(为0，1，2，3，4……)，原列名变为第0行数据。</li></ul><p>如案例1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &quot;&quot;&quot;案例1：filepath_or_buffer、sep、header的使用 &quot;&quot;&quot;</span><br><span class="line"> def demo01():</span><br><span class="line">     print(&quot;=== header=0时（默认）表示数据第一行为列名===&quot;)</span><br><span class="line">     path = &quot;data.csv&quot;</span><br><span class="line">     df = pd.read_csv(path, sep=&quot;,&quot;, header=0)</span><br><span class="line">     print(df.head(), &quot;\n&quot;)  # 默认输出前5行</span><br><span class="line"> </span><br><span class="line">     print(&quot;===header=none时 列名变为第0行数据===&quot;)</span><br><span class="line">     # header = None时</span><br><span class="line">     df = pd.read_csv(path, sep=&quot;,&quot;, header=None)</span><br><span class="line">     print(df.head(), &quot;\n&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> === header=0时（默认）===</span><br><span class="line">     a   b   c   d</span><br><span class="line"> 0   0   1   2   3</span><br><span class="line"> 1   4   5   6   7</span><br><span class="line"> 2   8   9  10  11</span><br><span class="line"> 3  12  13  14  15</span><br><span class="line"> 4  16  17  18  19 </span><br><span class="line"> </span><br><span class="line"> ===header=none时 ===</span><br><span class="line">     0   1   2   3</span><br><span class="line"> 0   a   b   c   d</span><br><span class="line"> 1   0   1   2   3</span><br><span class="line"> 2   4   5   6   7</span><br><span class="line"> 3   8   9  10  11</span><br><span class="line"> 4  12  13  14  15 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>names: <strong>–list</strong> 指定列名，当文件含有列名时会覆盖</li></ul><p>如案例2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &quot;&quot;&quot;通过names参数重新指定列名&quot;&quot;&quot;</span><br><span class="line"> def demo02():</span><br><span class="line">     df = pd.read_csv(path, names=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;])</span><br><span class="line">     print(&quot;重新指定列名:&quot;)</span><br><span class="line">     print(df.head(), &quot;\n&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 重新指定列名:</span><br><span class="line">     A   B   C   D</span><br><span class="line"> 0   a   b   c   d</span><br><span class="line"> 1   0   1   2   3</span><br><span class="line"> 2   4   5   6   7</span><br><span class="line"> 3   8   9  10  11</span><br><span class="line"> 4  12  13  14  15 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>encoding</strong>：指定编码格式，默认为utf-8。常用户解决乱码问题和平台编码不同的问题。</li><li>index_col:<strong>–str&#x2F;list</strong> 指定索引,将表中的某一列数据指定为索引。可以是单列也可以是多列。</li></ul><p>如案例3：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &quot;&quot;&quot;通过index_col参数指定索引&quot;&quot;&quot;</span><br><span class="line"> def demo03():</span><br><span class="line">     print(&quot;指定b列为索引:&quot;)</span><br><span class="line">     df = pd.read_csv(path, index_col=&quot;b&quot;)</span><br><span class="line">     print(df.head(), &quot;\n&quot;)</span><br><span class="line">     df.to_csv(&quot;text.csv&quot;)</span><br><span class="line"> </span><br><span class="line">     print(&quot;指定ab两列为索引:&quot;)</span><br><span class="line">     df = pd.read_csv(path, index_col=[&quot;a&quot;, &quot;b&quot;])</span><br><span class="line">     print(df.head())</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 指定b列为索引:</span><br><span class="line">      a   c   d</span><br><span class="line"> b             </span><br><span class="line"> 1    0   2   3</span><br><span class="line"> 5    4   6   7</span><br><span class="line"> 9    8  10  11</span><br><span class="line"> 13  12  14  15</span><br><span class="line"> 17  16  18  19 </span><br><span class="line"> </span><br><span class="line"> 指定ab两列为索引:</span><br><span class="line">         c   d</span><br><span class="line"> a  b         </span><br><span class="line"> 0  1    2   3</span><br><span class="line"> 4  5    6   7</span><br><span class="line"> 8  9   10  11</span><br><span class="line"> 12 13  14  15</span><br><span class="line"> 16 17  18  19</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>usecols: <strong>–str&#x2F;list</strong> 指定读取的列,默认读取全部列</li><li>nrows：**–int** 仅读取前多少行（不包括此行）</li><li>skiprows：**–int** 跳过指定行数，开始读取（包括此行），注意必要时要指定列名，否则根据header&#x3D;0当前行会为列名</li></ul><p>如案例4：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &quot;&quot;&quot;usecols、nrows、skiprows的使用&quot;&quot;&quot;</span><br><span class="line"> def demo04():</span><br><span class="line">     print(&quot;只读取bc列:&quot;)</span><br><span class="line">     df = pd.read_csv(path, usecols=(&quot;b&quot;, &quot;c&quot;))</span><br><span class="line">     print(df.head(), &quot;\n&quot;)</span><br><span class="line"> </span><br><span class="line">     print(&quot;读取前6行:&quot;)</span><br><span class="line">     df = pd.read_csv(path, nrows=6)</span><br><span class="line">     print(df, &quot;\n&quot;)</span><br><span class="line"> </span><br><span class="line">     print(&quot;从第6行开始读取:&quot;)</span><br><span class="line">     df = pd.read_csv(path, skiprows=6, names=list(&quot;abcd&quot;))</span><br><span class="line">     print(df.head(), &quot;\n&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 只读取bc列:</span><br><span class="line">     b   c</span><br><span class="line"> 0   1   2</span><br><span class="line"> 1   5   6</span><br><span class="line"> 2   9  10</span><br><span class="line"> 3  13  14</span><br><span class="line"> 4  17  18 </span><br><span class="line"> </span><br><span class="line"> 读取前6行:</span><br><span class="line">     a   b   c   d</span><br><span class="line"> 0   0   1   2   3</span><br><span class="line"> 1   4   5   6   7</span><br><span class="line"> 2   8   9  10  11</span><br><span class="line"> 3  12  13  14  15</span><br><span class="line"> 4  16  17  18  19</span><br><span class="line"> 5  20  21  22  23 </span><br><span class="line"> </span><br><span class="line"> 从第6行开始读取:</span><br><span class="line">     a   b   c   d</span><br><span class="line"> 0  20  21  22  23</span><br><span class="line"> 1  24  25  26  27</span><br><span class="line"> 2  28  29  30  31</span><br><span class="line"> 3  32  33  34  35</span><br><span class="line"> 4  36  37  38  39 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-2-pandas保存CSV文件"><a href="#6-2-pandas保存CSV文件" class="headerlink" title="6.2 pandas保存CSV文件"></a>6.2 pandas保存CSV文件</h3><p>通过pandas保存csv实质上是调用<strong>DataFrame对象</strong>的to_csv方法。接下来我们就主要介绍一下<code>to_csv</code>方法的常用参数。</p><ul><li><code>path_or_buf</code>: 保存路径</li><li><code>sep</code>：分隔符，默认为<code>,</code></li><li><code>na_rep</code>：替换空格。将空格替换为指定的值</li><li><code>float_format</code>： 格式化数值如保留两位小数<code>%.2f</code></li><li><code>header</code>： 是否保留列名，默认保留。值为<code>0</code>则不保留。</li><li><code>index</code>：是否保留索引（布尔值），默认保留。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python通过plt.boxplot()绘制箱图.md</title>
      <link href="/article/75bf383e.html"/>
      <url>/article/75bf383e.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-箱图含义"><a href="#1-箱图含义" class="headerlink" title="1. 箱图含义"></a>1. 箱图含义</h1><p>箱图是一中用于统计数据分布的统计图，也可以粗略地看出数据是否具有对称性，分布的分散程度等信息。箱图中的信息含义如下：<br><img src="/img/Python%E9%80%9A%E8%BF%87plt.boxplot()%E7%BB%98%E5%88%B6%E7%AE%B1%E5%9B%BE/20210121230720396.png" alt="在这里插入图片描述"></p><ul><li><p>最下方的横线表示最小值</p></li><li><p>最上方的横线表示最大值</p></li><li><p>黑色空心圆圈表示异常值</p></li><li><p>黑色实心圆圈表示极端值</p></li><li><p>箱子由下四分位数、中值以及上四分位数组成</p><blockquote><p>异常值又称离群值，指大于1.5倍的四分位数间距的值。处于1.5倍~3倍四分位数间距的值用空心圆圈表示。极端值属于异常值中的一种。<br>极端值是指大于3倍的四分位数间距的值。</p></blockquote></li></ul><h1 id="2-计算方法"><a href="#2-计算方法" class="headerlink" title="2.计算方法"></a>2.计算方法</h1><p>首先找出一组数据的五个特征值，包括除异常值外的最小值(minimum)和最大值（maximum）、中位数（median）、两个四分位数（上四分位数Q1和下四分位Q3数）；<br><strong>中位数</strong>：将所有数值<strong>从小到大</strong>排列，如果是<strong>奇数</strong>个数值则取最中间一个值作为中位数，之后最中间的值在计算Q1和Q3时<strong>不再使用</strong>；<strong>偶数</strong>个数值则取最中间两个数的平均数作为中位数，这两个数在计算Q1和Q3时<strong>继续使用</strong>。<br><strong>Q1</strong>：中位数将所有数据分成两部分，<strong>最小值到中位数</strong>的部分按取中位数的方法取中位数作为Q1。<br><strong>Q3</strong>：同Q1取法，取<strong>中位数到最大值</strong>的中位数。<br><strong>IQR(四分位数间距)</strong>&#x3D;<strong>Q3-Q1</strong>。<br>所有不在（Q1-1.5IQR，Q3+1.5IQR）的区间内的数为<strong>离群值</strong>，剩下的值最大的为最大值，最小的为最小值。<br><strong>特征值</strong>（从下到上）：最小值、Q1、中位数、Q3、最大值<br>将五个数值描绘在一个图上，五个特征值<strong>在一个直线上</strong>，最小值和Q1连接起来，Q1、中位数、Q3分别作<strong>平行等长线段</strong>，<br>然后，连接两个四分位数构成箱子。<br>最后连接两个极值点与箱子，形成箱式图，然后点上离群值即可。</p><h1 id="3-绘图"><a href="#3-绘图" class="headerlink" title="3.绘图"></a>3.绘图</h1><h2 id="3-1-绘制单个箱图"><a href="#3-1-绘制单个箱图" class="headerlink" title="3.1 绘制单个箱图"></a>3.1 绘制单个箱图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成data数据</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">data = np.random.normal(size=(<span class="number">1000</span>,),loc=<span class="number">0</span>,scale=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.boxplot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/Python%E9%80%9A%E8%BF%87plt.boxplot()%E7%BB%98%E5%88%B6%E7%AE%B1%E5%9B%BE/2021012212473072.png" alt="在这里插入图片描述"></p><h2 id="3-2-绘制多个箱图"><a href="#3-2-绘制多个箱图" class="headerlink" title="3.2 绘制多个箱图"></a>3.2 绘制多个箱图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">data = np.random.normal(size=(<span class="number">1000</span>,<span class="number">4</span>),loc=<span class="number">0</span>,scale=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.boxplot(data)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/Python%E9%80%9A%E8%BF%87plt.boxplot()%E7%BB%98%E5%88%B6%E7%AE%B1%E5%9B%BE/20210122124811996.png" alt="在这里插入图片描述"></p><h2 id="3-3实战"><a href="#3-3实战" class="headerlink" title="3.3实战"></a>3.3实战</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plt_box_iamge</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    snrr的五个范围为[5,10)、[10,15)、[15,20)、[20,30)、[30-)，按照五个snrr范围计算对应redchi的箱图</span></span><br><span class="line"><span class="string">    :param df:包含snrr以及redchi的csv数据（dataFrame）。</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 根据snrr范围对redchi进行筛选。</span></span><br><span class="line">    df1 = df.loc[df[<span class="string">&#x27;lam_snrr&#x27;</span>] &gt;= <span class="number">5</span>]</span><br><span class="line">    redchi_1 = df1.loc[df1[<span class="string">&#x27;lam_snrr&#x27;</span>] &lt; <span class="number">10</span>].redchi</span><br><span class="line"></span><br><span class="line">    df2 = df.loc[df[<span class="string">&#x27;lam_snrr&#x27;</span>] &gt;= <span class="number">10</span>]</span><br><span class="line">    redchi_2 = df2.loc[df2[<span class="string">&#x27;lam_snrr&#x27;</span>] &lt; <span class="number">15</span>].redchi</span><br><span class="line"></span><br><span class="line">    df3 = df.loc[df[<span class="string">&#x27;lam_snrr&#x27;</span>] &gt;= <span class="number">15</span>]</span><br><span class="line">    redchi_3 = df3.loc[df3[<span class="string">&#x27;lam_snrr&#x27;</span>] &lt; <span class="number">20</span>].redchi</span><br><span class="line"></span><br><span class="line">    df4 = df.loc[df[<span class="string">&#x27;lam_snrr&#x27;</span>] &gt;= <span class="number">20</span>]</span><br><span class="line">    redchi_4 = df4.loc[df4[<span class="string">&#x27;lam_snrr&#x27;</span>] &lt; <span class="number">30</span>].redchi</span><br><span class="line"></span><br><span class="line">    redchi_5 = df.loc[df[<span class="string">&#x27;lam_snrr&#x27;</span>] &gt;= <span class="number">30</span>].redchi</span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    ax = plt.subplot()</span><br><span class="line">    ax.boxplot([redchi_1, redchi_2, redchi_3, redchi_4, redchi_5])</span><br><span class="line">    <span class="comment"># 设置轴坐标值刻度的标签</span></span><br><span class="line">    ax.set_xticklabels([<span class="string">&#x27;5&lt;=snrr&lt;10&#x27;</span>, <span class="string">&#x27;10&lt;=snrr&lt;15&#x27;</span>, <span class="string">&#x27;15&lt;=snrr&lt;20&#x27;</span>, <span class="string">&#x27;20&lt;=snrr&lt;30&#x27;</span>, <span class="string">&#x27;30&lt;=snrr&#x27;</span>], fontsize=<span class="number">8</span>)</span><br><span class="line"><span class="comment">#保存图片 </span></span><br><span class="line">    plt.savefig(<span class="string">&#x27;./images/box.jpg&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;./inputfile/lamost6w_new.csv&#x27;</span>)</span><br><span class="line">    df_sc = screening(df)  <span class="comment"># 筛选数据 (lamost数据应该在正常值范围内，不然因为数值差过大会导致绘制不出图像!)</span></span><br><span class="line">    plt_box_iamge(df_sc)</span><br></pre></td></tr></table></figure><p><img src="/img/Python%E9%80%9A%E8%BF%87plt.boxplot()%E7%BB%98%E5%88%B6%E7%AE%B1%E5%9B%BE/20210122135648812.png" alt="在这里插入图片描述"></p><h2 id="3-3-参数详解"><a href="#3-3-参数详解" class="headerlink" title="3.3 参数详解"></a>3.3 参数详解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.boxplot(x,                      <span class="comment"># x：指定要绘制箱图的数据</span></span><br><span class="line">            notch=<span class="literal">None</span>,           <span class="comment"># notch：是否是凹口的形式展现箱线图，默认非凹口</span></span><br><span class="line">            sym=<span class="literal">None</span>,              <span class="comment"># sym：指定异常点的形状，默认为+号显示</span></span><br><span class="line">            vert=<span class="literal">None</span>,              <span class="comment"># vert：是否需要将箱线图垂直摆放，默认垂直摆放</span></span><br><span class="line">            whis=<span class="literal">None</span>,             <span class="comment"># whis：指定上下须与上下四分位的距离，默认为1.5倍的四分位差</span></span><br><span class="line">            positions=<span class="literal">None</span>,   <span class="comment"># positions：指定箱线图的位置，默认为[0,1,2…]</span></span><br><span class="line">            widths=<span class="literal">None</span>,         <span class="comment"># widths：指定箱线图的宽度，默认为0.5</span></span><br><span class="line">            patch_artist=<span class="literal">None</span>,        <span class="comment"># patch_artist：是否填充箱体的颜色</span></span><br><span class="line">            meanline=<span class="literal">None</span>,             <span class="comment"># meanline：是否用线的形式表示均值，默认用点来表示</span></span><br><span class="line">            showmeans=<span class="literal">None</span>,       <span class="comment"># showmeans：是否显示均值，默认不显示</span></span><br><span class="line">            showcaps=<span class="literal">None</span>,           <span class="comment"># showcaps：是否显示箱线图顶端和末端的两条线，默认显示</span></span><br><span class="line">            showbox=<span class="literal">None</span>,             <span class="comment"># showbox：是否显示箱线图的箱体，默认显示</span></span><br><span class="line">            showfliers=<span class="literal">None</span>,          <span class="comment"># showfliers：是否显示异常值，默认显示</span></span><br><span class="line">            boxprops=<span class="literal">None</span>,           <span class="comment"># boxprops：设置箱体的属性，如边框色，填充色等</span></span><br><span class="line">            labels=<span class="literal">None</span>,                  <span class="comment"># labels：为箱线图添加标签，类似于图例的作用</span></span><br><span class="line">            flierprops=<span class="literal">None</span>,          <span class="comment"># filerprops：设置异常值的属性，如异常点的形状、大小、填充色等</span></span><br><span class="line">            medianprops=<span class="literal">None</span>,   <span class="comment"># medianprops：设置中位数的属性，如线的类型、粗细等</span></span><br><span class="line">            meanprops=<span class="literal">None</span>,       <span class="comment"># meanprops：设置均值的属性，如点的大小、颜色等</span></span><br><span class="line">            capprops=<span class="literal">None</span>,           <span class="comment"># capprops：设置箱线图顶端和末端线条的属性，如颜色、粗细等</span></span><br><span class="line">            whiskerprops=<span class="literal">None</span>)   <span class="comment"># whiskerprops：设置须的属性，如颜色、粗细、线的类型等</span></span><br></pre></td></tr></table></figure><h2 id="3-4-常用方法"><a href="#3-4-常用方法" class="headerlink" title="3.4 常用方法"></a>3.4 常用方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">data = np.random.normal(size=(<span class="number">1000</span>,<span class="number">4</span>),loc=<span class="number">0</span>,scale=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax = plt.subplot()</span><br><span class="line">ax.boxplot(data)                                 <span class="comment"># 绘图</span></span><br><span class="line">ax.set_xlim([<span class="number">0</span>,<span class="number">5</span>])                               <span class="comment"># 设置x轴值的范围  rotation=30</span></span><br><span class="line"><span class="comment"># ax.set_xticks()        # 自定义x轴的值</span></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;xlabel&quot;</span>)                  <span class="comment"># 设置x轴的标签</span></span><br><span class="line">ax.set_xticklabels([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>],  rotation=<span class="number">30</span>,fontsize=<span class="number">10</span>)   <span class="comment"># 设置x轴坐标值的标签 旋转角度 字体大小</span></span><br><span class="line">ax.set_title(<span class="string">&quot;xcy&quot;</span>)         <span class="comment"># 设置图像标题</span></span><br><span class="line">ax.legend(labels= [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>],loc=<span class="string">&#x27;best&#x27;</span>,)  <span class="comment"># 增加图例</span></span><br><span class="line">ax.text(x=<span class="number">0.2</span> , y=<span class="number">3.5</span> , s=<span class="string">&quot;test&quot;</span> ,fontsize=<span class="number">12</span>)   <span class="comment"># 增加注</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p>参考：<br>百度百科<br>matplotlib官方文档</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 箱图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python|数据分析三剑客之Numpy.md</title>
      <link href="/article/13f11e39.html"/>
      <url>/article/13f11e39.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>开始之前，请配置好python环境，同时检查是否安装了第三方库：numpy。</p></blockquote><h2 id="1-数据的维度"><a href="#1-数据的维度" class="headerlink" title="1. 数据的维度"></a>1. 数据的维度</h2><p>首先我们来了解一下基本概念。</p><h4 id="1-1-什么是维度？"><a href="#1-1-什么是维度？" class="headerlink" title="1.1 什么是维度？"></a>1.1 什么是维度？</h4><p>  维度就是一组数据的组织形式。</p><h4 id="1-2-一维数据"><a href="#1-2-一维数据" class="headerlink" title="1.2 一维数据"></a>1.2 一维数据</h4><p>  一维数据由对等关系的有序或无序数据构成，采用线性方式表示。即所有的数据都排列在同一方向上。如python中列表和集合的概念。<br>在python中可以通过如下方式来表示一维数据：</p><ul><li>列表</li><li>集合</li></ul><h4 id="1-3-二维数组"><a href="#1-3-二维数组" class="headerlink" title="1.3 二维数组"></a>1.3 二维数组</h4><p>二维数组有多个一维数据构成，是一维数据的组合形式。如表格、二维数组等。</p><ul><li>二维列表</li></ul><h4 id="1-4-多维数据"><a href="#1-4-多维数据" class="headerlink" title="1.4 多维数据"></a>1.4 多维数据</h4><p>  多数据是基于一维和二维数据，从而在新维度上扩展形成。如在二维数据上在增加一个时间维度，这就变成了一个三维数据。 </p><ul><li>多维列表</li></ul><h4 id="1-5-高维数据"><a href="#1-5-高维数据" class="headerlink" title="1.5 高维数据"></a>1.5 高维数据</h4><p>高维数据仅仅利用最基本的二元关系展示数据间的复杂结构。如复合型键值对。</p><ul><li>字典</li><li>josn</li><li>XML</li><li>YAML</li></ul><h2 id="2-NumPy的数组对象：ndarray"><a href="#2-NumPy的数组对象：ndarray" class="headerlink" title="2. NumPy的数组对象：ndarray"></a>2. NumPy的数组对象：ndarray</h2><h4 id="2-1NumPy是什么？"><a href="#2-1NumPy是什么？" class="headerlink" title="2.1NumPy是什么？"></a>2.1NumPy是什么？</h4><p>numpy是一个开源的、用于科学计算的基础的第三方库。</p><ul><li>numpy提供了一个强大的N维数组对象：ndarray</li><li>具有广播功能的函数</li><li>具有线性代数、傅里叶变换、随机数生成等功能</li><li>NumPy是SciPy、pandas等数据处理或科学计算库的基础。</li></ul><h4 id="2-2-NUmPy的引入方式"><a href="#2-2-NUmPy的引入方式" class="headerlink" title="2.2 NUmPy的引入方式"></a>2.2 NUmPy的引入方式</h4><p>一般的，我们习惯上运用如下方式来引用numpy库  ：</p><pre><code>import numpy as np</code></pre><h4 id="2-3-ndarray数组对象有什么用？"><a href="#2-3-ndarray数组对象有什么用？" class="headerlink" title="2.3 ndarray数组对象有什么用？"></a>2.3 ndarray数组对象有什么用？</h4><p> 这里我们先借用代码来感觉其优势：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求（a的三次方+b的二次方）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通列表</span></span><br><span class="line">a= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">b= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    c.append((a[i]**<span class="number">3</span> + b[i]**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy数组对象</span></span><br><span class="line">c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">d = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">e = c**<span class="number">3</span> + d**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>通过以上代码可以发现，ndarray数组对象可以去掉元素间运算所需的循环，使一维向量更想单个数据，从而使使用者更专心于数据计算，而这仅仅是其中之一，下面让我们进一步了解numpy。</p><h4 id="2-4-ndarray数组对象"><a href="#2-4-ndarray数组对象" class="headerlink" title="2.4 ndarray数组对象"></a>2.4 ndarray数组对象</h4><p>ndarray是一个多维数组对象，由两部分构成：</p><ul><li>实际数据</li><li>描述这些数据的元数据（数据维度、数据类型等）</li></ul><p>此外，ndarray数组<strong>一般</strong>要求所有元素类型相同，数组下标从0开始。  </p><p><em><strong>想一想：数组与python中的列表有什么区别呢？</strong></em>  </p><p>在程序中，ndarray的别名是array，因此我们可以使用np.array（）来生成一个ndarray数组。需要注意的是，通过print（）输出ndarray数组时，元素之间的分隔符不再是“，”，而是空格。  </p><p>对于ndarray有两个基本的概念，轴和秩。</p><ul><li>轴（axis）：保存数据的维度，</li><li>秩（rank）：轴的数量，即数据的维度。</li></ul><p>ndarray对象的属性有如下几个：</p><ul><li>.adim:秩，即轴的数量或数据的维度</li><li>.shape： ndarray对象的尺度</li><li>.size：ndarray对象元素的个数</li><li>.dtype：ndarray对象的元素类型</li><li>.itemsize：ndarray对象中每个元素的大小，以字节为单位</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.ndim)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">int32   </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="2-5-ndarraay数组的创建和变换"><a href="#2-5-ndarraay数组的创建和变换" class="headerlink" title="2.5 ndarraay数组的创建和变换"></a>2.5 ndarraay数组的创建和变换</h4><p>创建ndarray的方法共有4种，具体如下：  </p><p>（1）从python的列表、元组等类型中创建ndarray数组:<br>x &#x3D; np.array(list&#x2F;tuple,dtype&#x3D;np.**)。</p><ul><li>参数一：可以直接写入list&#x2F;tuple,也可以将list&#x2F;tuple传入其中</li><li>参数二：指定ndarray数组对象类型。当np.array()不指定dtype时，numpy将根据数据情况关联一个dtype类型。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">b = np.array(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;间接传参方法：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接传参方法：&quot;</span>)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表、元组混合使用：&quot;</span>)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">间接传参方法：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">直接传参方法：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">列表、元组混合使用：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>（2）使用numpy中的函数创建ndarray数组，如arange、ones和zeros等。 </p><ul><li>np.arrange(low,high,step,dtype):类似range函数，返回ndarray类型</li><li>np.ones(shape):根据指定的元组shape来创建一个全1的数组</li><li>np.zeros(shape)；根据指定的元组shape来创建一个全0的数组</li><li>np.full(shape,val)：根据指定的元组shape来创建一个全val的数组</li><li>np.eye(n)：创建一个n*n的正方形单位矩阵，对角线为1，其余为0</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">间接传参方法：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">直接传参方法：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">列表、元组混合使用：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用arange：</span><br><span class="line">[ <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br><span class="line">使用ones：</span><br><span class="line">[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">使用zeros：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br><span class="line">使用full：</span><br><span class="line">[[<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]]</span><br><span class="line">使用eye：</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>此外，numpy还提供了几个“模仿”样式的函数：</p><ul><li>np.ones_like(a)</li><li>np.zeros_like(a)</li><li>np.full_like(a,val)<br>三着分别是生成和a形状相同且元素为0&#x2F;1&#x2F;val的数组。<br>（3）使用numpy中其它函数创建ndarray数组</li><li>np.linspace(low,hig h,num):根据起止数据等间距填充数据，其中num是生成元素的个数</li><li>np.concatenate(a,b):将两个或多个数组合并，形成一个新的数组</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">c = np.concatenate((a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>,c)</span><br></pre></td></tr></table></figure><p>输出为：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a: [ <span class="number">1.</span>    <span class="number">3.25</span>  <span class="number">5.5</span>   <span class="number">7.75</span> <span class="number">10.</span>  ]</span><br><span class="line">b: [ <span class="number">1.</span>    <span class="number">5.75</span> <span class="number">10.5</span>  <span class="number">15.25</span> <span class="number">20.</span>  ]</span><br><span class="line">c [ <span class="number">1.</span>    <span class="number">3.25</span>  <span class="number">5.5</span>   <span class="number">7.75</span> <span class="number">10.</span>    <span class="number">1.</span>    <span class="number">5.75</span> <span class="number">10.5</span>  <span class="number">15.25</span> <span class="number">20.</span>  ]</span><br></pre></td></tr></table></figure><p>对创建后ndarray数组，可以对其进行维度变换和元素变换，这统称为ndarray数组的变换。常用的变换方法有如下几种：</p><ul><li>.reshape(shape): 返回一个由原元素构成的新的shape形状的数组，原数组不变</li><li>.resize(shape): 功能同上，但修改原数组</li><li>.swapaxes(ax1,ax2): 将两个数组的维度进行调换</li><li>.flatten(): 对数组进行降维，原数组不变</li><li>.tolist(): 转换成python中的列表</li><li>.astype(): 对数组进行类型转换，返回一个新数组，原数组不变</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变换前的a:\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">b = a.reshape((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经reshape变换后的a:\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经reshape变换后的的返回值:\n&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">c = a.resize((<span class="number">3</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经resize变换后的a:\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经resize变换后的的返回值:\n&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变换前的a:\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">d = a.flatten()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经flatten变换后的a:\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经flatten变换后的的返回值:\n&quot;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变换前的a:</span><br><span class="line">   [[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  </span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]]</span><br><span class="line">  **************************************************</span><br><span class="line">  经reshape变换后的a:</span><br><span class="line">   [[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  </span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]]</span><br><span class="line">  经reshape变换后的的返回值:</span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">   [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">   [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  **************************************************</span><br><span class="line">  经resize变换后的a:</span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">   [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">   [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  经resize变换后的的返回值:</span><br><span class="line">   <span class="literal">None</span></span><br><span class="line">  **************************************************</span><br><span class="line">  变换前的a:</span><br><span class="line">   [[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  </span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]]</span><br><span class="line">  经flatten变换后的a:</span><br><span class="line">   [[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line">  </span><br><span class="line">   [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">    [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]]</span><br><span class="line">  经flatten变换后的的返回值:</span><br><span class="line">   [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">  **************************************************</span><br></pre></td></tr></table></figure><p><em><strong>想一想：通过以上代码，你发现了什么？</strong></em></p><h4 id="2-6-ndarray数组的索引和切片"><a href="#2-6-ndarray数组的索引和切片" class="headerlink" title="2.6 ndarray数组的索引和切片"></a>2.6 ndarray数组的索引和切片</h4><ul><li>索引：获取数组中特定位置元素的过程</li><li>切片：获取数组元素子集的过程。</li></ul><p>（1）一维数组的索引和切片<br>ndarray一维数组的索引和切片和python相同,这里通过代码进行解释;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组a为：&quot;</span>,a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取下标为3的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下标为3的元素：&quot;</span>,a[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行切片操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;切片：&quot;</span>,a[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>输出为:  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数组a为： [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">下标为<span class="number">3</span>的元素： <span class="number">4</span></span><br><span class="line">切片： [<span class="number">1</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>（2）二维及多维数组的索引和切片<br>二维数组的索引和切片其实就是一维数组的叠加。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取【1,2,1】：&quot;</span>,a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">b = a[:,<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>,::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;切片后：\n&quot;</span>,b)</span><br></pre></td></tr></table></figure><p>输出为：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]]</span><br><span class="line">取【<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>】： <span class="number">21</span></span><br><span class="line">切片后：</span><br><span class="line"> [[[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">8</span> <span class="number">10</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">12</span> <span class="number">14</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">22</span>]]]</span><br></pre></td></tr></table></figure><p>通过代码可以发现，实际上每个维度切片方法都与一维数组相同，即多个一维的叠加使用。</p><h4 id="2-6-ndarray数组的运算"><a href="#2-6-ndarray数组的运算" class="headerlink" title="2.6 ndarray数组的运算"></a>2.6 ndarray数组的运算</h4><p>（1）标量运算：数组数组与标量（常量）的运算作用于数组的每一个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原数组为：&quot;</span>,a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c*4=&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">c = a*<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>输出如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原数组为： [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">c*<span class="number">4</span>=[ <span class="number">4</span>  <span class="number">8</span> <span class="number">12</span> <span class="number">16</span> <span class="number">20</span> <span class="number">24</span> <span class="number">28</span> <span class="number">32</span> <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p>（2）一元函数运算</p><ul><li>np.abs(a):计算数组各元素的绝对值</li><li>np.sqrt(a):计算数组各元素的平方根</li><li>np.square(a):计算数组各元素的平方</li><li>np.log(a)&#x2F;np.log2(a)&#x2F;np.log10(a):计算数组各元素的对数</li><li>np.rint(a):计算数组各元素的四舍入值</li><li>np.modf(a)：分离元素的小数和整数部分，并以两个独立数组形式返回</li><li>np.cos(a)</li><li>np.sin(a)</li><li>np.tan(a):计算三角函数</li><li>np.cxp(a)：计算各元素的指数值</li><li>np.sign(a)：计算各元素的符号值1（+）,-1（-），0（0）<br>（3）二元函数运算</li><li>+- * &#x2F; **:基本运算</li><li>np.fmax(a,b)：元素级取最大</li><li>np.fmin(a,b)：元素级取最小</li><li>np.mod(a,b): 元素级模运算</li><li>np.copysign(a,b): 将y中元素符号赋给对应的a元素</li><li>&lt; &gt; &#x3D; !&#x3D;等比较：元素级比较，产生Boolean值</li></ul><h2 id="3-numpy的随机数函数"><a href="#3-numpy的随机数函数" class="headerlink" title="3. numpy的随机数函数"></a>3. numpy的随机数函数</h2><p>numpy的随机数函数都存放在random子库中，其中一些常用的基础函数如下</p><ul><li>rand(d0,d1,d2,,,dn): 根据d0-dn创建随机数函数，元素范围为[0,1)的浮点数，且均匀分布</li><li>randn(d0,d1,d2,,,dn): 根据d0-dn创建随机数函数，元素范围的浮点数，元素符合标准正态分布</li><li>randint(low,[high,shape]): 根据shape创建一个范围在[low，high)之间的随机整数数组。</li><li>sedd(s)：随机数种子</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rand函数:\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">b = np.random.randn(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;randn函数：\n&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">c = np.random.randint(<span class="number">10</span>,<span class="number">50</span>,(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;randint函数：\n&quot;</span>,c)</span><br></pre></td></tr></table></figure><p>输出如下：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rand函数:</span><br><span class="line"> [[<span class="number">0.09798002</span> <span class="number">0.49921352</span> <span class="number">0.31738805</span> <span class="number">0.11513971</span>]</span><br><span class="line"> [<span class="number">0.73888379</span> <span class="number">0.20517624</span> <span class="number">0.5653194</span>  <span class="number">0.93201328</span>]</span><br><span class="line"> [<span class="number">0.08834032</span> <span class="number">0.59798905</span> <span class="number">0.14361878</span> <span class="number">0.13311843</span>]]</span><br><span class="line">randn函数：</span><br><span class="line"> [[ <span class="number">0.6802766</span>   <span class="number">0.03696936</span> -<span class="number">0.3010713</span> ]</span><br><span class="line"> [-<span class="number">0.91815841</span> -<span class="number">2.38550783</span>  <span class="number">1.28881925</span>]</span><br><span class="line"> [-<span class="number">0.63961654</span>  <span class="number">0.90820396</span>  <span class="number">0.38482065</span>]]</span><br><span class="line">randint函数：</span><br><span class="line"> [[<span class="number">39</span> <span class="number">40</span> <span class="number">43</span> <span class="number">43</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">14</span> <span class="number">17</span> <span class="number">28</span>]</span><br><span class="line"> [<span class="number">48</span> <span class="number">44</span> <span class="number">15</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">33</span> <span class="number">34</span> <span class="number">38</span> <span class="number">40</span>]]</span><br></pre></td></tr></table></figure><p> 此外，部分常用的高级的随机数函数有：</p><ul><li>shuffle(a): 根据数组的第0轴进行随机排序，改变数组a</li><li>permutation(a): 功能同上，但不改变原有数组，即返回一个新的数组</li><li>choice(a,[size,replace,p]): 从一维数组a中以概率p抽取元素，形成size形状的新数组，replace表示可以重复使用元素（默认为False）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.randint(<span class="number">10</span>,<span class="number">90</span>,(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原有数组a:\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">np.random.shuffle(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经shuffle变换后的a:\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_&quot;</span>*<span class="number">50</span>)</span><br><span class="line">a = np.random.randint(<span class="number">10</span>,<span class="number">90</span>,(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">b = np.random.permutation(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经permutation变换后的a：\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经permutation变换后的a：\n&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经permutation变换后返回的值：\n&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原有一维数组:\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">a = np.random.choice(a,(<span class="number">3</span>,<span class="number">4</span>),<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变换后的数组：\n&quot;</span>,a)</span><br></pre></td></tr></table></figure><p>输出如下：   </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">原有数组a:</span><br><span class="line">    [[<span class="number">64</span> <span class="number">34</span> <span class="number">56</span> <span class="number">55</span> <span class="number">26</span>]</span><br><span class="line">    [<span class="number">33</span> <span class="number">72</span> <span class="number">14</span> <span class="number">56</span> <span class="number">16</span>]</span><br><span class="line">    [<span class="number">55</span> <span class="number">45</span> <span class="number">26</span> <span class="number">43</span> <span class="number">71</span>]</span><br><span class="line">    [<span class="number">27</span> <span class="number">21</span> <span class="number">34</span> <span class="number">19</span> <span class="number">22</span>]]</span><br><span class="line">   经shuffle变换后的a:</span><br><span class="line">    [[<span class="number">33</span> <span class="number">72</span> <span class="number">14</span> <span class="number">56</span> <span class="number">16</span>]</span><br><span class="line">    [<span class="number">64</span> <span class="number">34</span> <span class="number">56</span> <span class="number">55</span> <span class="number">26</span>]</span><br><span class="line">    [<span class="number">55</span> <span class="number">45</span> <span class="number">26</span> <span class="number">43</span> <span class="number">71</span>]</span><br><span class="line">    [<span class="number">27</span> <span class="number">21</span> <span class="number">34</span> <span class="number">19</span> <span class="number">22</span>]]</span><br><span class="line">   __________________________________________________</span><br><span class="line">   经permutation变换后的a：</span><br><span class="line">    [[<span class="number">70</span> <span class="number">52</span> <span class="number">17</span> <span class="number">37</span> <span class="number">36</span>]</span><br><span class="line">    [<span class="number">15</span> <span class="number">28</span> <span class="number">33</span> <span class="number">23</span> <span class="number">58</span>]</span><br><span class="line">    [<span class="number">68</span> <span class="number">57</span> <span class="number">89</span> <span class="number">55</span> <span class="number">23</span>]</span><br><span class="line">    [<span class="number">55</span> <span class="number">43</span> <span class="number">35</span> <span class="number">64</span> <span class="number">17</span>]]</span><br><span class="line">   经permutation变换后的a：</span><br><span class="line">    [[<span class="number">70</span> <span class="number">52</span> <span class="number">17</span> <span class="number">37</span> <span class="number">36</span>]</span><br><span class="line">    [<span class="number">15</span> <span class="number">28</span> <span class="number">33</span> <span class="number">23</span> <span class="number">58</span>]</span><br><span class="line">    [<span class="number">68</span> <span class="number">57</span> <span class="number">89</span> <span class="number">55</span> <span class="number">23</span>]</span><br><span class="line">    [<span class="number">55</span> <span class="number">43</span> <span class="number">35</span> <span class="number">64</span> <span class="number">17</span>]]</span><br><span class="line">   经permutation变换后返回的值：</span><br><span class="line">    [[<span class="number">70</span> <span class="number">52</span> <span class="number">17</span> <span class="number">37</span> <span class="number">36</span>]</span><br><span class="line">    [<span class="number">15</span> <span class="number">28</span> <span class="number">33</span> <span class="number">23</span> <span class="number">58</span>]</span><br><span class="line">    [<span class="number">55</span> <span class="number">43</span> <span class="number">35</span> <span class="number">64</span> <span class="number">17</span>]</span><br><span class="line">    [<span class="number">68</span> <span class="number">57</span> <span class="number">89</span> <span class="number">55</span> <span class="number">23</span>]]</span><br><span class="line">   __________________________________________________</span><br><span class="line">   原有一维数组:</span><br><span class="line">    [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">   变换后的数组：</span><br><span class="line">    [[ <span class="number">2</span>  <span class="number">1</span>  <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line">    [<span class="number">11</span>  <span class="number">0</span>  <span class="number">7</span> <span class="number">11</span>]</span><br><span class="line">    [ <span class="number">1</span>  <span class="number">7</span>  <span class="number">1</span>  <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><p>最后，random还有一些关于分布的随机函数;</p><ul><li>uniform(low,high,size)：均匀分布的数组</li><li>normal(loc,scale,size): 正态分布的数组，loc为均值、scale为标准差，size为形状</li><li>poisson(lam,size): 泊松分布的数组，lam为随机事件发生概率，size为形状</li></ul><p>附：random中的统计函数：</p><ul><li>min()&#x2F;max()：最大最小值</li><li>argmin()&#x2F;argmax()：计算a中元素最大最小值，降一维后的下标</li><li>unuravel_index(index,shape)：根据shape将一维下标转换成多维下标</li><li>ptp()：计算极差</li><li>median():计算数组a中元素的中位数</li></ul><h2 id="4-numpy的统计函数"><a href="#4-numpy的统计函数" class="headerlink" title="4. numpy的统计函数"></a>4. numpy的统计函数</h2><ul><li>sum(a,axis&#x3D;None)：根据给定轴axis计算数组a相关元素之和，axis整<br>数或元组</li><li>mean(a,axis&#x3D;None)：根据给定轴axis计算数组a相关元素的期望，axis<br>整数或元组</li><li>average(a,axis&#x3D;None,weights&#x3D;None)：根据给定轴axis计算数组a相关元素的加权平均值</li><li>std(a,axis&#x3D;None)：根据给定轴axis计算数组a相关元素的标准差</li><li>var(a,axis&#x3D;None)：根据给定轴axis计算数组a相关元素的方差</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析三剑客之Matplotlib.md</title>
      <link href="/article/d8747af8.html"/>
      <url>/article/d8747af8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>开始之前，请配置好python环境，同时检查是否安装了第三方库：matplotlib。</p></blockquote><h2 id="1-matplotlib库的介绍"><a href="#1-matplotlib库的介绍" class="headerlink" title="1.  matplotlib库的介绍"></a>1.  matplotlib库的介绍</h2><h4 id="1-1-matplotlib库的介绍"><a href="#1-1-matplotlib库的介绍" class="headerlink" title="1.1 matplotlib库的介绍"></a>1.1 matplotlib库的介绍</h4><p>matplotlib库是一个数据可视化的一个第三方库，它包含了过百种图像。它结合matlab的优缺点，在此基础上形成了matplotlib。matplotlib由各种可视化类构成，内部结构复杂。因此，我们可以通过matplotlib的一个命令子库matplotlib.pyplot来调用这些基本功能。<br>一般，我们引用pyplot子库的方式为：  </p><pre><code>import matplotlib.pyplot as plt</code></pre><h4 id="1-2-牛刀小试"><a href="#1-2-牛刀小试" class="headerlink" title="1.2 牛刀小试"></a>1.2 牛刀小试</h4><p>我们先画一个简单的图像：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>])      <span class="comment"># 传入xy轴参数，默认为y轴</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Grade&quot;</span>)          <span class="comment"># 指定y轴 名称</span></span><br><span class="line">plt.savefig(<span class="string">&quot;test&quot;</span>,dpi=<span class="number">600</span>)  <span class="comment"># 保存图像 默认png格式，其中dpi指图片质量</span></span><br><span class="line">plt.show()                   <span class="comment"># 展示图片</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722104639890.png" alt="折线图"></p><h4 id="1-3-pyplot的绘图区域"><a href="#1-3-pyplot的绘图区域" class="headerlink" title="1.3 pyplot的绘图区域"></a>1.3 pyplot的绘图区域</h4><p>pyplot通过plt.subplot(nrows,ncols,plot_number)方法来实现在同一画板上画多幅子图。参数介绍如下：</p><ul><li>nrows：横向数量</li><li>ncols：纵向数量</li><li>plot_number：当前子图的区域位置。<br>如plt.subplot(2,2,3)就是表示将将一个全局绘图区域分成4个子区域，当前子图位于第3个子图位置。当子图数量为个位数时，subplot（）内参数可以不用逗号分隔，即subplot（223）。<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722111329919.png" alt="在这里插入图片描述"></li></ul><h4 id="1-4-pyplot的plot-绘图函数"><a href="#1-4-pyplot的plot-绘图函数" class="headerlink" title="1.4 pyplot的plot()绘图函数"></a>1.4 pyplot的plot()绘图函数</h4><p>plot是matplotlib中最主要的绘图函数，其全部参数介绍如下：<br>plt.plot(x,y,format_string,**kwargs)</p><ul><li>x: x轴的数据，可以是列表或数组，是一个可选参数</li><li>y：y轴的数据，可以是列表或数组，必选。</li><li>**kwargs：可以是第二条曲线的参数，需要注意的是，当绘制多条曲线时，xy参数都必须存在；也可以是color、linestyle、marker等等</li></ul><p>下面仔细讲解一下format_string参数：<br>format_string参数是控制曲线格式的字符串，虽然是可选参数，但是却非常重要。它由颜色字符、风格字符和标记字符组成，可以组合使用。   </p><p>（1）颜色字符，即控制曲线颜色的字符，由于控制颜色的字符较多，这里就仅列出一些常用的字符：</p><ul><li>b: 蓝色</li><li>g: 绿色</li><li>r: 红色</li><li>k: 黑色</li><li>w: 白色</li><li>y: 黄色</li><li>c: 青绿色</li><li>m: 洋红色</li><li>#000000： 此外还可以使用rgb颜色</li></ul><p>（2）风格字符，即控制曲线样式的字符：</p><ul><li>“_”:实线</li><li>“–”: 破折线</li><li>“:”: 虚线</li><li>“ “: 无线条</li></ul><p>（3）标记字符：即对数据坐标点的标记：</p><ul><li>“ .”: 点标记</li><li>“ ,”: 像素标记</li><li>“ v”: 倒三角标记</li><li>“ ^”: 上三角标记</li><li>“ &gt;”: 右三角标记</li><li>“ &lt;”: 左三角标记</li><li>“ 1”: 下花三角标记</li><li>“ 2”: 上花三角标记</li><li>“ 3”: 左花三角标记</li><li>“ 4”: 右花三角标记</li><li>“ s”: 实心方形标记</li><li>“ p”: 实心五角标记</li><li>“ *”: 星号标记</li><li>“ o”: 实心圈标记 </li><li>“ +”: +号标记</li><li>“ x”: x号标记</li><li>“ D”: 菱形标记</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(a,a,<span class="string">&quot;r--o&quot;</span>,a,a*<span class="number">2</span>,<span class="string">&quot;b:&quot;</span>,a,a*<span class="number">3</span>,<span class="string">&quot;y_&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;01&quot;</span>,dpi=<span class="number">600</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722111559132.png" alt="在这里插入图片描述"></p><h4 id="1-5-pyplot的中文显示"><a href="#1-5-pyplot的中文显示" class="headerlink" title="1.5 pyplot的中文显示"></a>1.5 pyplot的中文显示</h4><p>pyplot默认不支持中文显示，因此我们需要对其进行一下代码设置（如果不设置，输出时是一些空心的方形）。<br>更改字体的方法有两种，我们先来看一下第一种：  </p><p>（1）通过rcparams更改全局字体<br>先看一下如果不进行中文设置，会是什么效果，如图</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(a,np.cos(<span class="number">0.02</span>*a))</span><br><span class="line">plt.xlabel(<span class="string">&quot;这是中文&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;03&quot;</span>,dpi=<span class="number">600</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722112038692.png" alt="在这里插入图片描述"></p><p>可以发现，x轴的标志是一个个的方形。接下来我们引入matplotlib的rcparams来设置全局字体属性：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span>   <span class="comment"># 设置字体为黑体</span></span><br><span class="line">a = np.arange(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(a,np.cos(<span class="number">0.02</span>*a))</span><br><span class="line">plt.xlabel(<span class="string">&quot;这是中文&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;03&quot;</span>,dpi=<span class="number">600</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722112255983.png" alt="在这里插入图片描述"></p><p>可以发现，中文可以显示出来了。除了可以设置字体类型，它还有如下属性：</p><ul><li>font.style：字体风格（正常normal或斜体italic）</li><li>font.size: 字体大小</li></ul><p>但是，细心观察，无论是x轴的标志还是xy轴的尺度，它们的字体全部都变为了黑体。这对全局来说很不友好，因此，我们可以对显示中文的地方单独进行设置。即第二种方法，如下：  </p><p>（2）通过fontproperties参数单独设置字体：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib.rcParams[&quot;font.family&quot;] = &quot;SimHei&quot;   # 设置字体为黑体</span></span><br><span class="line">a = np.arange(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(a,np.cos(<span class="number">0.02</span>*a))</span><br><span class="line">plt.xlabel(<span class="string">&quot;这是中文&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>，fontsize=<span class="number">20</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;03&quot;</span>,dpi=<span class="number">600</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像的输出效果如下：</p><p><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722112532972.png" alt="在这里插入图片描述"><br>通过fontproperties参数我们可以方便的对所需文本进行设置，使得绘图更加灵活。</p><h4 id="1-6-pyplot的文本显示"><a href="#1-6-pyplot的文本显示" class="headerlink" title="1.6 pyplot的文本显示"></a>1.6 pyplot的文本显示</h4><p>文本显示就是为图像添加坐标轴、图例、标题和文本注释等内容,从而使图像更加专业化。同时支持LaTeX语法，使其更加具有专业性。前面我们使用plt.xlabel()来对x轴添加文本标签，就是文本显示函数之一，全部的文本显示标签如下：</p><ul><li>plt.xlabel():对x轴添加文本标签</li><li>plt.ylabel():对y轴添加文本标签</li><li>plt.tilte():对图像添加标题，位于图像上方中间位置</li><li>plt.text()：在任意位置添加文本注释</li><li>plt.annotate()：在图像中添加带有箭头的注解</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0.02</span>)</span><br><span class="line">plt.plot(a,np.cos(<span class="number">2</span>*np.pi*a), <span class="string">&quot;r--&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">18</span>,color=<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;振幅&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">18</span>,color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">plt.title(<span class="string">r&quot;正弦波图 $y=cos(2\pi x)$&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">26</span>)</span><br><span class="line">plt.text(<span class="number">2</span>,<span class="number">1</span>,<span class="string">r&quot;$\mu=100$&quot;</span>,fontsize=<span class="string">&quot;15&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.axis([-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">2</span>])  <span class="comment"># x轴坐标尺度</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)         <span class="comment"># 显示网格</span></span><br><span class="line">plt.savefig(<span class="string">&quot;04&quot;</span>,dpi=<span class="number">600</span>)</span><br></pre></td></tr></table></figure><p>图像如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722113341663.png" alt="在这里插入图片描述"></p><p>我们再来看一下plt.annotate()函数，它的参数如下：</p><ul><li>s: 注释文本内容</li><li>xy&#x3D;arrow_crd: 箭头指向的位置</li><li>xytext&#x3D;text_crd: 文本所在位置</li><li>arrowprops&#x3D;dict: 文本属性</li></ul><p>我们将上面的实例修改一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0.02</span>)</span><br><span class="line">plt.plot(a,np.cos(<span class="number">2</span>*np.pi*a), <span class="string">&quot;r--&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">18</span>,color=<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;振幅&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">18</span>,color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">plt.title(<span class="string">r&quot;正弦波图 $y=cos(2\pi x)$&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>,fontsize=<span class="number">22</span>)</span><br><span class="line"><span class="comment"># plt.text(2,1,r&quot;$\mu=100$&quot;,fontsize=&quot;15&quot;)</span></span><br><span class="line">plt.annotate(<span class="string">r&quot;$\mu=100$&quot;</span>,xy=(<span class="number">2</span>,<span class="number">1</span>),xytext=(<span class="number">3</span>,<span class="number">1.5</span>),arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&quot;black&quot;</span>,shrink=<span class="number">0.1</span>,width=<span class="number">2</span>))</span><br><span class="line">plt.axis([-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">2</span>,<span class="number">2</span>])  <span class="comment"># x轴坐标尺度</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)         <span class="comment"># 显示网格</span></span><br><span class="line">plt.savefig(<span class="string">&quot;04&quot;</span>,dpi=<span class="number">600</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下</p><p><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722113522137.png" alt="在这里插入图片描述"></p><h4 id="1-7-pyplot的子绘图区域"><a href="#1-7-pyplot的子绘图区域" class="headerlink" title="1.7 pyplot的子绘图区域"></a>1.7 pyplot的子绘图区域</h4><p>前面我们提到通过subplot函数来绘制多规则的子图区域，但如果我们希望在区域中绘制不规则的图像应该怎样处理呢？这里提供一个plt.subplot2grid()函数,用于设计复杂的子图结构。通过设计网格、选中网格，确定选中的行列并进行延伸扩展从而形成我们想要的区域。其参数如下：  </p><ul><li>gridspec:设定网格结构</li><li>curspec： 选定网格初始位置</li><li>colspan： 网格扩展列数（以当前为基准）</li><li>rowspan：网格扩展行数（以当前为基准）</li></ul><p>我们借助图像来进行理解：<br>plt.subplot((4,4)(2,0),colspan&#x3D;3，rowspan&#x3D;2)就是把绘图区域分成4*4个区域，然后以第3行第一列子区域（黑色）为基准，扩展2  列1行（灰色），即红色区域为但覆盖前子图区域，如图：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722113809400.png" alt="在这里插入图片描述"></p><p>以上方法在绘图时有较为复杂的代码，因此，matplotlib为我们提供了另外一个较为简单的设计复杂子图的库gridspec（），我们通过代码及图像进行讲解;<br>如图，若要选中灰色及黑色部分作为一个子图区域，我们可以这样做：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> gridspec</span><br><span class="line"></span><br><span class="line">gs = gridspec.GridSpec(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(gs[<span class="number">2</span>:,<span class="number">0</span>:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这非常类似于numpy中二维数组的切片操作。即，在gs二维数组中，我们选择一维中的下标为2及2以后的元素，然后选择二维中下标从0开始至倒数第2个结束的区域。</p><h4 id="1-8-关于pyplot基本图表函数"><a href="#1-8-关于pyplot基本图表函数" class="headerlink" title="1.8 关于pyplot基本图表函数"></a>1.8 关于pyplot基本图表函数</h4><p> pyplot的基本图表函数有很多很多种，而这些图表有的非常常用、有的很少用到（需要注意的是，少用不等于不重要）。在接下来的内容中博主仅简单介绍部分常用的图表，如若想了解更多的基本图表，可以去matplotlib的官网进行学习。这里提供一下链接：<a href="https://matplotlib.org/tutorials/introductory/pyplot.html#sphx-glr-tutorials-introductory-pyplot-py">matplotlib官网</a> </p><h4 id="1-9-pyplot饼图的绘制"><a href="#1-9-pyplot饼图的绘制" class="headerlink" title="1.9 pyplot饼图的绘制"></a>1.9 pyplot饼图的绘制</h4><p>饼图，具有简洁直观的特点，常用于带有百分号的数据。饼图通过plt.pie（）绘制:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   labels = <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>  <span class="comment"># 每一块的标签</span></span><br><span class="line">   sizes = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">20</span>]        <span class="comment"># 每一块饼图的尺寸</span></span><br><span class="line">   explode = (<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0</span>)       <span class="comment"># 指定哪一块是否突出，以及突出强度</span></span><br><span class="line">   </span><br><span class="line">   plt.pie(sizes,explode=explode,labels=labels,autopct=<span class="string">&quot;%1.1f%%&quot;</span>,shadow=<span class="literal">True</span>,startangle=<span class="number">90</span>)   <span class="comment"># autopct 是百分数的显示格式，shadow是否带有阴影 startangle是饼图的起始角度</span></span><br><span class="line">   plt.axis(<span class="string">&quot;equal&quot;</span>)  <span class="comment"># 画出图像是正圆形</span></span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure><p> 图像如下：<br> <img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722114838708.png" alt="在这里插入图片描述"></p><p> 更多信息请看<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie">官方pie（）文档</a></p><h4 id="1-10-pyplot直方图的绘制"><a href="#1-10-pyplot直方图的绘制" class="headerlink" title="1.10 pyplot直方图的绘制"></a>1.10 pyplot直方图的绘制</h4><p> 相信大家对直方图都不陌生，那么直方图应该如何绘制呢，我们先来看一段代码：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">mu = <span class="number">100</span></span><br><span class="line">sigma = <span class="number">200</span></span><br><span class="line">a = np.random.normal(mu,sigma,size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.hist(a,<span class="number">20</span>,histtype=<span class="string">&quot;stepfilled&quot;</span>,facecolor=<span class="string">&quot;b&quot;</span>,alpha=<span class="number">0.75</span>)</span><br><span class="line">plt.title(<span class="string">&quot;直方图&quot;</span>,fontproperties=<span class="string">&quot;SimHei&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：<br><img src="/img/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BMatplotlib/20200722115116657.png" alt="在这里插入图片描述"></p><p>我们通过numpy生成一个正太分布的数组a，并利用它绘制直方图。我们绘制直方图使用plt.hist()函数，其中a是传入的数据，第二个参数bin是用于控制图像中直方的个数（这里表示共有20个直方），这里个数划分的方法是从数组中选择最大最小两个值，在其范围内均分为bin个区域。每个bin内元素的个数，就是这个直方的高度。<br>更多信息请看<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html#matplotlib.pyplot.hist">官方hist()文档</a>。</p><h4 id="1-11-pyplot散点图的绘制"><a href="#1-11-pyplot散点图的绘制" class="headerlink" title="1.11 pyplot散点图的绘制"></a>1.11 pyplot散点图的绘制</h4><p> 散点图的绘制我们可以通过plot或scatter，其中scatter散点图的绘制和plot类似。这里不再过多介绍。<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html#matplotlib.pyplot.scatter">官方scatter()文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python|爬虫利器Requests.md</title>
      <link href="/article/48727427.html"/>
      <url>/article/48727427.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-requests简介"><a href="#1-requests简介" class="headerlink" title="1. requests简介"></a>1. requests简介</h3><p>获取网页最主要的就是如何<strong>模拟浏览器向服务器发送请求</strong>，而r第三方库requests库给我们提供了<strong>功能齐全</strong>的处理方法，下面就让我们一起来看一下requests库的强大之处吧！</p><h3 id="2-安装requests库"><a href="#2-安装requests库" class="headerlink" title="2.安装requests库"></a>2.安装requests库</h3><ul><li>liunx用户可以直接使用命令行模式：pip3 install requests</li><li>window10 用户也可以使用命令行模式：pip install requests或通过pycharm下载（<a href="https://blog.csdn.net/qq_45807032/article/details/106096113">教程链接在这里</a>）。</li></ul><h3 id="3-requests库的请求方法"><a href="#3-requests库的请求方法" class="headerlink" title="3. requests库的请求方法"></a>3. requests库的请求方法</h3><h4 id="3-1-requests-get-url，params，headers"><a href="#3-1-requests-get-url，params，headers" class="headerlink" title="3.1 requests.get(url，params，headers)"></a>3.1 requests.get(url，params，headers)</h4><p>构造一个向服务器请求的<strong>Request对象</strong>，并返回一个<strong>Response对象</strong>。这是最常用的方法，务必<strong>熟练</strong>掌握。其中response主要的属性如下：</p><ul><li>text：HTTP响应内容的字符串形式，即，url对应的页面内容</li><li>content ：HTTP响应内容的二进制形式  </li><li>encoding：从HTTP header中猜测的响应内容编码方式</li><li>status_code：HTTP请求的返回状态，200表示连接成功，404表示失败     </li><li>apparent_ encoding：从内容中分析出的响应内容编码方式(备选编码方式) </li><li>history：请求历史</li><li>headers：响应的头部信息</li><li>cookies：记录在响应中的cookies</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应的内容文本</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应的内容（二进制形式）</span></span><br><span class="line"><span class="built_in">print</span>(response.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从响应头部中得到的编码方式</span></span><br><span class="line"><span class="built_in">print</span>(response.encoding)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应体中得到的编码方式</span></span><br><span class="line"><span class="built_in">print</span>(response.apparent_encoding)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态码，用查看请求状态</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应的头部</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应cookies</span></span><br><span class="line"><span class="built_in">print</span>(response.cookies) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url</span></span><br><span class="line"><span class="built_in">print</span>(response.url)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求历史</span></span><br><span class="line"><span class="built_in">print</span>(response.history)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200513202017870.png" alt="在这里插入图片描述"><br>  <strong>参数url</strong>是指需要爬取的网页的 url；<strong>参数headers</strong>是指需要传递的<strong>头部</strong>信息，如<strong>User-Agent，cookies</strong>等；<strong>params</strong> 是需要<strong>传递的参数</strong>,示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url1 =<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">response1 = requests.get(url1,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(response1.content)</span><br><span class="line"><span class="built_in">print</span>(response1.text)  <span class="comment"># 注意区分两者区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取二进制数据，如图片，视频等</span></span><br><span class="line">url2 = <span class="string">&quot;http://github.com/favicon.ico&quot;</span></span><br><span class="line">response2 = requests.get(url2,headers=headers)</span><br><span class="line">p = <span class="built_in">open</span>(<span class="string">&quot;github.ico&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">p.write(response2.content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;图片下载完成&quot;</span>)</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下载的图片如下：<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200513202400926.png" alt="在这里插入图片描述"></p><h4 id="3-2-requests-post-url-data，file"><a href="#3-2-requests-post-url-data，file" class="headerlink" title="3.2 requests.post(url,data，file)"></a>3.2 requests.post(url,data，file)</h4><p>   HTML网页提交<strong>POST请求</strong>的方法。参数data是提交的数据（一般为<strong>字典或json</strong>类型）；file是上传的文件。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;http://www.httpbin.org/post&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaowang&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;16&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(url,data=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>运行结果如下，可见提交的数据存放在了<strong>form</strong>中。<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200513203300702.png" alt="在这里插入图片描述"></p><h4 id="3-3requests-put-）"><a href="#3-3requests-put-）" class="headerlink" title="3.3requests.put(）"></a>3.3requests.put(）</h4><p>  向HTML网页提交<strong>PUT请求</strong>的方法 。</p><h4 id="3-4-requests-head-）"><a href="#3-4-requests-head-）" class="headerlink" title="3.4 requests.head(）"></a>3.4 requests.head(）</h4><p>获取HTML网页<strong>头</strong>信息的方法。</p><h4 id="3-5-requests-patch"><a href="#3-5-requests-patch" class="headerlink" title="3.5 requests.patch()"></a>3.5 requests.patch()</h4><p>向HTML网页提交<strong>局部修改请求</strong>。</p><h4 id="3-6-requests-delete"><a href="#3-6-requests-delete" class="headerlink" title="3.6 requests.delete()"></a>3.6 requests.delete()</h4><p>  向HTML页面提交<strong>删除请求</strong>。<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20200514105103201.png">https://img-blog.csdnimg.cn/20200514105103201.png</a></p><h3 id="4-requests库的异常"><a href="#4-requests库的异常" class="headerlink" title="4. requests库的异常"></a>4. requests库的异常</h3><ul><li>requests.HTTPError：HTTP网页<strong>状态异常</strong>，正常情况下状态码是<strong>200</strong></li><li>requests.Timeout：请求<strong>超时异常</strong>（从发起url请求到获得内容的整个时间段）</li><li>requests.URLRequired：<strong>URL缺失异常</strong></li><li>requests.ConnectTimeout：仅指<strong>连接远程服务器超时异常</strong></li><li>requests.ConnectionError：<strong>网络连接错误异常</strong> ，如DNS查询失败、 拒绝连接等</li><li>requests.TooManyRedirects：超过最大重定向次数， 产生<strong>重定向异常</strong>。<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200514105345747.png" alt="在这里插入图片描述"></li></ul><h3 id="5-维持会话"><a href="#5-维持会话" class="headerlink" title="5. 维持会话"></a>5. 维持会话</h3><h4 id="5-1为什么要维持会话？"><a href="#5-1为什么要维持会话？" class="headerlink" title="5.1为什么要维持会话？"></a>5.1为什么要维持会话？</h4><p>正常情况下，如果直接使用get等请求方法多次请求网页，对方不会认可这是一次会话，也就是说，<strong>每一次请求都是一个新的会话</strong>。在需要登录操作时，你需要多次爬取其网站信息，这时就会产生错误（第一次请求登录了，但第二次请求没有登录）。这时<strong>维持会话</strong>就起到相应作用了。requests库提供的<strong>session</strong>对象可以帮我们简便的维持一个会话，而不用担心其他问题。下面我们就来看一下session的作用吧！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通的多次的登录并不会保存相同的cookies</span></span><br><span class="line">r1 = requests.get(<span class="string">&quot;http://www.httpbin.org/cookies/set/number/11111111111&quot;</span>)</span><br><span class="line">r2 = requests.get(<span class="string">&quot;http://www.httpbin.org/cookies&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r2.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">s = requests.session()  <span class="comment"># 建立会话对象</span></span><br><span class="line">s.get(<span class="string">&quot;http://www.httpbin.org/cookies/set/number/2222222222&quot;</span>)   <span class="comment"># 通过会话对象进行请求操作，设置cookies</span></span><br><span class="line">response = s.get(<span class="string">&quot;http://www.httpbin.org/cookies&quot;</span>)   <span class="comment"># 同一会话再次请求，查询cookies</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下。可以发现，普通情况下，会话r1 进行设置本次会话的cookies，但再次请求时cookies不再相同，说明<strong>不再是同一会话</strong>；维持会话状态下<strong>两次的cookies相同</strong>，说明这是同一会话。因此，session常用于带有<strong>模拟登录</strong>的操作。<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/2020051321133438.png" alt="在这里插入图片描述"></p><h3 id="6-SSL证书验证"><a href="#6-SSL证书验证" class="headerlink" title="6. SSL证书验证"></a>6. SSL证书验证</h3><p>一些加密网站需要被<strong>官方CA机构信任</strong>，如果没有被认证，就会出现<strong>证书验证错误</strong>的结果。<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200514093021976.jpg" alt="在这里插入图片描述"><br>当爬取时，如果我们直接请求网站，就会抛出异常<strong>SSLError</strong>，表示证书验证错误。不用担心，requests库已经为我们想到了解决办法。它提供了一个参数<strong>verify</strong>，默认情况下是<strong>True（不检查证书）</strong>，我们只需将其设置成False即可。但此时我们会收到一个<strong>警告</strong>，我们可以通过设置<strong>忽略警告</strong>的方式来处理。具体如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()   <span class="comment"># 忽视警告</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://www.12306.cn&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></table></figure><p>这时，再次的爬取网站就可以正常访问了。<br><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200514093819741.png" alt="在这里插入图片描述"></p><h3 id="7-代理设置"><a href="#7-代理设置" class="headerlink" title="7. 代理设置"></a>7. 代理设置</h3><h4 id="7-1-什么是代理？"><a href="#7-1-什么是代理？" class="headerlink" title="7.1 什么是代理？"></a>7.1 什么是代理？</h4><p>在实际爬取过程中，服务器会检测某个ip的访问频率，由于<strong>爬虫爬取频率过快</strong>，一些网站就会出现<strong>验证提示</strong>，或直接<strong>封ip</strong>，更或者不动声色的<strong>返回错误的数据信息</strong>。为解决这种问题，我们需要来<strong>伪装自己的ip</strong>，这时就需要代理了。代理实际上就是<strong>代理服务器</strong>，他的功能是代理用户去取得网络信息。形象的来说，就是一个代理人。利用代理人替我们来爬取数据，这样就可以解决问题了。#### 7.2 设置代理<br>强大的requests为我们设置了一个参数<strong>proxies</strong>，用来设置代理。参数proxies是一个字典，键名是协议，键值是ip和端口。具体如下（此处的代理不是真正的）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>:<span class="string">&quot;127.0.0.1:1314&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>:<span class="string">&quot;127.0.0.1:2345&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url,proxies)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>如果代理服务器需要<strong>用户名和密码</strong>，则可以设置如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>:<span class="string">&quot;username：password@127.0.0.1:1314&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>:<span class="string">&quot;username：password@127.0.0.1:2345&quot;</span></span><br></pre></td></tr></table></figure><h4 id="8-超时设置"><a href="#8-超时设置" class="headerlink" title="8. 超时设置"></a>8. 超时设置</h4><p>我们请求父服务器并得到其响应需要一定的时间。我们有时会等待特别长的时间。因此为了<strong>防止不能及时得到服务器的响应</strong>，requests库提供了一个<strong>超时设置</strong>的参数t<strong>imeout</strong>。在规定的时间内得不到响应就会抛出异常ConnectTimeout。因此我们可以通过<strong>设置捕获异常</strong>来进行处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>,timeout=<span class="number">0.01</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><p><img src="/img/Python%7C%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8Requests/20200514094828805.png" alt="在这里插入图片描述"></p><h4 id="9-身份验证"><a href="#9-身份验证" class="headerlink" title="9. 身份验证"></a>9. 身份验证</h4><p>在访问网络时，我们可能会面临<strong>身份验证</strong>的问题。这时，直接登录就会出现异常。requests库的<strong>auth</strong>参数为我们提供了登录方法。<strong>auth是一个元组，元素1为用户名，元素2为密码。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">auth = (<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)  <span class="comment"># 元组，用户名，密码</span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>,auth=auth) <span class="comment"># 此url请更换</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br></pre></td></tr></table></figure><h4 id="10-Request方法"><a href="#10-Request方法" class="headerlink" title="10.  Request方法"></a>10.  Request方法</h4><pre><code>    我们可以将请求表示为**数据结构**，将各个参数都通过一个request来表示，这样我们就可以将请求当做**独立的对象**来看待，这在后续进行**队列调度**时会非常方便。如下实例：</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.httpbin.org/post&quot;</span></span><br><span class="line">data=&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">request = requests.Request(<span class="string">&quot;post&quot;</span>,url,data=data,headers=headers)</span><br><span class="line"></span><br><span class="line">prepared = s.prepare_request(request)</span><br><span class="line">response = s.send(prepared)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 第三方库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PythonPython迭代器</title>
      <link href="/article/452ead1d.html"/>
      <url>/article/452ead1d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是迭代器"><a href="#1-什么是迭代器" class="headerlink" title="1. 什么是迭代器"></a>1. 什么是迭代器</h2><p>迭代是python中访问集合元素的一种非常强大的一种方式。迭代器是一个可以记住遍历位置的对象，因此不会像列表那样一次性全部生成，而是可以等到用的时候才生成，因此节省了大量的内存资源。迭代器对象从集合中的第一个元素开始访问，直到所有的元素被访问完。迭代器有两个方法：iter（）和next（）方法。</p><h2 id="2-可迭代的对象"><a href="#2-可迭代的对象" class="headerlink" title="2. 可迭代的对象"></a>2. 可迭代的对象</h2><p>类似于list、tuple、str 等类型的数据可以使用for …… in…… 的循环遍历语法从其中依次拿到数据并进行使用，我们把这个过程称为遍历，也称迭代。python中可迭代的对象有list（列表）、tuple（元组）、dirt（字典）、str（字符串）set等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">mydirt = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">mytuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">myset = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mytuple:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myset:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> mydirt.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> % (i,j))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，也可以创建一个可迭代的对象：只要此对象含有__iter__方法，那么它就是一个可迭代的对象，如下面的例子：其中定义了一个__iter__方法，我们通过isinstance（）函数以及Iterable来判断由Classmate类创建的class1对象是否是可迭代的对象：若class1是一个Iterable（可迭代对象）则结果返回为True；否则，结果为False。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个同学类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="built_in">list</span>()</span><br><span class="line">        self.name_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">class1 =  Classmate()</span><br><span class="line">class1.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是可迭代的对象：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterable))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/PythonPython%E8%BF%AD%E4%BB%A3%E5%99%A8/20200331134840863.png"></p><h2 id="3-创建一个迭代器"><a href="#3-创建一个迭代器" class="headerlink" title="3. 创建一个迭代器"></a>3. 创建一个迭代器</h2><ul><li>一个类（对象）只要含有“__iter__”、”<strong>next</strong>“两个方法，就将其称为迭代器。__iter__方法返回一个特殊的迭代器对象，而这个迭代器对象自动实现了_next__方法，并返回一个值，最后通过抛出异常StopIteration来结束迭代。我们来给上一个例子增加__next__方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个同学类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="built_in">list</span>()</span><br><span class="line">        self.name_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class1 =  Classmate()</span><br><span class="line">class1.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是可迭代的对象：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterable))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是迭代器：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterator))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是通过isinstance（）函数来判断，如果class1是一个迭代器（Iterator），则结果返回True；否则返回False。运行结果如下：<br><img src="/img/PythonPython%E8%BF%AD%E4%BB%A3%E5%99%A8/20200331142605969.png"></p><ul><li>只是名义上的 可迭代对象&#x2F;迭代器 还不够，具有相应的功能才算是完整。首先，对于__iter__方法，它需要具有一个可以返回一个迭代器对象的功能（这个对象可以是自己(前提是本身就是一个迭代器），也可以是其它迭代器）；对于__next__方法，它需要标记并返回下一个迭代器对象。代码如下（为防止迭代速度过快，我们添加sleep来控制速度）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个同学类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="built_in">list</span>()</span><br><span class="line">        self.name_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self   <span class="comment"># 返回本身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">       </span><br><span class="line">       <span class="comment"># 记忆性返回数据</span></span><br><span class="line">       <span class="keyword">if</span> self.name_num &lt; <span class="built_in">len</span>(self.name):</span><br><span class="line">           ret = self.name[self.name_num]</span><br><span class="line">           self.name_num += <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class1 =  Classmate()</span><br><span class="line">class1.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是可迭代的对象：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterable))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是迭代器：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterator))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> class1:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/PythonPython%E8%BF%AD%E4%BB%A3%E5%99%A8/20200331144250447.png"><br>可以发现，当需要读取的内容读取完之后不会停止，而是无限循环的继续返回空值。因此我们可以为其添加抛出异常（StopIteration，python中用于标标识迭代完成，防止出现无限循环的情况）的程序，当需要的数据读取完成时就抛出异常，从而结束：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个同学类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="built_in">list</span>()</span><br><span class="line">        self.name_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self   <span class="comment"># 返回本身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">if</span> self.name_num &lt; <span class="built_in">len</span>(self.name):</span><br><span class="line">           ret = self.name[self.name_num]</span><br><span class="line">           self.name_num += <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 抛出异常，当循环后自动结束</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class1 =  Classmate()</span><br><span class="line">class1.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">class1.add(<span class="string">&quot;王五&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是可迭代的对象：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterable))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;判断是否是迭代器：&quot;</span>, <span class="built_in">isinstance</span>(class1,Iterator))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> class1:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/PythonPython%E8%BF%AD%E4%BB%A3%E5%99%A8/20200331145016234.png"></p><h2 id="4-迭代器的应用"><a href="#4-迭代器的应用" class="headerlink" title="4. 迭代器的应用"></a>4. 迭代器的应用</h2><p>迭代器最核心的功能就是可以通过__next__方法的调用来返回下一个值。而这个值不是从已有的数据中读取的，而是通过程序按照一定的规则生成的。这也就意味着我们可以不再依赖一个现存的数据集合来存放数据，而是边用边生成，这样的好处就是可以节省大量的内存空间。我们通过对比以下问题的两个解决方法，来进一步的理解其应用优势。</p><p>问题：试编写一个程序实现斐波那契数列（0,1,1,2,3,5,8,13,21……后一项总是等于前两项的和）：</p><h3 id="4-1方法一"><a href="#4-1方法一" class="headerlink" title="4.1方法一"></a>4.1方法一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">myFibonacci = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">nums = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入需要生成Fibonacci数列项的个数：&quot;</span>))</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; nums:</span><br><span class="line">    myFabonacci.append(a)</span><br><span class="line">    a,b = b,a+b</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h3 id="4-2-方法二"><a href="#4-2-方法二" class="headerlink" title="4.2 方法二"></a>4.2 方法二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;斐波那契数列得迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,nums</span>):</span><br><span class="line">        self.nums = nums   <span class="comment"># 传入参数，生成斐波那契数列的个数</span></span><br><span class="line">        self.a = <span class="number">0</span>   </span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.i =<span class="number">0</span>    <span class="comment"># 用于记忆生成的个数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">           </span><br><span class="line">       ret = self.a   <span class="comment"># 记忆第一个数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> self.i &lt; self.nums:</span><br><span class="line">            self.a, self.b = self.b,self.a +self.b</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">raise</span> StopIteration   <span class="comment"># 停止迭代</span></span><br><span class="line"></span><br><span class="line">nums = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入需要生成Fibonacci数列项的个数：&quot;</span>))</span><br><span class="line">fobo = Fibonacci(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> fobo:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h3 id="4-3-结果"><a href="#4-3-结果" class="headerlink" title="4.3 结果"></a>4.3 结果</h3><p>如我们需要生成10个Fibonacci数列的项，两者的运行结果相同，如下：<br><img src="/img/PythonPython%E8%BF%AD%E4%BB%A3%E5%99%A8/20200331151435699.png"><br>虽然结果相同，但实际效果却相差巨大。来看一下方法一，他是通过while循环立即生成一个列表用来存放数据，接着再从已有的数据中读取所需数据，而这需要占用一定的内存空间；再来看一下方法二，它并没有用到列表，而是返回一个迭代器，在需要的时候生成相关数据。纵观以上两种方法，在生成个数较小时，两者相差不大，但当生成个数是10万，100万，1000万呢？前者需要消耗大量的内存资源，而后者仅需占用一点内存即可。这也是python2中range（）函数和python3中range（）函数的不同点，python3的range（）函数采用了迭代器的方式，不再依赖于现有的数据集合，也就相当于python2中的xrange()函数。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><ol><li>可迭代对象不一定是迭代器。</li><li>迭代器一定是可迭代对象。</li><li>容器类型（list tuple dict str set ）是可迭代对象但不是迭代器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库设计</title>
      <link href="/article/7647f2b.html"/>
      <url>/article/7647f2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1. 数据库设计概述"></a>1. 数据库设计概述</h1><p>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库<code>逻辑模式</code>和<code>物理结构</code>，并据此建立数据库及其应用系统，使之能够<code>有效的存储和管理数据</code>，满足各种用于需求，包括<code>信息管理要求</code>和<code>数据操作要求</code>。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523142018184.png" alt="在这里插入图片描述"></p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><p><strong>需求分析的主要作用是了解与分析用户需求(包括数据与处理)，然后再此基础上确定新系统的功能</strong>。分析方法常用SA(Structured  Analysis) 结构化分析方法，SA方法从最上层的系统组织结构入手，采用自顶向下，逐层分解的方式分析系统。</p><ul><li>充分了解系统的工作概况，保留扩充和改变的方法。</li><li>详细调查要开发应用系统的组织&#x2F;部门&#x2F;企业等。</li><li>充分明确用户的各种需求。</li></ul><p>调查的重点主要是<code>数据</code>和<code>处理</code>：</p><ul><li>用户需要获得哪些信息，内容与性质是什么</li><li>需要导出哪些数据，即数据库需要存储哪些数据</li><li>用户需要怎样处理数据，即处理数据的功能、方式、 周期等</li><li>安全性和完整性</li></ul><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523144000312.png" alt="在这里插入图片描述"></p><h2 id="2-1-数据字典"><a href="#2-1-数据字典" class="headerlink" title="2.1 数据字典"></a>2.1 数据字典</h2><p>数据字典是关于数据库中<code>数据的描述</code>，而不是数据本身，称为<strong>元数据</strong>。</p><h2 id="2-2-数据字典的内容"><a href="#2-2-数据字典的内容" class="headerlink" title="2.2 数据字典的内容"></a>2.2 数据字典的内容</h2><h3 id="2-2-1-数据项"><a href="#2-2-1-数据项" class="headerlink" title="2.2.1 数据项"></a>2.2.1 数据项</h3><p>数据项是数据的最小组成单位不可再分割，若干个数据项可以组成一个数据结构，通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据项描述 = &#123;数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系（完整性）,数据项之间的联系（数据依赖）&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据项描述=&#123;</span><br><span class="line">    数据项名：学号</span><br><span class="line">    含义说明：唯一的学生标识</span><br><span class="line">    别名:学生编号</span><br><span class="line">    数据类型：字符型</span><br><span class="line">    长度：9</span><br><span class="line">    取值范围：0000 00 000~9999 99 999</span><br><span class="line">    取值含义：前4位为学生入学年份，5~6位为学生所在专业编号，后三位安顺序编号</span><br><span class="line">    与其他数据项的逻辑关系：学号确定了其他数据项的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-数据结构"><a href="#2-2-2-数据结构" class="headerlink" title="2.2.2 数据结构"></a>2.2.2 数据结构</h3><p>数据结构反应了<code>数据之间的组合关系</code>。一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成（套娃？），或混合组成。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构描述=&#123;数据结构名，含义说明，组成：&#123;数据项或数据结构&#125;&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构描述=&#123;</span><br><span class="line">数据结构名：学生</span><br><span class="line">含义说明：学籍学籍管理子系统的主体数据结构，学生的相关信息</span><br><span class="line">组成：学号，姓名，性别，年龄，所在系，年级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-数据流"><a href="#2-2-3-数据流" class="headerlink" title="2.2.3 数据流"></a>2.2.3 数据流</h3><p>数据流是<strong>数据结构</strong>在系统<strong>内部</strong>传输的路径。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据流描述 = &#123;数据流名，说明，数据流来源，数据流去向，组成：&#123;数据结构&#125;，平均流量，高峰期流量&#125;</span><br><span class="line">注：</span><br><span class="line">    - 来源：来自哪个处理过程或数据存储</span><br><span class="line">    - 去向：去往哪个处理过程或数据存储</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据流描述  =&#123;</span><br><span class="line">    数据流名： 体检结果</span><br><span class="line">    说明：学生参加体检的最终报告</span><br><span class="line">    来源：体检（处理过程）</span><br><span class="line">    去向：审批（处理过程）</span><br><span class="line">    组成：学号，&#123;血常规&#125;，&#123;心电图&#125;，年龄等等</span><br><span class="line">    平均流量：200/天</span><br><span class="line">高峰流量：400/天</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-数据存储"><a href="#2-2-4-数据存储" class="headerlink" title="2.2.4 数据存储"></a>2.2.4 数据存储</h3><p>数据存储是数据结构<code>停留</code>或<code>保存</code>的地方，也是数据流的<code>来源和去向</code>之一。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据存储描述 = &#123;数据存储名，说明，编号，输入的数据流，输出的数据流，组成：&#123;数据结构&#125;，数据量，存取频度，存取方式&#125;</span><br><span class="line">注：</span><br><span class="line">- 存取方法：批处理/联机处理；检索/更新；</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据存取描述 = &#123;</span><br><span class="line">数据存储名：学生登记表</span><br><span class="line">说明：记录学生的基本情况</span><br><span class="line">输入的数据流：5000/学期</span><br><span class="line">输出的数据流：5000/学期</span><br><span class="line">组成：&#123;学号，姓名，性别，年龄，所在系，年级，&#123;学习成绩&#125;，&#123;体检报告&#125;&#125;</span><br><span class="line">数据量：10000张/年</span><br><span class="line">存取方式：随机存取、顺序存取</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-处理过程"><a href="#2-2-5-处理过程" class="headerlink" title="2.2.5 处理过程"></a>2.2.5 处理过程</h3><p>具体处理逻辑一般使用判定表或判定 树来描述。数据字典中只需要描述处理过程中的<code>说明性信息</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理过程描述 = &#123;处理过程名，说明，输入：&#123;数据流&#125;，输出：&#123;数据流&#125;处理：&#123;简要说明功能和处理要求&#125;&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理过程描述 = &#123;</span><br><span class="line">处理过程名： 分配宿舍</span><br><span class="line">说明：为学生分配宿舍</span><br><span class="line">输入：学生，宿舍</span><br><span class="line">输出：宿舍安排</span><br><span class="line">处理：在新生报道后为新生安排宿舍，同一宿舍只能安排同一年级的学生……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-概念结构设计"><a href="#3-概念结构设计" class="headerlink" title="3. 概念结构设计"></a>3. 概念结构设计</h1><p>概念结构设计的主要任务就是将需求分析得到的用<strong>户需求抽象为概念模型</strong>。概念模型是现实世界的一个<strong>真实</strong>模型，是现实世界到机器世界的过度桥梁，是各种数据模型的基础。</p><ul><li><p>实体：客观存在并可相互识别的物体称为实体，可以是具体的人、事、物或抽象的概念。</p></li><li><p>属性：实体所具有的某一特性。</p></li><li><p>码：唯一标识实体的属性称为码。</p></li><li><p>实体型：即实体和其属性的结合。</p></li><li><p>实体集：同一类型的实体的集合。</p></li><li><p>联系：现实世界中事物内部和事物之间的联系</p><ul><li><p>实体内部的联系：该实体内部各属性之间的联系，</p></li><li><p>实体（集）之间的联系：不同实体集之间的联系，</p></li><li><p>实体之间的联系有 一对一（1:1）、一对多（1:n），多对多（n:m）三种联系。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523164824899.png" alt="在这里插入图片描述"></p></li></ul></li></ul><h2 id="3-1-E-R图和E-R模型"><a href="#3-1-E-R图和E-R模型" class="headerlink" title="3.1 E-R图和E-R模型"></a>3.1 E-R图和E-R模型</h2><p>E-R图，实现-联系方法，是一种描述现实世界的概念模型。他提供了表示实体型、属性和联系的方法。</p><h3 id="3-1-1-一对一联系"><a href="#3-1-1-一对一联系" class="headerlink" title="3.1.1 一对一联系"></a>3.1.1 一对一联系</h3><p>对于实体集A中的每一个实体，在实体集B中至多有一个实体与之有联系；反之亦然。则称为实体集A和实体集B具有1:1的联系。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个班的班长(1)和班级(1)</span><br></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523170606156.png" alt="在这里插入图片描述"></p><h3 id="3-1-2-一对多联系"><a href="#3-1-2-一对多联系" class="headerlink" title="3.1.2 一对多联系"></a>3.1.2 一对多联系</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个班的班长(1)和班级中的学生(n)</span><br></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523171323313.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-多对多联系"><a href="#3-1-3-多对多联系" class="headerlink" title="3.1.3 多对多联系"></a>3.1.3 多对多联系</h3><p>对于实体集A中的每一个实体，在实体集B中有n个实体(n&gt;&#x3D;0)与之有联系，反之亦然。则称为实体集A和实体集B具有m:n的联系。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">课程（n）和学生（m）间的联系</span><br></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523171715564.png" alt="在这里插入图片描述"></p><h3 id="3-3-4-其它"><a href="#3-3-4-其它" class="headerlink" title="3.3.4 其它"></a>3.3.4 其它</h3><ul><li>两个以上的实体型之间的联系也存在一对一、一对多、多对多的联系。</li></ul><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523182505309.png" alt="在这里插入图片描述"></p><ul><li>单个实体型内也存在此类联系。</li></ul><h2 id="3-2-E-R图表示方法"><a href="#3-2-E-R图表示方法" class="headerlink" title="3.2 E-R图表示方法"></a>3.2 E-R图表示方法</h2><ul><li><p>实体型：矩形表示，框内注明实体名</p></li><li><p>属性：椭圆表示,框内注明属性，并用无向边将其与实体型连接起来</p><p>​<img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523183645481.png" alt="在这里插入图片描述"></p></li><li><p>联系：菱形表示，框内注明联系名，并用无向边与有关实体型联系起来，同时注明联系的类型（1:1&#x2F;1:n&#x2F;n:m）。联系可以具有属性。</p><p>​<img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523183953263.png" alt="在这里插入图片描述"></p></li></ul><h2 id="3-3-例题"><a href="#3-3-例题" class="headerlink" title="3.3 例题"></a>3.3 例题</h2><h3 id="3-3-1-例一"><a href="#3-3-1-例一" class="headerlink" title="3.3.1 例一"></a>3.3.1 例一</h3><p>题目：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523184727936.png" alt="在这里插入图片描述"></p><p>解答：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190611458.png" alt="在这里插入图片描述"></p><h3 id="3-3-2-例二"><a href="#3-3-2-例二" class="headerlink" title="3.3.2 例二"></a>3.3.2 例二</h3><p>题目：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190643263.png" alt="在这里插入图片描述"></p><p>解答：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190714798.png" alt="在这里插入图片描述"></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190747542.png" alt="在这里插入图片描述"></p><h3 id="3-3-3-例三"><a href="#3-3-3-例三" class="headerlink" title="3.3.3 例三"></a>3.3.3 例三</h3><p>题目：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190850351.png" alt="在这里插入图片描述"></p><p>解答：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190930653.png" alt="在这里插入图片描述"></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210523190518480.png" alt="在这里插入图片描述"></p><h2 id="3-4-概念结构设计"><a href="#3-4-概念结构设计" class="headerlink" title="3.4 概念结构设计"></a>3.4 概念结构设计</h2><h3 id="3-4-1-实体与属性的划分"><a href="#3-4-1-实体与属性的划分" class="headerlink" title="3.4.1 实体与属性的划分"></a>3.4.1 实体与属性的划分</h3><ol><li>现实世界的事物能够作为属性对待的，<code>尽量作为属性</code>对待。</li><li>属性必须是<code>不可分割</code>的数据项，不能包含其他属性。</li><li>属性<code>不</code>能够与其他实体具有联系。</li></ol><h3 id="3-4-2-E-R图的集成"><a href="#3-4-2-E-R图的集成" class="headerlink" title="3.4.2 E-R图的集成"></a>3.4.2 E-R图的集成</h3><p>首先设计各个子系统的分E-R图，然后将它们集成起来，消除冲突，得到全局E-R图。</p><h2 id="3-5-注意！"><a href="#3-5-注意！" class="headerlink" title="3.5 注意！"></a>3.5 注意！</h2><p>联系！&#x3D; 实体型</p><p>管理员！&#x3D; 实体型</p><h1 id="4-逻辑结构设计"><a href="#4-逻辑结构设计" class="headerlink" title="4. 逻辑结构设计"></a>4. 逻辑结构设计</h1><p>逻辑结构设计的主要任务就是将基本E-R图转换为关系模式。</p><h2 id="4-1-E-R图向关系模型的转换"><a href="#4-1-E-R图向关系模型的转换" class="headerlink" title="4.1 E-R图向关系模型的转换"></a>4.1 E-R图向关系模型的转换</h2><h3 id="4-1-1-转换内容"><a href="#4-1-1-转换内容" class="headerlink" title="4.1.1 转换内容"></a>4.1.1 转换内容</h3><p>将实体型、实体的属性和实体型之间的联系转化为关系模式。</p><h3 id="4-1-2-转换原则"><a href="#4-1-2-转换原则" class="headerlink" title="4.1.2 转换原则"></a>4.1.2 转换原则</h3><ol><li><p>实体型的转换：一个实体型转换为一个关系模式</p><ul><li>关系模式的属性就是实体的属性</li><li>关系模式的码就是实体属性的码</li></ul><p>如学生实体的ER图如下：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210528165713407.png" alt="在这里插入图片描述"></p><p>则关系模式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学生(学号，姓名，出生日期，所在系，年级，平均成绩)</span><br></pre></td></tr></table></figure></li><li><p>实体型1:1联系：与任意一端对应的关系模式合并</p><ul><li>与某一端的关系模式合并，则在合并的一端加上被合并一端关系模式的码和联系的属性</li><li>合并后关系的码不变</li></ul><p>如班级和教师的E-R图如下：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2021052817321382.png" alt="在这里插入图片描述"></p><p>则关系模式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">教师（教师号，姓名，职称，……）</span><br><span class="line">班级（班级号，班级名，学生人数）</span><br><span class="line"></span><br><span class="line">关系模式合并：</span><br><span class="line">（班级号，班级名，学生人数，教师号，管理时限）</span><br></pre></td></tr></table></figure></li><li><p>实体型1：n联系：将1端的码以及联系的属性并入n端</p><ul><li>合并后关系模式的码不变</li><li>合并后关系模式的属性&#x3D; n端的关系模式属性+1端的码+联系的属性</li></ul><p>如班级和学生的E-R图如下：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210528174726889.png" alt="在这里插入图片描述"></p><p>则关系模式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">班级（班级号，班级名，学生人数）</span><br><span class="line">学生(学号，姓名，出生日期，所在系，年级，平均成绩)</span><br><span class="line"></span><br><span class="line">合并后的关系模式为：</span><br><span class="line">学生(学号，姓名，出生日期，所在系，年级，平均成绩，班级号，入班时间)</span><br></pre></td></tr></table></figure></li><li><p>实体型n:m联系：与该联系相连的实体的码和联系的属性构成一个新的关系模式</p><ul><li>属性 &#x3D; 实体的码+联系的属性</li><li>码 &#x3D; 各实体的码的组合</li></ul><p>如课程和教师的E-R图如下：</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/20210528175855710.png" alt="在这里插入图片描述"></p><p>则关系模式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">教师（教师号，姓名，职称，……）</span><br><span class="line">课程（客户号，课程名，学分）</span><br><span class="line"></span><br><span class="line">合并后的关系模式为：</span><br><span class="line">(课程号，教师号，教科书)</span><br></pre></td></tr></table></figure></li><li><p>具有相同码的关系模式可合并</p><ul><li>将其中一个关系模式中的全部属性加到另外一个关系模式中</li><li>去掉同义的属性</li><li>调整属性的次序</li></ul></li></ol><h2 id="4-2-数据模型的优化"><a href="#4-2-数据模型的优化" class="headerlink" title="4.2 数据模型的优化"></a>4.2 数据模型的优化</h2><ol><li>确定数据依赖</li><li>并不是规范化程度越高就越优化</li></ol><h2 id="4-3-设计用户子模式"><a href="#4-3-设计用户子模式" class="headerlink" title="4.3 设计用户子模式"></a>4.3 设计用户子模式</h2><p>通过视图机制来定义子模式，提高用户的体验。</p><ul><li>使用更符合用户习惯的别名</li><li>对不同级别的用户定义不同的视图，以保证系统的安全性。</li><li>简化用户对系统的使用</li></ul><h1 id="5-物理结构设计"><a href="#5-物理结构设计" class="headerlink" title="5. 物理结构设计"></a>5. 物理结构设计</h1><p>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。关系数据库的物理结构设计的主要内容包括：</p><ul><li>为关系模式选择存取方法（建立存取路径）</li><li>为关系、索引、日志、备份等数据文件选择物理存储结构</li></ul><blockquote><p>本文笔记基于王珊老师的《数据库系统概论》(第五版)整理而成,如有侵权，请联系作者删除！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL|SQL数据定义</title>
      <link href="/article/749ae3a4.html"/>
      <url>/article/749ae3a4.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-模式-schema"><a href="#1-模式-schema" class="headerlink" title="1.模式(schema)"></a>1.模式(schema)</h1><p>模式就相当于一个空间，定义一个模式，就相当于开辟了一个空间，在这个空间中可以定义表、视图、索引等等。</p><h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1  创建"></a>1.1  创建</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">authorization</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模式名默认&#x3D;&#x3D;用户名</li></ul><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>为用户wang定义一个学生-课程模式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="string">&#x27;S-T&#x27;</span> <span class="keyword">authorization</span> wang;</span><br></pre></td></tr></table></figure></li><li><p>在学生-课程模式中创建一个表sc：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S_T.sc(</span><br><span class="line">Sno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    Cno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    Grade <span class="type">float</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(Sno,Cno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-删除"><a href="#1-2-删除" class="headerlink" title="1.2 删除"></a>1.2 删除</h2><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>cascade<span class="operator">|</span>restrict<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>cascade : 级联，删除该模式的同时，将该模式下的所有数据库删除</li><li>restrict ：限制，若该模式下存在内容(表、视图等)，则拒绝删除</li></ul><h3 id="2-例题-1"><a href="#2-例题-1" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>以级联方式删除S-T模式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema S<span class="operator">-</span>T cascade</span><br></pre></td></tr></table></figure></li><li><p>限制条件下尝试删除S-T模式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema S<span class="operator">-</span>T restrict</span><br></pre></td></tr></table></figure><blockquote><p>拒绝删除，因为存在sc表</p></blockquote></li></ol><h2 id="1-3-修改"><a href="#1-3-修改" class="headerlink" title="1.3 修改"></a>1.3 修改</h2><p>SQL标准中不提供修改模式的语句，若要修改模式，只能重建。</p><h1 id="2-基本表-table"><a href="#2-基本表-table" class="headerlink" title="2. 基本表(table)"></a>2. 基本表(table)</h1><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1 创建"></a>2.1 创建</h2><h3 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>（</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]，</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]，</span><br><span class="line">……，</span><br><span class="line">[表级完整性约束条件]</span><br><span class="line">）</span><br></pre></td></tr></table></figure><h3 id="2-例题-2"><a href="#2-例题-2" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>创建一个student表,要求Sno为主码:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    Sno <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    Sname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    Ssex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">    Sage <span class="type">smallint</span>,</span><br><span class="line">    Sdept <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>创建一个course表,要求cno作为主码， Cpno作为本表的外码，被参照表是当前表，被参照列是cno。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    Cno <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    Cname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    Cpno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    Ccredit <span class="type">smallint</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key(Cpno) <span class="keyword">references</span> course(Cno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>参照表和被参照表可以是同一个表</p></blockquote></li><li><p>创建一个sc表，sno和cno是主码，参照表示student和course表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sc(</span><br><span class="line">    Sno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    Cno <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">    Grade <span class="type">float</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(Sno,Cno),</span><br><span class="line">    <span class="keyword">foreign</span> key(Sno) <span class="keyword">references</span> student(Sno),</span><br><span class="line">    <span class="keyword">foreign</span> key (Cno) <span class="keyword">references</span> course(Cno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-删除"><a href="#2-2-删除" class="headerlink" title="2.2 删除"></a>2.2 删除</h2><h3 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure><ul><li>cascade : 级联删除，删除该表的同时，其相关的依赖项都会被删除。</li><li>restrict ：(默认) 若该表存在依赖项，则拒绝删除。</li></ul><h3 id="2-例题-3"><a href="#2-例题-3" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>删除student表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息 3726，级别 16，状态 1，第 56 行</span><br><span class="line">Could not drop object &#x27;student&#x27; because it is referenced by a FOREIGN KEY constraint.</span><br><span class="line">（不能够删除表student，因为存在外键约束引用）</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-修改"><a href="#2-3-修改" class="headerlink" title="2.3 修改"></a>2.3 修改</h2><h3 id="1-语法-4"><a href="#1-语法-4" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">add</span> [<span class="keyword">column</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加表级完整性约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">add</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">drop</span> [<span class="keyword">column</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除完整性约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>完整性约束<span class="operator">&gt;</span> [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新列的数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-例题-4"><a href="#2-例题-4" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>为student表添加入学时间（Sentrance）列，数据类型为int类型。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">add</span> Sentrance <span class="type">int</span></span><br></pre></td></tr></table></figure></li><li><p>为student表修改入学时间的类型为float</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> Sentrance <span class="type">float</span></span><br></pre></td></tr></table></figure></li><li><p>删除student表的入学时间列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> Sentrance</span><br></pre></td></tr></table></figure></li></ol><h1 id="3-视图-view"><a href="#3-视图-view" class="headerlink" title="3. 视图(view)"></a>3. 视图(view)</h1><h2 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>[列名，列名，……]</span><br><span class="line"><span class="keyword">as</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure><h2 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-索引-index"><a href="#4-索引-index" class="headerlink" title="4. 索引(index)"></a>4. 索引(index)</h1><h2 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1 创建"></a>4.1 创建</h2><h3 id="1-语法-5"><a href="#1-语法-5" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][cluster] index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>（<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[次序]，<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[次序]……）</span><br></pre></td></tr></table></figure><h3 id="2-例题-5"><a href="#2-例题-5" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>为student表建立索引。student表按学号升序建立唯一的索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index stusno </span><br><span class="line"><span class="keyword">on</span> student(sno)</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-2-删除"><a href="#4-2-删除" class="headerlink" title="4.2 删除"></a>4.2 删除</h2><h3 id="1-语法-6"><a href="#1-语法-6" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-例题-6"><a href="#2-例题-6" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>删除student表的索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index stusno</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-3-修改索引"><a href="#4-3-修改索引" class="headerlink" title="4.3 修改索引"></a>4.3 修改索引</h2><h3 id="1-语法-7"><a href="#1-语法-7" class="headerlink" title="1. 语法"></a>1. 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> index <span class="operator">&lt;</span>旧索引名<span class="operator">&gt;</span>rename <span class="keyword">to</span> <span class="operator">&lt;</span>新索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-例题-7"><a href="#2-例题-7" class="headerlink" title="2. 例题"></a>2. 例题</h3><ol><li><p>修改student表的索引名为new_sno</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> index stusno rename <span class="keyword">as</span> new_sno</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker一篇文章带你了解Docker.md</title>
      <link href="/article/2ad3e4a9.html"/>
      <url>/article/2ad3e4a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Docker 是一个基于<strong>GO语言</strong>实现的一个开源的应用<strong>容器</strong>引擎。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现<strong>虚拟化</strong>。Docker是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。</p><ul><li>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></li><li>docker官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></li><li>docker官方仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></li></ul><p>Docker和VM一样，同为虚拟化技术，但docker十分轻巧，它占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。这也是docker火的原因之一。</p><blockquote><p><strong>Docker与VM的区别：</strong></p><ul><li>VM模拟的是完整的系统，需要虚拟出一套支撑系统运行的完整硬件，启动缓慢，占用内存非常大。</li><li>Docker模拟的不是完整的系统，<strong>容器内的应用直接运行在宿主机的内核之上</strong>且每个容器都是互相隔离的，每个容器都有自己的文件系统。启动时间为秒级，占用内存为MB级，可以充分发挥服务器的性能。</li></ul></blockquote><img src="/img/Docker一篇文章带你了解Docker/eb0487589139ee49f80f8ab0f5e0b1ad.png" alt="image-20210207183042750" style="zoom:50%;" /><h2 id="2-组成"><a href="#2-组成" class="headerlink" title="2. 组成"></a>2. 组成</h2><p>Docker三要素为容器（container）、镜像（image）、仓库（registry）。</p><ul><li><p>Images：是一个<strong>只读</strong>的模板，<strong>相当于类</strong>，通过镜像可以创建多个容器。就好比使用类创建多个对象。可以简单理解为 镜像—&gt;类，容器—&gt;对象</p></li><li><p>Container ：由镜像所创建，<strong>相当于一个对象</strong>，服务或项目就是运行在容器之中的， 是一个独立的文件系统，是镜像运行时的实体。</p></li><li><p>Repository：存放镜像的位置。官方的仓库为docker hub，国内也有较多的仓库，如阿里云。</p><blockquote><p><strong>官方镜像地址：</strong><a href="https://hub.docker.com/%EF%BC%8C%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E4%B8%AD%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E5%90%AB%E6%9C%89%E8%AF%A5%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%8E%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E3%80%82">https://hub.docker.com/，官方镜像中一般都会含有该镜像的下载及其创建容器的方式，可以在官方镜像中进行查看，然后从国内镜像仓库中拉取镜像。</a></p></blockquote></li></ul><p>三者的关系如下：</p><img src="/img/Docker一篇文章带你了解Docker/6944652b2b65ea5ce7071370f6f3a68e.png" alt="image-20210207161213352" style="zoom:80%;" /><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><p>docker是一个CS(client-server)结构的系统，用户通过客户端来操作后台的守护进程，从而操作主机上的Docker-cerver。</p><img src="/img/Docker一篇文章带你了解Docker/1108d36ad5dbcd439fe4cf618beea334.png" alt="image-20210207182636557" style="zoom:80%;" /><h2 id="4-联合文件系统"><a href="#4-联合文件系统" class="headerlink" title="4. 联合文件系统"></a>4. 联合文件系统</h2><p>Docker联合文件系统（Union File System），它是实现Docker镜像的技术基础，是一种轻量级的高性能分层文件系统，支持将文件系统中的修改进行提交和层层叠加，这个特性使得镜像可以通过分层实现和继承。同时支持将不同目录挂载到同一个虚拟文件系统下。</p><p>在Docker镜像分为基础镜像和父镜像，没有父镜像的镜像被称为基础镜像。用户是基于基础镜像来制作各种不同的应用镜像。这些应用镜像共享同一个基础镜像层，提高了存储效率。</p><p>当用户通过升级程序到新版本，改变了一个Docker镜像时，一个新的镜像层会被创建。因此，用户不用替换整个原镜像或者完全重新建立新镜像，只需要添加新层即可。在用户分发镜像的时，也只需要分发被改动的新层内容(增量部分)。这让Docker的镜像管理变得十分轻松级和快速。典型的案例就是<code>docker commit</code>:每次打包都是在原有的镜像基础上添加一个新的镜像层，可以通过<code>docker inspect</code> 命令查看分层（Layers）。</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><blockquote><p>本文参考Docker官方文档：<a href="https://docs.docker.com/engine/install/%EF%BC%8C%E5%B9%B6%E5%9F%BA%E4%BA%8E%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85%EF%BC%8C%E9%83%A8%E5%88%86%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%98%E6%96%B9%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%BD%86%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E7%9B%B8%E5%90%8C%E3%80%82">https://docs.docker.com/engine/install/，并基于国内阿里云安装，部分安装过程与官方不同，但最终效果相同。</a></p></blockquote><p>Docker提供了以下Linux发行版本的docker安装包。</p><img src="/img/Docker一篇文章带你了解Docker/image-20220101103935721.png" alt="image-20220101103935721" style="zoom:80%;" /><p>其中包括三种类型的发行版本：</p><ul><li>Stable稳定版本，这是经过测试后正式发行的版本，也是最稳定的一个版本。</li><li>Test测试版本，这是正在进行测试的版本，其中包含一些即将在新的稳定版本中增加的功能，稳定性较差。</li><li>Nightly迭代版本，它们每天从 master 分支创建一次，展示最新版本的构建工作。</li></ul><blockquote><ul><li>The <strong>Stable</strong> channel gives you latest releases for general availability.</li><li>The <strong>Test</strong> channel gives pre-releases that are ready for testing before general availability (GA).</li><li>The <strong>Nightly</strong> channel gives you latest builds of work in progress for the next major release.</li></ul></blockquote><h2 id="1-自动安装"><a href="#1-自动安装" class="headerlink" title="1. 自动安装"></a>1. 自动安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h2 id="2-Ubuntu手动安装"><a href="#2-Ubuntu手动安装" class="headerlink" title="2. Ubuntu手动安装"></a>2. Ubuntu手动安装</h2><blockquote><ul><li><p>Ubuntu Impish 21.10</p></li><li><p>Ubuntu Hirsute 21.04</p></li><li><p>Ubuntu Focal 20.04 (LTS)</p></li><li><p>Ubuntu Bionic 18.04 (LTS)</p></li></ul></blockquote><h3 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1. 卸载旧版本"></a>1. 卸载旧版本</h3><p>旧的Docker版本被称为docker、docker.io或者docker-engine。在重新安装之前需要将这些东西卸载,卸载命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove docker docker.io docker-engine containerd runc</span><br></pre></td></tr></table></figure><blockquote><p>docker的相关数据（镜像、容器、数据卷、网络等）默认存放在<code>/var/lib/docker/</code>目录和<code>/var/lib/containerd</code>下，如果有必要可以将该目录删除。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-允许apt通过HTTPS使用存储库"><a href="#2-允许apt通过HTTPS使用存储库" class="headerlink" title="2. 允许apt通过HTTPS使用存储库"></a>2. 允许apt通过HTTPS使用存储库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h3 id="3-添加Docker的阿里云GPG密钥"><a href="#3-添加Docker的阿里云GPG密钥" class="headerlink" title="3. 添加Docker的阿里云GPG密钥"></a>3. 添加Docker的阿里云GPG密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><h3 id="4-设置docker的稳定存储库"><a href="#4-设置docker的稳定存储库" class="headerlink" title="4. 设置docker的稳定存储库"></a>4. 设置docker的稳定存储库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-更新软件源"><a href="#5-更新软件源" class="headerlink" title="5.更新软件源"></a>5.更新软件源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6.安装docker"></a>6.安装docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="7-测试安装是否成功"><a href="#7-测试安装是否成功" class="headerlink" title="7. 测试安装是否成功"></a>7. 测试安装是否成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="3-Centos手动安装"><a href="#3-Centos手动安装" class="headerlink" title="3. Centos手动安装"></a>3. Centos手动安装</h2><h3 id="1-安装必要的一些系统工具"><a href="#1-安装必要的一些系统工具" class="headerlink" title="1. 安装必要的一些系统工具"></a>1. 安装必要的一些系统工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h3 id="2-添加软件源信息"><a href="#2-添加软件源信息" class="headerlink" title="2. 添加软件源信息"></a>2. 添加软件源信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3. 更新"></a>3. 更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><h3 id="4-安装docker"><a href="#4-安装docker" class="headerlink" title="4.安装docker"></a>4.安装docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="5-测试安装是否成功"><a href="#5-测试安装是否成功" class="headerlink" title="5. 测试安装是否成功"></a>5. 测试安装是否成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="4-使用镜像加速器"><a href="#4-使用镜像加速器" class="headerlink" title="4.使用镜像加速器"></a>4.使用镜像加速器</h2><p>由于Docker默认的仓库是使用官方的仓库，而官方仓库是在国外，所以网速非常慢。因此我们使用阿里云的镜像加速器。</p><ul><li>注册或登录阿里云账号</li><li>阿里云docker镜像获取地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a>  ,登录之后在左侧就可以看到镜像加速器，点击，然后根据提示将自己的加速器地址配置到本地即可</li></ul><p>至此，Docker安装完成，一些高级配置见官方文档：<a href="https://docs.docker.com/engine/install/linux-postinstall/">https://docs.docker.com/engine/install/linux-postinstall/</a></p><h2 id="5-后续操作"><a href="#5-后续操作" class="headerlink" title="5. 后续操作"></a>5. 后续操作</h2><h3 id="1-设置自启动"><a href="#1-设置自启动" class="headerlink" title="1. 设置自启动"></a>1. 设置自启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure><h3 id="3-设置当前非root用户可以使用docker"><a href="#3-设置当前非root用户可以使用docker" class="headerlink" title="3. 设置当前非root用户可以使用docker"></a>3. 设置当前非root用户可以使用docker</h3><ul><li><p>添加docker用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></li><li><p>将当前用户添加到用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>重新加载当前用户至新的用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure></li></ul><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h2><h2 id="2-搜索镜像"><a href="#2-搜索镜像" class="headerlink" title="2. 搜索镜像"></a>2. 搜索镜像</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>--filter , -f</code></td><td>根据提供的条件筛选后输出</td></tr><tr><td><code>--format</code></td><td>进行格式化展示</td></tr><tr><td><code>--limit</code></td><td>最大搜索结果，默认25条</td></tr><tr><td><code>--no-trunc</code></td><td>不截断输出</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»» docker search mysql                                                                                                                                            </span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10471     [OK]       </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3894      [OK]       </span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   768                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   526       [OK]       </span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   87                   </span><br><span class="line">mysql/mysql-cluster               Exper</span><br></pre></td></tr></table></figure><h2 id="3-查看本地镜像"><a href="#3-查看本地镜像" class="headerlink" title="3. 查看本地镜像"></a>3. 查看本地镜像</h2><p><strong>命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>--all , -a</code></td><td>显示所有镜像</td></tr><tr><td><code>--digests</code></td><td>显示摘要</td></tr><tr><td><code>--filter , -f</code></td><td>根据提供的条件筛选后输出</td></tr><tr><td><code>--format</code></td><td>进行格式化展示</td></tr><tr><td><code>--no-trunc</code></td><td>不截断输出</td></tr><tr><td><code>--quiet , -q</code></td><td>仅显示镜像ID</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker images                                                                                                                                                             </span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql           latest      c8562eaf9d81      2 weeks ago    546MB</span><br><span class="line">bestwu/qq       office    f429bf9a4ac4    4 weeks ago    902MB</span><br><span class="line">bestwu/wechat   latest   dc95baea4912        4 weeks ago    864MB</span><br><span class="line">centos          7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line">                                                     </span><br></pre></td></tr></table></figure><ul><li>repository: 镜像网站&#x2F;镜像名称</li><li>tag: 镜像版本&#x2F;标签</li><li>image id： 镜像id</li><li>created：镜像源创建时间</li><li>size：镜像大小</li></ul><h2 id="4-下载镜像"><a href="#4-下载镜像" class="headerlink" title="4. 下载镜像"></a>4. 下载镜像</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像：版本号   <span class="comment"># 指定版本号</span></span><br><span class="line">docker pull 镜像                     <span class="comment"># 默认是最新版本</span></span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker pull ubuntu                                                                                                                                                  </span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">da7391352a9b: Pull complete </span><br><span class="line">14428a6d4bcd: Pull complete </span><br><span class="line">2c2d948710f2: Pull complete </span><br><span class="line">Digest: sha256:c95a8e48bf88e9849f3e0f723d9f49fa12c5a00cfc6e60d2bc99d87555295e4c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line">docker.io/library/ubuntu:latest</span><br></pre></td></tr></table></figure><h2 id="5-删除镜像"><a href="#5-删除镜像" class="headerlink" title="5. 删除镜像"></a>5. 删除镜像</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi -f 镜像ID/镜像名称             <span class="comment"># 删除指定镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)   <span class="comment"># 删除全部镜像</span></span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker images                                                                                                                                                           </span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql           latest    c8562eaf9d81   2 weeks ago    546MB</span><br><span class="line">bestwu/qq       office    f429bf9a4ac4   4 weeks ago    902MB</span><br><span class="line">bestwu/wechat   latest    dc95baea4912   4 weeks ago    864MB</span><br><span class="line">ubuntu          latest    f643c72bc252   2 months ago   72.9MB</span><br><span class="line">centos          7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker rmi -f f643c72bc252                                                                                                                                           </span><br><span class="line">Untagged: ubuntu:latest</span><br><span class="line">Untagged: ubuntu@sha256:c95a8e48bf88e9849f3e0f723d9f49fa12c5a00cfc6e60d2bc99d87555295e4c</span><br><span class="line">Deleted: sha256:f643c72bc25212974c16f3348b3a898b1ec1eb13ec1539e10a103e6e217eb2f1</span><br><span class="line">Deleted: sha256:9386795d450ce06c6819c8bc5eff8daa71d47ccb9f9fb8d49fe1ccfb5fb3edbe</span><br><span class="line">Deleted: sha256:3779241fda7b1caf03964626c3503e930f2f19a5ffaba6f4b4ad21fd38df3b6b</span><br><span class="line">Deleted: sha256:bacd3af13903e13a43fe87b6944acd1ff21024132aad6e74b4452d984fb1a99a</span><br></pre></td></tr></table></figure><h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><h2 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h2><h2 id="2-创建容器（重点）"><a href="#2-创建容器（重点）" class="headerlink" title="2.创建容器（重点）"></a>2.创建容器（重点）</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>​<strong>参数</strong></p><blockquote><p>说明：docker run 的参数多达几十种，这里仅介绍常用参数，更多参数介绍请使用 –help 或直达官方docke run 帮助文档：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a> </p></blockquote><table><thead><tr><th>参数</th><th>示例&#x2F;详细</th><th>描述</th></tr></thead><tbody><tr><td>–name</td><td>–name&#x3D;mysql1</td><td>指定容器名称</td></tr><tr><td>- d</td><td></td><td>放置后台运行</td></tr><tr><td>-i</td><td></td><td>交互模式</td></tr><tr><td>-t</td><td>-it</td><td>启动终端，常与-i组合使用</td></tr><tr><td>-p</td><td></td><td>指定端口</td></tr><tr><td></td><td>-p ip:主机端口：容器端口</td><td>端口映射1</td></tr><tr><td></td><td>-p 主机端口：容器端口</td><td>端口映射2</td></tr><tr><td></td><td>-p 容器端口</td><td>指定容器端口</td></tr><tr><td>-P</td><td></td><td>随机指定端口</td></tr><tr><td>-e</td><td></td><td>环境配置</td></tr><tr><td>-v</td><td></td><td>数据卷挂载（后面会讲到）</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个名字为centos_test的centos7的容器，并直接进入后台</span></span><br><span class="line">rabbit•~•»»»docker run -it --name centos_test centos:7 /bin/bash                                                  </span><br><span class="line">[root@6c93d967edd3 /]<span class="comment"># ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><h2 id="3-退出容器"><a href="#3-退出容器" class="headerlink" title="3. 退出容器"></a>3. 退出容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ed09e4490c57:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><h2 id="4-查看容器"><a href="#4-查看容器" class="headerlink" title="4.查看容器"></a>4.查看容器</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>--all , -a</code></td><td></td><td>显示所有的容器</td></tr><tr><td><code>--filter , -f</code></td><td></td><td>根据提供的条件筛选后输出</td></tr><tr><td><code>--format</code></td><td></td><td>进行格式化展示</td></tr><tr><td><code>--last , -n</code></td><td><code>1</code></td><td>显示最后创建的容器（包括所有容器）</td></tr><tr><td><code>--latest , -l</code></td><td></td><td>显示最新创建的容器（包括所有容器）</td></tr><tr><td><code>--no-trunc</code></td><td></td><td>不间断输出</td></tr><tr><td><code>--quiet , -q</code></td><td></td><td>仅显示容器ID</td></tr><tr><td><code>--size , -s</code></td><td></td><td>显示容器大小</td></tr></tbody></table><h2 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5. 删除容器"></a>5. 删除容器</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>--force , -f</code></td><td>强制删除所有容器</td></tr><tr><td><code>--link , -l</code></td><td>删除指定的链接</td></tr><tr><td><code>--volumes , -v</code></td><td>删除与容器关联的匿名卷</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker ps                                                                                               </span><br><span class="line">CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">5dfadbfaf166   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   10 seconds ago   Up 9 seconds              centos3</span><br><span class="line">a40c7e77eecb   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   16 seconds ago   Up 14 seconds             centos2</span><br><span class="line">60a7d3d88b21   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   21 seconds ago   Up 20 seconds             centos1</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker ps -a                                                                                          </span><br><span class="line">CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">5dfadbfaf166   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   18 seconds ago   Up 18 seconds             centos3</span><br><span class="line">a40c7e77eecb   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   24 seconds ago   Up 23 seconds             centos2</span><br><span class="line">60a7d3d88b21   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   29 seconds ago   Up 28 seconds             centos1</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">rm</span> -f centos3                                                                               </span><br><span class="line">centos3</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">rm</span> -f $(docker ps -aq)                                                                   </span><br><span class="line">a40c7e77eecb</span><br><span class="line">60a7d3d88b21</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-进入容器"><a href="#6-进入容器" class="headerlink" title="6.进入容器"></a>6.进入容器</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器ID</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker ps                                                                                                                                                              </span><br><span class="line">CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">64b9f94d1adb   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   37 minutes ago   Up 37 minutes             centos3</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">exec</span> -it 64b9f94d1adb /bin/bash                                                                                                                               </span><br><span class="line">[root@64b9f94d1adb /]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-停止-x2F-启动-x2F-重启容器"><a href="#7-停止-x2F-启动-x2F-重启容器" class="headerlink" title="7. 停止&#x2F;启动&#x2F;重启容器"></a>7. 停止&#x2F;启动&#x2F;重启容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器ID/容器名称           <span class="comment"># 启动</span></span><br><span class="line">docker stop 容器ID/容器名称           <span class="comment"># 停止</span></span><br><span class="line">docker restart 容器ID/容器名称      <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><h2 id="8-查看日志"><a href="#8-查看日志" class="headerlink" title="8. 查看日志"></a>8. 查看日志</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>--details</code></td><td></td><td>显示提供给日志的额外详细信息</td></tr><tr><td><code>--follow , -f</code></td><td></td><td>跟踪日志输出</td></tr><tr><td><code>--since</code></td><td></td><td>显示自时间戳(例如2013-01-02T13:23:37Z)或相对(例如42m, 42分钟)以来的日志</td></tr><tr><td><code>--tail , -n</code></td><td></td><td>从日志的末尾开始显示行数（后需要加上参数）</td></tr><tr><td><code>--timestamps , -t</code></td><td></td><td>显示时间戳</td></tr><tr><td><code>--until</code></td><td></td><td>显示时间戳之前的日志(例如2013-01-02T13:23:37Z)或相对的日志(例如42m for 42 minutes)</td></tr></tbody></table><h2 id="9-查看容器进程"><a href="#9-查看容器进程" class="headerlink" title="9. 查看容器进程"></a>9. 查看容器进程</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker top 64b9f94d1adb                                                                              </span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                7848                7826                0                   13:55               ?                   00:00:00            /bin/bash              </span><br></pre></td></tr></table></figure><h2 id="10-查看镜像的元数据"><a href="#10-查看镜像的元数据" class="headerlink" title="10. 查看镜像的元数据"></a>10. 查看镜像的元数据</h2><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>--format , -f</code></td><td>根据给出的模板格化输出</td></tr><tr><td><code>--size , -s</code></td><td>显示容器大小</td></tr><tr><td><code>--type</code></td><td>返回指定类型的JSON</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker inspect 64b9f94d1adb                                                                                                                                            </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;64b9f94d1adb67e797e8537ad8a1641fbd8953ec2d9629f1a4a336fc46068748&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-02-08T05:55:36.648918967Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 7848,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2021-02-08T05:55:36.994219512Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="11-文件传输"><a href="#11-文件传输" class="headerlink" title="11.文件传输"></a>11.文件传输</h2><p><strong>命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-   # 从容器cp到主机</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH  # 从主机cp到容器</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从主机cp到容器</span></span><br><span class="line">rabbit•~•»»»docker ps                                                                                                                                                            </span><br><span class="line">CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">64b9f94d1adb   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   49 minutes ago   Up 49 minutes             centos3</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">cp</span> 01_hello.sh 64b9f94d1adb:/root/     </span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">exec</span> -it 64b9f94d1adb /bin/bash </span><br><span class="line">[root@64b9f94d1adb /]<span class="comment"># cd /root/</span></span><br><span class="line">[root@64b9f94d1adb ~]<span class="comment"># ls</span></span><br><span class="line">01_hello.sh  anaconda-ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从容器cp到主机</span></span><br><span class="line">[root@64b9f94d1adb ~]<span class="comment"># vi a.txt</span></span><br><span class="line">[root@64b9f94d1adb ~]<span class="comment"># ls</span></span><br><span class="line">01_hello.sh  a.txt  anaconda-ks.cfg</span><br><span class="line">[root@64b9f94d1adb ~]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">rabbit•~•»»»docker <span class="built_in">cp</span> 64b9f94d1adb:/root/a.text .                                                                                                                                 </span><br><span class="line">rabbit•~•»»»<span class="built_in">ls</span>                                                                                                                                                                     </span><br><span class="line"> a.txt    </span><br></pre></td></tr></table></figure><h2 id="12-打包容器"><a href="#12-打包容器" class="headerlink" title="12. 打包容器"></a>12. 打包容器</h2><p><strong>命令</strong></p><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>--author , -a</code></td><td></td><td>作者</td></tr><tr><td><code>--change , -c</code></td><td></td><td>添加Dockerfile用来创建新的镜像</td></tr><tr><td><code>--message , -m</code></td><td></td><td>提交信息</td></tr><tr><td><code>--pause , -p</code></td><td><code>true</code></td><td>在提交过程中暂停容器</td></tr></tbody></table><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbit•~•»»»docker images                                                                                                                                                         </span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql           latest    c8562eaf9d81   2 weeks ago    546MB</span><br><span class="line">tomcat          latest    040bdb29ab37   3 weeks ago    649MB</span><br><span class="line">nginx           latest    f6d0b4767a6c   3 weeks ago    133MB</span><br><span class="line">bestwu/qq       office    f429bf9a4ac4   4 weeks ago    902MB</span><br><span class="line">bestwu/wechat   latest    dc95baea4912   4 weeks ago    864MB</span><br><span class="line">centos          7         8652b9f0cb4c   2 months ago   204MB</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker run -dit --name centos_1 centos:7 /bin/bash</span><br><span class="line">rabbit•~•»»»docker <span class="built_in">exec</span> -it centos_1 /bin/bash   </span><br><span class="line">[root@626b5733e8e1 /]<span class="comment"># ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@626b5733e8e1 /]<span class="comment"># vi testFile.txt</span></span><br><span class="line">[root@626b5733e8e1 /]<span class="comment"># ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  testFile.txt  tmp  usr  var</span><br><span class="line">[root@626b5733e8e1 /]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker ps                                                                                                                                                           </span><br><span class="line">CONTAINER ID   IMAGE      COMMAND       CREATED         STATUS          PORTS     NAMES</span><br><span class="line">626b5733e8e1   centos:7   <span class="string">&quot;/bin/bash&quot;</span>   2 minutes ago   Up 18 seconds             centos_1</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker commit -a <span class="string">&quot;rabbit&quot;</span> -m <span class="string">&quot;commit a new centos:7 images&quot;</span> 626b5733e8e1 centos7:1.0                                                                                     </span><br><span class="line">sha256:e80b6bff4707966ef5bddde23520dba5da9fb488cc26a209dd67050c6bb87b51</span><br><span class="line"></span><br><span class="line">rabbit•~•»»»docker images                                                                                                                                                      </span><br><span class="line">REPOSITORY      TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">centos7         1.0       e80b6bff4707   9 seconds ago   204MB</span><br><span class="line">mysql           latest    c8562eaf9d81   2 weeks ago     546MB</span><br><span class="line">tomcat          latest    040bdb29ab37   3 weeks ago     649MB</span><br><span class="line">nginx           latest    f6d0b4767a6c   3 weeks ago     133MB</span><br><span class="line">bestwu/qq       office    f429bf9a4ac4   4 weeks ago     902MB</span><br><span class="line">bestwu/wechat   latest    dc95baea4912   4 weeks ago     864MB</span><br><span class="line">centos          7         8652b9f0cb4c   2 months ago    204MB</span><br></pre></td></tr></table></figure><h1 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h1><h2 id="1-什么是数据卷"><a href="#1-什么是数据卷" class="headerlink" title="1. 什么是数据卷?"></a>1. 什么是数据卷?</h2><p>实现<strong>数据持久化</strong>，将数据同步到容器外或将宿主机目录挂载到容器内部，容器结束后，数据仍然存在。通过数据挂载，可以实现 容器与主机、容器与容器之间的<strong>数据共享</strong>。</p><img src="/img/Docker一篇文章带你了解Docker/7f04aaebc49c2b10d54d1227cc4c495a.png" alt="image-20210209200955959" style="zoom:80%;" /><h2 id="2-如何使用数据卷？"><a href="#2-如何使用数据卷？" class="headerlink" title="2. 如何使用数据卷？"></a>2. 如何使用数据卷？</h2><h3 id="1-指定挂载路径"><a href="#1-指定挂载路径" class="headerlink" title="1. 指定挂载路径"></a>1. 指定挂载路径</h3><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v 主机文件目录:容器文件目录 image /bin/bash</span><br></pre></td></tr></table></figure><p>在容器运行时使用<code>-v 主机文件目录:容器文件目录</code>参数，实现宿主机指定目录与容器指定目录<strong>双向</strong>绑定。</p><p><strong>Example</strong></p><p>运行一个容器，并将其&#x2F;home与宿主机&#x2F;home&#x2F;rabbit&#x2F;test目录绑定。通过测试可以看出，实现了文件的双向同步。</p><p><img src="/img/Docker%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Docker/81f5758883120dbca85ed724b43d1758-1651807933602.png" alt="image-20210209205625498"></p><p><strong>练习：部署MySQL</strong></p><blockquote><p>见<code>案例-使用数据卷挂载MYSQL</code>。</p></blockquote><h3 id="2-匿名挂载与具名挂载"><a href="#2-匿名挂载与具名挂载" class="headerlink" title="2. 匿名挂载与具名挂载"></a>2. 匿名挂载与具名挂载</h3><p>在挂载数据卷时若不指定宿主机的挂载目录，这该方式称为匿名挂载。匿名挂载的默认路径为<code>/var/lib/docker/volumes</code>目录下的某一文件夹下。该目录名是随机生成的，因此不容易找到对应的容器。这种方式<strong>适用于只需要将文件存放在宿主机上而不需要通过宿主机访问的情况</strong>。</p><p><strong>用法</strong>：在挂载数据卷的时候<strong>仅</strong>指定容器内的文件名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /etc/mysql</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建mysql2， 匿名挂载容器目录 /etc/mysql 和/var/lib/mysql</span></span><br><span class="line">rabbit•/home/mysql/data•»»»docker run -dit --name mysql2 -v /etc/mysql -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306 mysql /bin/bash</span><br><span class="line">f18306ca3a252f59ebc827fcc16fa825cee2a9cc1db98bed8c5b14d03f52cb0f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker volume命令 </span></span><br><span class="line">rabbit•/home/mysql/data•»»»docker volume --<span class="built_in">help</span>                                                                                                                                       </span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line">Manage volumes</span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  <span class="built_in">ls</span>          List volumes</span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes</span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more volumes</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;docker volume COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载的数据卷</span></span><br><span class="line">rabbit•/home/mysql/data•»»»docker volume <span class="built_in">ls</span>                                                                                                                                           </span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     a5018b6327d822d09cc6bc43763af5871c34935e4cae3652da3d14dc762d4577</span><br><span class="line"><span class="built_in">local</span>     ae62c94221da7d9811f8eab5fb7602e71f5409fd4675f6844a31ef6ae1acac81</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载的数据卷的位置</span></span><br><span class="line">rabbit•/home/mysql/data•»»»docker volume inspect a5018b6327d822d09cc6bc43763af5871c34935e4cae3652da3d14dc762d4577                                                                     </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-02-10T10:30:19+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/a5018b6327d822d09cc6bc43763af5871c34935e4cae3652da3d14dc762d4577/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;a5018b6327d822d09cc6bc43763af5871c34935e4cae3652da3d14dc762d4577&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">rabbit•/home/mysql/data•»»»docker volume inspect ae62c94221da7d9811f8eab5fb7602e71f5409fd4675f6844a31ef6ae1acac81                                                                     </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-02-10T10:30:19+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/ae62c94221da7d9811f8eab5fb7602e71f5409fd4675f6844a31ef6ae1acac81/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ae62c94221da7d9811f8eab5fb7602e71f5409fd4675f6844a31ef6ae1acac81&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与匿名挂载类似，在不指定宿主机挂载目录的情况下挂载目录，且给挂载的数据卷<strong>命名一个名称</strong>。这种方式称为<code>具名挂载</code>。当需要查找该数据卷时可在<code>/var/lib/docker/voluems</code>目录下中寻找对应的数据卷名。</p><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v 卷名：容器内路径</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据库mysql3，具名挂载容器目录  etc/mysql 和/var/lib/mysql</span></span><br><span class="line">rabbit•~•»»»docker run -dit --name mysql3 -v jumingguazai1:/etc/mysql -v jumingguazai2:/var/lib/mysql -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql /bin/bash                 </span><br><span class="line">59513c8cec5b78be7d58ffd455b267ffb71b3ecc83080fa79332019562f3d41a</span><br><span class="line"><span class="comment"># 查看数据卷</span></span><br><span class="line">rabbit•~•»»»docker volume <span class="built_in">ls</span>                                                                                                                                                       </span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     jumingguazai2</span><br><span class="line"><span class="built_in">local</span>     jumingguazai1</span><br><span class="line"><span class="comment"># 查看数据卷jumingguazai1的详细信息</span></span><br><span class="line">rabbit•~•»»»docker volume inspect jumingguazai1                                                                                                                                    </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-02-10T10:44:52+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/jumingguazai1/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jumingguazai1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 查看数据卷jumingguazai2的详细信息</span></span><br><span class="line">rabbit•~•»»»docker volume inspect jumingguazai2                                                                                                                                      </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2021-02-10T10:44:52+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/jumingguazai2/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jumingguazai2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="3-权限设置"><a href="#3-权限设置" class="headerlink" title="3. 权限设置"></a>3. 权限设置</h3><p>对容器内的文件权限进行设置，使得挂载的文件能在宿主机中读写。</p><p>命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v 主机文件目录:容器文件目录:权限</span><br></pre></td></tr></table></figure><ul><li>ro: readOnly 容器只读，只能通过宿主机来改变。</li><li>rw: read &amp;&amp;write 可读可写。</li></ul><p>Example：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v juming:/etc/mysql:ro mysql</span><br><span class="line">docker run -v juming:/etc/mysql:rw mysql</span><br></pre></td></tr></table></figure><h1 id="自定义Docker镜像"><a href="#自定义Docker镜像" class="headerlink" title="自定义Docker镜像"></a>自定义Docker镜像</h1><h2 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1. Dockerfile"></a>1. Dockerfile</h2><p>docker通过解释Dockerfile中的指令，可以来构建一个自定义的docker镜像。可以说Dockerfile是的一个<strong>命令参数脚本文件</strong>。docker中每执行一条指令，都会新建一层镜像。</p><img src="/img/Docker一篇文章带你了解Docker/785d712a47b9f61eb137d0858254e249.png" /><h2 id="2-构建Dockerfile"><a href="#2-构建Dockerfile" class="headerlink" title="2. 构建Dockerfile"></a>2. 构建Dockerfile</h2><p>Dockerfile中的指令含义如下：</p><table><thead><tr><th align="left">参数</th><th align="center">描述</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">FROM</td><td align="center">FROM    centos:7</td><td align="left">基础镜像，构建的镜像就是在此镜像基础上形成的</td></tr><tr><td align="left">MAINTAINER</td><td align="center">MAINTAINER    rabbit&lt; <a href="mailto:&#x31;&#50;&#x33;&#52;&#53;&#54;&#x37;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x31;&#50;&#x33;&#52;&#53;&#54;&#x37;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a> &gt;</td><td align="left">镜像作者，一般为： 作者+邮箱</td></tr><tr><td align="left">RUN</td><td align="center"></td><td align="left">编译镜像是运行的脚本指令</td></tr><tr><td align="left">ENV</td><td align="center"></td><td align="left">容器的环境变量</td></tr><tr><td align="left">LABEL</td><td align="center"></td><td align="left">设置镜像的标签</td></tr><tr><td align="left">ONBUILD</td><td align="center"></td><td align="left">构建一个被继承的Dockerfile</td></tr><tr><td align="left">USER</td><td align="center"></td><td align="left">指定 RUN CMD 等指定执行用户</td></tr><tr><td align="left">VOLUME</td><td align="center"></td><td align="left">挂载的数据卷</td></tr><tr><td align="left">WORKDIR</td><td align="center"></td><td align="left">镜像的工作目录</td></tr><tr><td align="left">COPY</td><td align="center">.&#x2F;readme.txt &#x2F;usr&#x2F;localreadme.txt</td><td align="left">编译镜像时复制文件到容器中</td></tr><tr><td align="left">ADD</td><td align="center"></td><td align="left">编译镜像时复制文件到容器中（自动解压）</td></tr><tr><td align="left">EXPOSE</td><td align="center"></td><td align="left">保留端口配置</td></tr><tr><td align="left">CMD</td><td align="center"></td><td align="left">指定容器启动后需要运行的命令（覆盖，仅最后一个有效）</td></tr><tr><td align="left">ENTRYPOINT</td><td align="center"></td><td align="left">指定容器启动后需要运行的命令，不覆盖，可追加）</td></tr></tbody></table><h2 id="3-使用docker-build-运行（重点）"><a href="#3-使用docker-build-运行（重点）" class="headerlink" title="3. 使用docker build 运行（重点）"></a>3. 使用docker build 运行（重点）</h2><p><strong>命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f Dockerfile -t 目标镜像名称：版本号 生成路径 </span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Dockerfile内容</span></span><br><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      rabbit&lt;<span class="number">1234567</span>@qq.com&gt;</span><br><span class="line"><span class="keyword">ENV</span>     MYPATH /home</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">     yum install vim -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">     yum install net-tools -y</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">     <span class="built_in">echo</span> <span class="string">&quot;--------ok------------&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行命令</span></span><br><span class="line">rabbit•~/dockerfile•»»»docker build -f Dockerfile -t mycentos:7.1 .   </span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/8 : FROMcentos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">2d473b07cdd5: Pull complete </span><br><span class="line">Digest: sha256:0f4ec88e21daf75124b8a9e5ca03c37a5e937e0e108a255d890492430789b60e</span><br><span class="line">Status: Downloaded newer image for centos:7</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">8652b9f0cb4c</span></span><br><span class="line">Step 2/8 : MAINTAINERrabbit&lt;1234567@qq.com&gt;</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> a58b05fa8b1b</span></span><br><span class="line">Removing intermediate container a58b05fa8b1b</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">228d96fc7ab7</span></span><br><span class="line">Step 3/8 : ENVMYPATH /home</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 5df54a4392ff</span></span><br><span class="line">Removing intermediate container 5df54a4392ff</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">5b42216713df</span></span><br><span class="line">Step 4/8 : WORKDIR$MYPATH</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> e4989809e670</span></span><br><span class="line">Removing intermediate container e4989809e670</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">ee9f49f726c9</span></span><br><span class="line">Step 5/8 : RUNyum install vim -y</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Successfully built dc8102fdbb65</span><br><span class="line">Successfully tagged mycentos:7.1</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="使用Docker创建SQLServer容器"><a href="#使用Docker创建SQLServer容器" class="headerlink" title="使用Docker创建SQLServer容器"></a>使用Docker创建SQLServer容器</h1><blockquote><p>本教程基于 </p><ul><li>Docker20.10.6</li><li>SQL Server2019</li><li>Docker Desktop（WSL2 Ubuntu18）</li><li>Microsoft SQL Server 文档</li></ul><p>要求：</p><ul><li>Docker引擎1.8以上</li></ul></blockquote><h2 id="1-拉取SQL-Server2019容器镜像"><a href="#1-拉取SQL-Server2019容器镜像" class="headerlink" title="1. 拉取SQL Server2019容器镜像"></a>1. 拉取SQL Server2019容器镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull mcr.microsoft.com/mssql/server:2019-latest</span><br></pre></td></tr></table></figure><p>运行<code>docker images</code>可查看现有镜像。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xc•~•»»docker images                                                                       </span><br><span class="line">REPOSITORY                       TAG           IMAGE ID       CREATED       SIZE</span><br><span class="line">mcr.microsoft.com/mssql/server   2019-latest   62c72d863950   7 weeks ago   1.49GB</span><br></pre></td></tr></table></figure><h2 id="2-运行SQL-Server2019容器映像"><a href="#2-运行SQL-Server2019容器映像" class="headerlink" title="2. 运行SQL Server2019容器映像"></a>2. 运行SQL Server2019容器映像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run --name sqlserver2019\                                               </span><br><span class="line">    -h sqlserver2019\</span><br><span class="line">    -p 1433:1433\</span><br><span class="line">    -e <span class="string">&quot;ACCEPT_EULA=Y&quot;</span>\</span><br><span class="line">    -e <span class="string">&quot;SA_PASSWORD=MYpassword2019&quot;</span>\</span><br><span class="line">    -d mcr.microsoft.com/mssql/server:2019-latest</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>–<strong>name</strong>: 指定容器名称</li><li>-<strong>h</strong>: 指定容器ID</li><li>-<strong>p</strong>:端口映射 （主机端口：容器端口）</li><li>-<strong>e</strong>: SQL Server内部参数<ul><li>-e “ACCEPT_EULA&#x3D;Y”： 将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必需设置。</li><li>-e “SA_PASSWORD&#x3D;MYpassword2019”：指定至少包含 8 个字符且符合 <a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/security/password-policy?view=sql-server-ver15">SQL Server 密码要求</a>的强密码。 SQL Server 映像的必需设置。</li></ul></li><li>-<strong>d</strong>: 容器镜像（REPOSITORY）</li></ul><blockquote><p>SQLserver 密码要求：</p><ul><li>密码不得包含用户的帐户名。</li><li>密码长度至少为八个字符。</li><li>密码包含以下四类字符中的三类：</li><li>拉丁文大写字母 (A - Z)</li><li>拉丁文小写字母 (a - z)</li><li>10 个基本数字 (0 - 9)</li><li>非字母数字字符，如感叹号 (!)、美元符号 ($)、数字符号 (#) 或百分号 (%)。</li><li>密码可最长为 128 个字符。 使用的密码应尽可能长，尽可能复杂。</li></ul></blockquote><p>可以通过运行<code>docker ps</code> 查看正在运行的容器</p><p><img src="/img/Docker%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Docker/20210526201727727.png" alt="在这里插入图片描述"></p><h2 id="3-连接SQL-Server2019-数据库容器"><a href="#3-连接SQL-Server2019-数据库容器" class="headerlink" title="3. 连接SQL Server2019 数据库容器"></a>3. 连接SQL Server2019 数据库容器</h2><h3 id="3-1-命令行工具-sqlcmd"><a href="#3-1-命令行工具-sqlcmd" class="headerlink" title="3.1 命令行工具-sqlcmd"></a>3.1 命令行工具-sqlcmd</h3><h4 id="1-进入容器"><a href="#1-进入容器" class="headerlink" title="1. 进入容器"></a>1. 进入容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sqlserver2019 bash</span><br></pre></td></tr></table></figure><h4 id="2-使用sqlcmd进行本地连接"><a href="#2-使用sqlcmd进行本地连接" class="headerlink" title="2. 使用sqlcmd进行本地连接"></a>2. 使用sqlcmd进行本地连接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/mysql-tools -S localhost -U SA -P <span class="string">&quot;MYpassword2019&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-使用SSMS连接"><a href="#3-2-使用SSMS连接" class="headerlink" title="3.2 使用SSMS连接"></a>3.2 使用SSMS连接</h3><p><img src="/img/Docker%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Docker/20210526203700862.png" alt="在这里插入图片描述"></p><h3 id="3-3-使用-Navicat连接"><a href="#3-3-使用-Navicat连接" class="headerlink" title="3.3 使用 Navicat连接"></a>3.3 使用 Navicat连接</h3><p><img src="/img/Docker%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Docker/20210526204042977.png" alt="在这里插入图片描述"> </p><h2 id="4-其它"><a href="#4-其它" class="headerlink" title="4. 其它"></a>4. 其它</h2><h3 id="4-1-更改SA密码"><a href="#4-1-更改SA密码" class="headerlink" title="4.1 更改SA密码"></a>4.1 更改SA密码</h3><p>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。 创建 SQL Server 容器后，通过在容器中运行 <code>echo $SA_PASSWORD</code>，可发现指定的 <code>SA_PASSWORD</code> 环境变量。 出于安全考虑，请考虑更改 SA 密码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">   -S localhost -U SA -P <span class="string">&quot;MYpassword2019&quot;</span> \</span><br><span class="line">   -Q <span class="string">&#x27;ALTER LOGIN SA WITH PASSWORD=&quot;MYnewPASSWORD2019&quot;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Docker基础"><a href="#4-2-Docker基础" class="headerlink" title="4.2 Docker基础"></a>4.2 Docker基础</h3><p>更多关于Docker的内容请点击此处：<a href="https://blog.xclovecy.top/2021/05/02/%E5%85%A5%E9%97%A8Docker/">入门Docker | xcy.小相的个人博客 (xclovecy.top)</a></p><h1 id="使用数据卷挂载MySQL"><a href="#使用数据卷挂载MySQL" class="headerlink" title="使用数据卷挂载MySQL"></a>使用数据卷挂载MySQL</h1><blockquote><h3 id="部署要求"><a href="#部署要求" class="headerlink" title="部署要求"></a>部署要求</h3><p> 创建一个mysql容器，要求能够在宿主机上更改其配置文件，实现将mysql数据库中的数据挂载在宿主机的<code>/home/mysql/data</code>目录下，并且设置mysql的root用户的初始密码为<code>123456</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dit --name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123...xcy \</span><br><span class="line">-v /home/mysql/conf:/etc/mysql/conf.d </span><br><span class="line">-v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux|浅显易懂的ansible自动化运维教程.md</title>
      <link href="/article/ef947cb9.html"/>
      <url>/article/ef947cb9.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Ansible的安装"><a href="#1-Ansible的安装" class="headerlink" title="1. Ansible的安装"></a>1. Ansible的安装</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ansible </span><br></pre></td></tr></table></figure><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:ansible/ansible</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ansible</span><br></pre></td></tr></table></figure><h3 id="通过Python安装"><a href="#通过Python安装" class="headerlink" title="通过Python安装"></a>通过Python安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install ansible</span><br></pre></td></tr></table></figure><h2 id="2-配置Inventory"><a href="#2-配置Inventory" class="headerlink" title="2. 配置Inventory"></a>2. 配置Inventory</h2><p>inventory用来管理主机列表清单，默认对应的配置文件为<code>/etc/ansible/hosts</code>文件。该文件的内容格式如下，其中<code>[]</code>用来划分列表组。通过划分组的形式可以通过操作组来操作组内的所有主机。</p><ul><li>一个配置文件中可以含有多个组。</li><li>一个主机可以同时存在于多个组中。</li><li>当组内含有多个相似的ip时，可以通过类似于<code>[1:3]</code>的方式来规定主机范围</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 单个主机</span><br><span class="line">192.168.199.12</span><br><span class="line"></span><br><span class="line"># 划分组</span><br><span class="line">[server1]</span><br><span class="line">192.168.199.15</span><br><span class="line">192.168.199.17</span><br><span class="line">192.168.199.19</span><br><span class="line"></span><br><span class="line">[server2]</span><br><span class="line">192.168.199.15</span><br><span class="line">192.168.199.[22:30] # 表示192.168.199.22至192.168.199.30之间的所有主机</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><blockquote><p>Ansible的返回结果非常友好，一般会用三种颜色来表示执行结果:</p><ul><li>红色：表示执行过程出现异常；</li><li>橘黄：表示命令执行后目标有状态变化；</li><li>绿色：表示执行成功且没有目标机器做修改；</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible -i /etc/abdible/hosts all -m ping</span><br></pre></td></tr></table></figure><ul><li><code>-i</code> : 指定inventory文件。默认先寻找当前目录下的hosts文件，若没有则默认使用 <code>/etc/ansible/hosts</code>文件。</li><li><code>all</code> : ansible自带的分组，表示所有主机。</li><li><code>-m</code> : 命令参数，后跟需要执行的命令</li></ul><p>执行以上命令会发现输出红色错误信息，类似如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.199.15 | UNREACHABLE! =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Failed to connect to the host via ssh: Warning: Permanently added &#x27;192.168.199.115&#x27; (ECDSA) to the list of known hosts.\r\nxc@192.168.199.115: Permission denied (publickey,password).&quot;</span>,</span><br><span class="line">    <span class="string">&quot;unreachable&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当ansible没有指定登录用户时，它会试图用你的当前用户名来连接你的远程机器。若想使用指定的用户名来登录远程主机，则可以使用<code>-u</code>参数来指定用户。指定登录用户后再次尝试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible -i /etc/abdible/hosts all -m ping -u root</span><br></pre></td></tr></table></figure><p>发现仍旧失败，分析错误原因可知，主机授权失败，可想而知，是ansible没有成功登录主机列表中的主机，因此无法执行<code>ping</code>命令。</p><p>Ansible 通过 <code>SSH</code> 对设备进行管理，而 SSH 包含两种认证方式：一种是通过<code>密码认证</code>，另一种是通过<code>密钥对验证</code>。前者必须和系统交互，而后者是免交互登录。如果希望通过 Ansible 自动管理设备，应该配置为免交互登录被管理设备。</p><p>这里我们就先向主机列表中<code>ssh-copy-id</code>公钥。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i root@192.168.199.207</span><br><span class="line">……此处省略多条相似命令……</span><br></pre></td></tr></table></figure><p>再次执行测试命令<code>ping</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible all -m ping -u root</span><br></pre></td></tr></table></figure><p><strong>执行成功：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.199.115 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;discovered_interpreter_python&quot;</span>: <span class="string">&quot;/usr/bin/python&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">192.168.199.218 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;discovered_interpreter_python&quot;</span>: <span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">192.168.199.207 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;discovered_interpreter_python&quot;</span>: <span class="string">&quot;/usr/bin/python&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小插曲，由于实验环境为Ubuntu桌面版，默认不允许使用<code>root</code>用户远程登录，因此需要进行如下步骤设置允许root用户远程登录：</p><ul><li>登录主机（含有管理员权限即可）</li><li>sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</li><li>将<code>PermitRootLogin prohibit-password</code>改为<code>PermitRootLogin yes</code></li><li>重启sshdf服务<code>service ssh restart</code></li></ul></blockquote><h1 id="2-Inventory文件"><a href="#2-Inventory文件" class="headerlink" title="2. Inventory文件"></a>2. Inventory文件</h1><p>inventory用来管理主机列表清单，默认对应的配置文件为<code>/etc/ansible/hosts</code>文件。</p><p>inventory文件支持对主机列表进行分组操作，通过划分组的形式可以通过操作组来操作组内的所有主机。通过<code>[]</code>来定义组名。一个配置文件中可以含有多个组,一个主机也可以同时存在于多个组中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 单个主机</span><br><span class="line">192.168.199.12</span><br><span class="line"></span><br><span class="line"># 划分组</span><br><span class="line">[server1]</span><br><span class="line">192.168.199.15</span><br><span class="line">192.168.199.16</span><br><span class="line"></span><br><span class="line">[server2]</span><br><span class="line">192.168.199.15</span><br><span class="line">192.168.199.17</span><br></pre></td></tr></table></figure><p>当组内含有多个相似的ip时，可以通过类似于<code>192.168.199.[1:10]</code>的方式来b表示定义的主机范围（ 表示192.168.199.1至192.168.199.10之间的所有主机）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server3]</span><br><span class="line">192.168.199.15</span><br><span class="line">192.168.199.[1:10] # 表示192.168.199.1至192.168.199.10之间的所有主机</span><br></pre></td></tr></table></figure><p>inventory中的所有主机默认连接端口（ssh）为<code>22</code>号端口，也可以在主机后标明连接端口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server4]</span><br><span class="line">192.168.199.15:8887 # 指定该主机的连接端口为8887</span><br><span class="line">192.168.199.17:8888 # 指定该主机的连接端口为8888</span><br><span class="line">192.168.199.19:8889 # 指定该主机的连接端口为8889</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了使用ip地址来表示主机外，也可以使用<code>域名</code>来标明主机:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server5]</span><br><span class="line">192.168.199.15</span><br><span class="line">xcyxiaoxiang.top</span><br></pre></td></tr></table></figure><p>此外，当一个组中主机数较多，且又需要添加新的主机时，可以新建一个组，并将另外一个组作为该组的<code>子组</code>，如下，newgroup组中的主机包含biggroup组中的所有主机以及新增加的两个主机。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[biggroup]</span><br><span class="line">192.168.199.1</span><br><span class="line">……</span><br><span class="line">192.168.199.200</span><br><span class="line"></span><br><span class="line">[newgroup:children]</span><br><span class="line">biggroup</span><br><span class="line">192.168.177.3</span><br><span class="line">192.168.177.4</span><br></pre></td></tr></table></figure><h1 id="3-通过Ansible配置免密登录"><a href="#3-通过Ansible配置免密登录" class="headerlink" title="3. 通过Ansible配置免密登录"></a>3. 通过Ansible配置免密登录</h1><h2 id="1-关闭公钥认证"><a href="#1-关闭公钥认证" class="headerlink" title="1. 关闭公钥认证"></a>1. 关闭公钥认证</h2><ol><li><p>打开<code>etc/ansible/ansible.cfg</code>文件并编辑:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索host_key_checking，取消该行注释，并将值设置为False（大约在71行左右）</span></span><br><span class="line"><span class="string">host_key_checking</span> <span class="string">=</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-生成密钥和公钥"><a href="#2-生成密钥和公钥" class="headerlink" title="2. 生成密钥和公钥"></a>2. 生成密钥和公钥</h2><p>如果当前主机已经存在密钥和公钥那么久可以略过该步骤。若没有请继续：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t -rsa </span><br></pre></td></tr></table></figure><h2 id="3-配置inventory"><a href="#3-配置inventory" class="headerlink" title="3. 配置inventory"></a>3. 配置inventory</h2><p>编辑<code>etc/ansible/hosts</code>文件,添加主机信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">192.168.199.207 ansible_ssh_user=root ansible_ssh_pass=&quot;wll&quot;</span><br><span class="line">192.168.199.115 ansible_ssh_user=root ansible_ssh_pass=&quot;wll&quot;</span><br><span class="line">192.168.199.218 ansible_ssh_user=root ansible_ssh_pass=&quot;wll&quot;</span><br></pre></td></tr></table></figure><blockquote><p>此处比较适用于用户名和密码不相同时。在这里所有主机的用户名和密码都相同，也可以在最后执行命令时通过<code>-u</code>指定同一用户，<code>-k</code>指定同一密码。</p></blockquote><h2 id="4-编写playbooks"><a href="#4-编写playbooks" class="headerlink" title="4.编写playbooks"></a>4.编写playbooks</h2><p>在当前工作目录下创建并编辑<code>playbooks.yaml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">ssh.public</span></span><br><span class="line">       <span class="attr">authorized_key:</span> <span class="string">user=root</span></span><br><span class="line">                       <span class="string">key=&quot;&#123;&#123;lookup(&#x27;file&#x27;,&#x27;/root/.ssh.id_rsa.pub&#x27;)&#125;&#125;&quot;</span></span><br><span class="line">                       <span class="string">state=present</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>通过<code>ansible-doc anthorized_key</code>命令，可查看关于<code>anthorized_key</code>命令的使用方式。</p><blockquote><p>作用：Adds or removes SSH authorized keys for particular user accounts.</p><p>参数：</p><ul><li>user : he username on the remote host whose authorized_keys file will be modified.</li><li>key : The SSH public key(s), as a string or url.Default:null.</li><li>state:  Whether the given key (with the given key_options) should or should not be in the file.</li></ul></blockquote><h2 id="5-运行测试"><a href="#5-运行测试" class="headerlink" title="5. 运行测试"></a>5. 运行测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ansible-playbook playbooks.yaml</span><br></pre></td></tr></table></figure><p><img src="/img/Linux%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E7%9A%84ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%95%99%E7%A8%8B/image-20211111201112351.png" alt="image-20211111201112351"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java|在Java中使用Ajax</title>
      <link href="/article/824ac3d0.html"/>
      <url>/article/824ac3d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。Ajax具有以下作用：</p><ul><li>在页面加载后动态的向服务器请求数据</li><li>在页面加载后动态的从服务器接收数据</li><li>不刷新页面更新网页</li><li>AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。</li></ul><p>Ajax 在浏览器与 Web 服务器之间使用<strong>异步数据</strong>传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。</p><ul><li><p>Ajax可使因特网应用程序更小、更快，更友好。</p></li><li><p>Ajax 是一种独立于 Web 服务器软件的浏览器技术。</p></li></ul><p><img src="/img/Java%E5%9C%A8Java%E4%B8%AD%E4%BD%BF%E7%94%A8Ajax/b21c8701a18b87d61337414f050828381f30fd6d-1651304576992" alt="AJAX 工作原理"></p><h2 id="2-用处"><a href="#2-用处" class="headerlink" title="2. 用处"></a>2. 用处</h2><ul><li>注册时，输入用户名自动检测用户是否已经存在</li><li>登陆时，提示用户名密码错误</li><li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除</li></ul><h2 id="3-Jquery的Ajax使用"><a href="#3-Jquery的Ajax使用" class="headerlink" title="3. Jquery的Ajax使用"></a>3. Jquery的Ajax使用</h2><p>Ajax的核心是<code>XMLHttpRequest对象</code>(XHR)。<strong>XHR</strong>为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。而<strong>jQuery</strong> 提供多个与 AJAX 有关的方法。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:请求地址,</span><br><span class="line">    <span class="attr">data</span>:发送的数据,</span><br><span class="line">    <span class="attr">method</span>:请求方法post/get,</span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        成功后执行的方法</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        失败后执行的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">url：请求地址</span><br><span class="line">method：请求方式，GET、POST</span><br><span class="line">data：要发送的数据</span><br><span class="line">headers：请求头</span><br><span class="line">success：成功之后执行的回调函数(全局)</span><br><span class="line">error：失败之后执行的回调函数(全局)</span><br><span class="line">dataType：将服务器端返回的数据转换成指定类型</span><br><span class="line">    <span class="attr">&quot;xml&quot;</span><span class="punctuation">:</span> 将服务器端返回的内容转换成xml格式</span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> 将服务器端返回的内容转换成普通文本格式</span><br><span class="line">    <span class="attr">&quot;html&quot;</span><span class="punctuation">:</span> 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。</span><br><span class="line">    <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式</span><br><span class="line">    <span class="attr">&quot;json&quot;</span><span class="punctuation">:</span> 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class="line">    <span class="attr">&quot;jsonp&quot;</span><span class="punctuation">:</span> JSONP 格式使用 JSONP 形式调用函数时，如 <span class="string">&quot;myurl?callback=?&quot;</span> jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</span><br><span class="line">contentType：即将发送信息至服务器的内容编码类型(默认<span class="punctuation">:</span> <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>)</span><br><span class="line">async：是否异步</span><br><span class="line">timeout：设置请求超时时间（毫秒）</span><br><span class="line">beforeSend：发送请求前执行的函数(全局)</span><br><span class="line">complete：完成之后执行的回调函数(全局)</span><br><span class="line">accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="案例-用户登录"><a href="#案例-用户登录" class="headerlink" title="案例-用户登录"></a>案例-用户登录</h2><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ul><li>用户输入用户名，鼠标移开输入框时动态提示用户名是否重复</li><li>用户输入密码并验证密码，若两次相同，则提示正确；否则提示密码错误。</li><li>但用户名不重复且密码正确的前提下可以进行登录否则不允许登录。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>login.jsp</strong>:</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: xc</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">1</span>/<span class="number">7</span></span><br><span class="line">  Time: 下午<span class="number">10</span>:<span class="number">20</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;userName&quot;</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span>&gt; &lt;span id=<span class="string">&quot;userMsg&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div &gt;</span><br><span class="line">        密 码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;password&quot;</span>&gt; &lt;span id=<span class="string">&quot;passwordMsg&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       重复密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;repassword&quot;</span> id=<span class="string">&quot;repassword&quot;</span>&gt; &lt;span id=<span class="string">&quot;repasswordMsg&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;登录&quot;</span> id=<span class="string">&quot;login&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.6.0.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pflag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">uflog</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 动态验证用户名是否正确</span></span><br><span class="line">        $(<span class="string">&quot;#name&quot;</span>).blur(function () &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/verifyUserName&quot;</span>,</span><br><span class="line">                data:&#123;name:$(<span class="string">&quot;#name&quot;</span>).val()&#125;,</span><br><span class="line">                method:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">                success:function (data) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(data==<span class="literal">true</span>)&#123;</span><br><span class="line">                        $(<span class="string">&quot;#userMsg&quot;</span>).html(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">                        uflog = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        $(<span class="string">&quot;#userMsg&quot;</span>).html(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                error:function () &#123;</span><br><span class="line">                    console.log(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证重复密码</span></span><br><span class="line">        $(<span class="string">&quot;#repassword&quot;</span>).blur(function () &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">password</span> <span class="operator">=</span> $(<span class="string">&quot;#password&quot;</span>).val();</span><br><span class="line">            <span class="type">var</span> <span class="variable">repassword</span> <span class="operator">=</span> $(<span class="string">&quot;#repassword&quot;</span>).val();</span><br><span class="line">            <span class="keyword">if</span>(password == repassword)&#123;</span><br><span class="line">                $(<span class="string">&quot;#repasswordMsg&quot;</span>).html(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                pflag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="string">&quot;#repasswordMsg&quot;</span>).html(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录事件</span></span><br><span class="line">        $(<span class="string">&quot;#login&quot;</span>).click(function () &#123;</span><br><span class="line">            <span class="keyword">if</span>(pflag&amp;&amp;uflog)&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot;</span>,</span><br><span class="line">                    method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        name:$(<span class="string">&quot;#name&quot;</span>).val(),</span><br><span class="line">                        password:$(<span class="string">&quot;#password&quot;</span>).val()</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success:function (data) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(data == <span class="literal">true</span>)&#123;</span><br><span class="line">                            alert(<span class="string">&quot;login~&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            alert(<span class="string">&quot;no login&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error:function () &#123;</span><br><span class="line">                        alert(<span class="string">&quot;error login&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LoginController:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.xcyxiaoxiang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证用户名</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/verifyUserName&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyUserName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;verifyUserName:&quot;</span>+name);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;xcy&quot;</span>.equals(name))&#123;</span><br><span class="line">            msg = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            msg = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证登录</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String name,String password)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot;\npassword:&quot;</span>+password);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;xcy&quot;</span>.equals(name)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(password))&#123;</span><br><span class="line">            msg = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            msg = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python|python内置排序函数.md</title>
      <link href="/article/d4e5b415.html"/>
      <url>/article/d4e5b415.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-sort-函数"><a href="#1-sort-函数" class="headerlink" title="1. sort()函数"></a>1. sort()函数</h2><p>sort()函数是python3内置的列表方法，用于对列表中的元素进行指定行为的排序。sort()函数具有以下特点：</p><ul><li><p>不返回值，即列表本身进行排序，也称永久性排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(a.sort())</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>升序降序：参数reverse&#x3D;True时为降序，False为升序（默认值）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reverse=True  降序:&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">b.sort(reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reverse=False 升序:&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">c.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   默认值      升序:&quot;</span>,c)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">reverse=<span class="literal">True</span>  降序: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">reverse=<span class="literal">False</span> 升序: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">默认值         升序: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-sorted-函数"><a href="#2-sorted-函数" class="headerlink" title="2. sorted()函数"></a>2. sorted()函数</h2><p>与sort()函数不同，sorted()是python的内置函数，作用范围较sort()大一些。它具有以下特点：</p><ul><li><p>具有返回值，即将排序后的结果返回，并不对原列表进行任何操作，故又称为临时性排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">b = <span class="built_in">sorted</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">b: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">a: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>升序降序：参数reverse&#x3D;True时为降序，False为升序（默认值），这点与sort()函数相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">b = <span class="built_in">sorted</span>(a,reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b 降序:&quot;</span>,b)</span><br><span class="line">c = <span class="built_in">sorted</span>(a,reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a 升序:&quot;</span>,c)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">b 降序: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">a 升序: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python使用pyplot添加图例-坐标轴尺度.md</title>
      <link href="/article/965eaddc.html"/>
      <url>/article/965eaddc.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-添加图例"><a href="#1-添加图例" class="headerlink" title="1.添加图例"></a>1.添加图例</h2><p>在同一图中绘制多条曲线时，为了便于区分和使图像更加专业化，我们通常会给图像添加图例。<br>如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">40</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">40</span>,<span class="number">70</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入xy轴参数，默认为y轴;label 指定图例名称</span></span><br><span class="line">plt.plot(a,label=<span class="string">&quot;a&quot;</span>,color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.plot(b,label=<span class="string">&quot;b&quot;</span>,color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)  <span class="comment"># 设置图例位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定xy轴 名称</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;This is Y&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;This is X&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像 默认png格式，其中dpi指图片质量</span></span><br><span class="line">plt.savefig(<span class="string">&quot;05.png&quot;</span>, dpi=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">plt.show()  <span class="comment"># 展示图片</span></span><br></pre></td></tr></table></figure><p>输入图像如下：<br><img src="/img/Python%E4%BD%BF%E7%94%A8pyplot%E6%B7%BB%E5%8A%A0%E5%9B%BE%E4%BE%8B-%E5%9D%90%E6%A0%87%E8%BD%B4%E5%B0%BA%E5%BA%A6/20200823143537535.png" alt="在这里插入图片描述"><br>通过在plot(label&#x3D;” “) 指定图例名称，随后通过legend()的参数指定图例位置,便可对图像添加图例，其中loc参数如下：</p><ul><li>best</li><li>upper right</li><li>upper left</li><li>lower left</li><li>lower right</li><li>right</li><li>center left</li><li>center right</li><li>lower center</li><li>upper center</li><li>center</li></ul><h2 id="2-设置xy轴刻度"><a href="#2-设置xy轴刻度" class="headerlink" title="2.设置xy轴刻度"></a>2.设置xy轴刻度</h2><p>上文我们讲述了如何设置图像图例，但是细心的盆友会发现，我们在设置图像x&#x2F;y轴坐标尺度时是让它自动调整，但有时候我们需要人为的对刻度进行控制。这时候我们可以plt.xticks()&#x2F;plt.yticks()进行设置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">b = np.arange(<span class="number">40</span>,<span class="number">130</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x/y轴尺度</span></span><br><span class="line">plt.xticks(a[::<span class="number">5</span>])</span><br><span class="line">plt.yticks(b[::<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入xy轴参数，默认为y轴;label 指定图例名称</span></span><br><span class="line">plt.plot(a,label=<span class="string">&quot;a&quot;</span>,linestyle=<span class="string">&quot;--&quot;</span>,color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.plot(b,label=<span class="string">&quot;b&quot;</span>,color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)  <span class="comment"># 设置图例位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定xy轴 名称</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;This is Y&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;This is X&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像 默认png格式，其中dpi指图片质量</span></span><br><span class="line">plt.savefig(<span class="string">&quot;05.png&quot;</span>, dpi=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">plt.show()  <span class="comment"># 展示图片</span></span><br></pre></td></tr></table></figure><p>图像如下：<br><img src="/img/Python%E4%BD%BF%E7%94%A8pyplot%E6%B7%BB%E5%8A%A0%E5%9B%BE%E4%BE%8B-%E5%9D%90%E6%A0%87%E8%BD%B4%E5%B0%BA%E5%BA%A6/20200823152957396.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux|一文搞懂java多线程.md</title>
      <link href="/article/273687f6.html"/>
      <url>/article/273687f6.html</url>
      
        <content type="html"><![CDATA[<p>Java 语言提供了非常优秀的多线程支持,程序可以通过非常简单的方式来启动多线程。几乎所有的操作系统都支持同时运行多个任务,一个任务通常就是一 个程序,每个运行中的程序就是一个进程 。 当一个程序运行时,内部可能包含了多个顺序执行流,每个顺序执行流就是一个线程 。</p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-程序、进程、线程"><a href="#1-1-程序、进程、线程" class="headerlink" title="1.1 程序、进程、线程"></a>1.1 程序、进程、线程</h2><ul><li><p><strong>程序（program）</strong></p><p>程序是为完成特定任务、用某种语言编写的<strong>一组指令的集合</strong>。即指一段<code>静态</code>的代码（还没有运行起来），静态对象。</p></li><li><p><strong>进程（process）</strong></p><p><code>进程是程序的一次执行过程</code> ，也就是说程序运行起来了，加载到了内存中，并占用了cpu的资源。这是一个<strong>动态</strong>的过程：有自身的产生、存在和消亡的过程，这也是进程的生命周期。进程是系统中独立存在的实体,它可以拥有自己独立的资源,每 一个进程都拥有自己私有的地址空间 。 </p><p>进程是系统资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。<strong>进程是资源分配的最小单位</strong>。</p><blockquote><p>进程具有一定的生命周期，因此含有动态性；而程序只是一组有序指令的集合，因而是静态的。</p></blockquote></li><li><p><strong>线程（thread）</strong></p><p>线程 (Thread ) 也被称作轻量级进程 (Lightweight Process) ,线程是进程的执行单元 。 进程可进一步细化为线程，是一个程序内部的执行路径。<strong>线程是进程的组成部分, 一 个进程可以拥有多个线程,一个线程必须有 一个父进程。</strong>线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量,<strong>但不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源</strong>。<strong>线程是cpu调度的最小单位</strong>。</p><blockquote><p>当主线程结束时,其他线程不受任何影响,并不会随之结束 。一旦子线程启动起来后,它就拥有和主线程相同的地位,它不会受主线程的影响 。</p></blockquote></li></ul><h2 id="1-2-并发和并行"><a href="#1-2-并发和并行" class="headerlink" title="1.2 并发和并行"></a>1.2 并发和并行</h2><ul><li><p><strong>并行</strong>：同一时刻，多个cpu同时执行多个任务。 </p></li><li><p><strong>并发</strong>：同一时刻，多个任务交替执行，造成一种多个任务<code>同时</code>运行的假象。单核CPU实现的多任务就是并发。</p></li><li><p><strong>CPU单核和多核的理解</strong></p><p><strong>单核</strong>的CPU是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。同时间段内有多个线程需要CPU去运行时，CPU也只能交替去执行多个线程中的一个线程，但是由于其执行速度特别快，因此感觉不出来。</p><p><strong>多核</strong>的CPU才能更好的发挥多线程的效率。</p><blockquote><p>对于<strong>Java</strong>应用程序java.exe来讲，至少会存在三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。</p></blockquote></li><li><p><strong>时间片：</strong>cpu正常情况下的调度策略。即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p></li><li><p><strong>Java线程的分类</strong>：用户线程 和 守护线程</p><ul><li>Java的gc()垃圾回收线程就是一个守护线程</li><li>守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以吧一个用户线程变成一个守护线程。</li></ul></li></ul><h2 id="1-3-多线程的优势"><a href="#1-3-多线程的优势" class="headerlink" title="1.3 多线程的优势"></a>1.3 多线程的优势</h2><p><strong>多线程的优点</strong>：</p><ol><li>进程之间不能共 享 内存,但线程之间<strong>共享内存</strong>非常容易 。</li><li>利用这些共享的数据,线程<strong>很容易实现相互之间的通信</strong> 。</li><li>系统创建进程时需要为该进程重新分配系统资源,但创建线程则<strong>代价小</strong>得多。</li><li>因为线程的划分尺度小于进程,使得多线程程序的<strong>并发性高</strong> ，提高计算机系CPU的利用率。</li></ol><p><strong>何时需要多线程：</strong></p><ul><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时。</li></ul><h1 id="2-实现线程的几种方式"><a href="#2-实现线程的几种方式" class="headerlink" title="2. 实现线程的几种方式"></a>2. 实现线程的几种方式</h1><p>Java语言的JVM允许程序运行多个线程，多线程可以通过Java中的<code>java.lang.Thread</code>类来体现。所有的线程对象都必须是<strong>Thread类或其子类</strong>的实例。在Java中，使用<strong>线程体</strong>（<code>run()方法</code>）来表示一段需要执行的程序流，通过调用Thread对象的<code>start()方法</code>来启动这个线程，它会自动调用线程对象的run方法。<strong>而非直接调用run()。</strong></p><h2 id="2-1-继承Thread类创建线程类"><a href="#2-1-继承Thread类创建线程类" class="headerlink" title="2.1 继承Thread类创建线程类"></a>2.1 继承Thread类创建线程类</h2><p>通过<strong>继承</strong>Thread类创建线程类的步骤如下：</p><blockquote><ol><li>创建一个继承<code>Thread类</code>的类，重写Thread类的<code>run()</code>方法，该run方法代表了线程的执行体，也就是我们需要在run方法内编写业务代码。</li><li>创建Thread类的子类的<strong>实例</strong>对象。</li><li>通过此对象调用start()来启动一个线程。</li></ol></blockquote><p>首先，我们先按照步骤来创建一个Thread类的子类<code>FirstThread</code>，并实现其run()方法(线程体)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过重写run方法来实现自己的业务逻辑，该部分也叫做，线程体。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; num&lt;<span class="number">100</span>; num++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类，通过start()方法，开启“两个”线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 通过调用start方法来开启线程，它会自动调用线程对象的run方法。</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FirstThread</span>().start();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FirstThread</span>().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类的主方法，可以看到出现了有三个不同的输出结果？不要忘记主线程也是一个线程，因此一个主线程+两个显式创建的线程一共有三个线程。</p><blockquote><p>线程具有默认的名称，可以通过<code>Thread.getCurrentThread()</code><strong>静态</strong>方法来获取当前正在运行的线程。</p><ul><li>主线程默认名称为“main”</li><li>其它线程默认名称为“Thread-0”、“Thread-1”……</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-1:68</span><br><span class="line">main:42</span><br><span class="line">Thread-1:69</span><br><span class="line">Thread-0:83</span><br><span class="line">Thread-1:70</span><br><span class="line">main:43</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的子线程和主线程是同时开始的，<strong>当主线程结束后，子线程仍会继续</strong>，并不会因主线程的结束而结束。</p><h2 id="2-2-实现Runnable接口创建线程类"><a href="#2-2-实现Runnable接口创建线程类" class="headerlink" title="2.2 实现Runnable接口创建线程类"></a>2.2 实现Runnable接口创建线程类</h2><p>通过实现Runnable接口，并实现其<code>run()</code>方法来创建线程类。Runnable的实例化对象仅作为Thread对象的target，也就是说，我们<strong>实际的线程对象是Thread对象，而Runnable的实例化对象仅作为构建Thread对象时的参数</strong>，Thread会自动执行Runnable对象的方法体(<code>run方法()</code>)。</p><blockquote><p>这里使用到了一种设计模式：<strong>代理模式（静态代理）</strong>。 </p></blockquote><p>通过实现<code>Runnable接口</code>创建线程类的步骤如下：</p><blockquote><ol><li>定义一个<strong>实现</strong>Runnable接口的类，并实现Runnable接口中的线程体<code>run()方法</code>。</li><li>创建实现类的对象，<strong>将此对象作为参数传到Thread类的构造器中</strong>，创建Thread类的对象。</li><li>通过Thread类的对象调用start()方法。</li></ol></blockquote><p>创建一个SecondThread类实现Runnable接口，并实现run()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;num++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，将SecondThread实例对象作为参数传入到Thread的构造器中，并通过start()方法开始线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecondThread</span> <span class="variable">secondThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecondThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(secondThread,<span class="string">&quot;第一个线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(secondThread,<span class="string">&quot;第二个线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个线程:1</span><br><span class="line">第二个线程:2</span><br><span class="line">第一个线程:3</span><br><span class="line">第二个线程:4</span><br><span class="line">第一个线程:5</span><br><span class="line">第二个线程:6</span><br><span class="line">第二个线程:7</span><br></pre></td></tr></table></figure><p>细心的同学可以发现，通过Runnable实现的线程类，可以<strong>共享实例变量</strong>，因为我们这里使用的是同一个Runnable类的对象作为target，从而多个线程<strong>共享</strong>了其实例的<code>num</code>变量。<strong>而通过继承<code>Thread</code>创建的线程类不具有该特性！</strong></p><p>此外，Runnable接口被<code>@FuncationInterface</code>修饰，因此，Runnable接口是一个函数式接口，可以使用<strong>Lambda表达式</strong>来创建Runnablle实例。上面的代码可以简化为如下代码，当然，这种情况下，就不能共享实例变量了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;第一个线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;第二个线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-实现Callable接口创建线程类"><a href="#2-3-实现Callable接口创建线程类" class="headerlink" title="2.3 实现Callable接口创建线程类"></a>2.3 实现Callable接口创建线程类</h2><p>与Runnable相比，Callable与前者类似，但Callable更强大。Callable接口提供了一个call()方法，如run()方法相比，该方法可以具有返回值，可以抛出异常。</p><p>那么如何接受call()方法的返回值呢？java提供了一个<code>Future</code>接口，用来代表Callable接口内call()方法的返回值。FutureTask是Future的一个实现类。通过该类来包装Callable类，从而获取方法的返回值。其常用方法如下：</p><ul><li><code>get()</code>: 获取call()方法的返回值。</li><li><code>get(Long timeout,TimeUnit unit)</code>:  获取call()方法的返回值，并指定超时时间，若超时，则抛出TimeoutException异常。</li><li><code>cancel(boolean mayInterruptIfRunning)</code>: 取消该task对象中包含的Callable任务。</li><li><code>isCancelled()</code>: 判断callable任务是否在正常完成之前被取消，是则返回true。</li><li><code>isDone()</code>: 判断callable任务是否正常完成并结束。</li></ul><p>创建一个ThirdThread类实现Callable接口，并实现call()方法，这一步几乎和runnable一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;：已完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，使用Future类包装ThirdThread对象，即将<code>ThirdThread</code>作为<code>FutureTask</code>的构造器<strong>参数</strong>传入。并通过FutureTask对象的get()方法获取call()的返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;String&gt; stringFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ThirdThread</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(stringFutureTask,<span class="string">&quot;第一个线程&quot;</span>).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = stringFutureTask.get();</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-通过线程池创建线程类"><a href="#2-4-通过线程池创建线程类" class="headerlink" title="2.4 通过线程池创建线程类"></a>2.4 通过线程池创建线程类</h2><p><strong>背景：</strong></p><p> 经常创建和销毁、使用量特别大的资源、比如并发情况下的线程、对性能影响很大。</p><p><strong>思路：</strong></p><p> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><strong>优点：</strong></p><p> 提高响应速度（减少了创建新线程的时间）</p><p> 降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p><p> 便于线程管理</p><h2 id="2-5-探究start-方法的执行原理"><a href="#2-5-探究start-方法的执行原理" class="headerlink" title="2.5 探究start()方法的执行原理"></a>2.5 探究start()方法的执行原理</h2><p>通过上面，我们知道需调用start()方法来启动线程，而不是调用run()方法。调用run()方法，系统只会将该方法体作为一个普通的程序<strong>立即</strong>执行，而其他方法必须<strong>等待</strong>run()方法结束后才能执行，无法实现并发执行！</p><p>start()方法本质上是调用的<code>start0()方法</code>，而这个方式是一个本地方法，由JVM调用。当调start()方法时，系统会才将该run()方法作为线程执行体来处理！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.start0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-比较创建线程的几种方式"><a href="#2-6-比较创建线程的几种方式" class="headerlink" title="2.6 比较创建线程的几种方式"></a>2.6 比较创建线程的几种方式</h2><p>通过继承 Thread 类或实现 Runnable 、 Callable 接口<strong>都可以实现多线程</strong>。实现 Runnable 接口与实现 Callable 接口的方式基本相同,只是 Callab le 接口里定义的方法有返回值,可以声明抛出异常而己 。</p><p><strong>继承 Thread 类实现多线程的优缺点：</strong></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 因为线程类己经继承了 Thread 类 ,所以<span class="strong">**不能再继承其他父类**</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 编写简单,如果需要访问当前线程,则无须使用 Thread .currentThreadO方法,直接使用this 即可获得当前线程 。</span><br></pre></td></tr></table></figure><p><strong>实现 Runnable 、 Callable 接口实现多线程的优缺点</strong>：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 线程类只是实现了 Runnable 接口或 Callable 接口, <span class="strong">**还可以继承其他类**</span> 。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 在这种方式下,多个线程可以共享同一个 target 对象,所以非常<span class="strong">**适合多个相同线程来处理同一份资源**</span>的情况。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 编程稍稍复杂,如果需要访问当前线程,则必须使用 Thread.currentThreadO方法 。</span><br></pre></td></tr></table></figure><blockquote><p>因此一般推荐<strong>采用实现 Runnable 接口、 Callable 接口</strong>的方式来创建多线程。</p></blockquote><h1 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h1><p>一个线程从开始创建到最后结束共经过了5个阶段：<code>新建(New)</code>、<code>就绪(Runnable)</code>、<code>运行(Running)</code>、<code>阻塞(Blocked)</code>、<code>死亡(Dead)</code>，当有多个线程同时运行时，CPU大概率需要在多条线程之间切换,于是线程状态也会多次在<strong>运行、就绪</strong>之间切换 。</p><ul><li><p><code>新建状态</code>：当程序使用 <code>new </code>关键宇创建了一个线程之后,该线程就处于新建状态，,但其仅仅由 Java 虚拟机为其分配内存，并没有进行运行，即系统没有调用其线程执行体。 需要注意的是<strong>线程只能拥有一次这种状态</strong>。</p></li><li><p><code>就绪状态</code>：当线程对象调用了 <code>start()</code>方法之后,该线程处于就绪状态, JVM为其创建方法调用栈和程序计数器（即资源）,<strong>处于这个状态中的线程并没有开始运行 , 只是表示该线程可以运行了</strong> ，具体何时运行，这取决于JVM中的线程调度器。</p></li><li><p><code>运行状态</code>：如果处于就绪状态的线程获得了 <code>CPU </code>,开始执行 run()方法的线程执行体,则该线程就处于运行状态。</p></li><li><p><code>阻塞状态</code>：当发生如下情况时 ,处于运行状态的线程将会进入阻塞状态。当转为阻塞状态的线程满足条件后就会再次转为就绪状态，等待系统为其分配GPU。</p><ol><li>线程调用sleep()方法主动放弃所占用的处理器资源</li><li>线程调用了一个阻塞式IO方法,在该方法返回之前,该线程被阻塞</li><li>线程试图获得一个同步监视器,但该同步监视器正被其他线程所持有</li><li>线程在等待某个通知 ( notify )</li><li>程序调用了线程的 suspend()方法将该线程挂起</li></ol></li><li><p><code>死亡</code>：线程的结束就代表着该线程的死亡。包括线程执行完成正常结束、线程抛出异常非正常结束。</p></li></ul><p>五种状态的互相转换关系如下：</p><p><img src="/img/Java%E5%A4%9A%E7%BA%BF%E7%A8%8BThread/image-20220507093155324.png" alt="image-20220507093155324"></p><h1 id="4-控制线程"><a href="#4-控制线程" class="headerlink" title="4. 控制线程"></a>4. 控制线程</h1><p>Java 的线程支持提供了一些便捷的工具方法 ,。这些方法包含在<code>Thread</code>类中，通过调用其<code>静态方法</code>或<code>实例方法</code>可以很好地控制线程的执行。主要包括：</p><ul><li><p><strong>join线程</strong>： 当在某个程序执行流中调用其他线程的 join()方法时,调用线程将被阻塞 , <strong>直到被 join()方法加入的 join()线程执行完为止</strong> 。</p></li><li><p><strong>守护线程</strong>：它是在后台运行的一种特殊线程,它的任务是为其他的线程提供服务 ，如果所有的前台线程都死亡 , 后台线程会自动死亡。</p></li><li><p><strong>线程睡眠</strong>：要让当前正在执行的线程暂停一段时间,并进入阻塞状态。</p></li><li><p><strong>线程优先级</strong>：每个线程执行时都具有一定的优先级,优先级高的线程获得较多的执行机会，每个线程默认的优先级都与 创建它的父线程的优先级相同。</p></li></ul><h2 id="4-1-Join线程"><a href="#4-1-Join线程" class="headerlink" title="4.1 Join线程"></a>4.1 Join线程</h2><p>当在某个程序执行流中<strong>A线程</strong>调用B线程的<code>join()</code>方法时,A线程将被阻塞 , <strong>直到B线程线程执行完为止</strong> 。join方法主要有以下两种形式：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>join()</code></td><td>将该线程加入到当前线程中</td></tr><tr><td><code>join(long millis)</code></td><td>将该线程加入到当前线程中，并规定最长执行时间。如果在millis毫秒内被 Join() 的线程还没有执行结束,则不再等待</td></tr></tbody></table><p>下面代码要做的是：当main线程执行一半时，加入dog线程，直到dog线程执行完毕后，才继续执行main线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            <span class="comment">// 当main线程执行一半时，加入dog线程。直到dog线程执行完毕后，才继续执行main线程。</span></span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">joinThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">                joinThread.start();</span><br><span class="line">                joinThread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main:<span class="number">8</span></span><br><span class="line">main:<span class="number">9</span></span><br><span class="line">开始执行Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line">结束执行Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">10</span></span><br><span class="line">main:<span class="number">11</span></span><br><span class="line">main:<span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="4-2-守护线程"><a href="#4-2-守护线程" class="headerlink" title="4.2 守护线程"></a>4.2 守护线程</h2><p><strong>守护线程</strong>又叫“后台线程”或“精灵线程”，它是在后台运行的,它的任务是为其他的线程提供服务 , <strong>JVM 的垃圾回收线程就是典型的守护线程。</strong> 如果所有的前台线程都死亡 , 后台线程会自动死亡。通过调用 Thread 对象的<code>setDaemon (true)</code>方法可将指定线程设置成守护线程。需要注意的是：<code>setDaemon(true) </code>必须在 <code>start() </code>方法<strong>之前</strong>调用,否则会引发<code>IllegalThreadStateException</code> 异常 。</p><p>Thread 类还提供了一个<code> isDaemon()</code>方法,用于判断指定线程是否为后台线程。 </p><p>下面将线程daemon设置为守护线程，让其在main线程结束后结束。这里守护线程设置的是无限循环，按照正常来说，程序会一直运行下去。但是这里将其设置为了守护线程，当其他线程结束后，守护线程也就没有存在的必要了，因此便结束了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Daemon</span>());</span><br><span class="line">        <span class="comment">// setDaemon必须在start之前</span></span><br><span class="line">        daemon.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daemon</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置守护线程无限循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">main:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="4-3-线程睡眠"><a href="#4-3-线程睡眠" class="headerlink" title="4.3 线程睡眠"></a>4.3 线程睡眠</h2><p>观察上面程序的输出结果，可以发现一个很有意思的现象：主线程和守护线程交替执行。这一切的结果都归功于<code>Thread.sleep(100);</code>代码。通过调用<code>Thread</code>的静态方法<code>sleep(long millis)</code>可以让当前正在执行的线程暂停一段时间,并进入阻塞状态，等到达时间后，该线程会转为就绪状态，等待CPU的调度。一个进程调用sleep的状态转换可以用下面的图表示：</p><p><img src="/img/Java%E5%A4%9A%E7%BA%BF%E7%A8%8BThread/image-20220507082429024.png" alt="image-20220507082429024"></p><blockquote><p>在哪个线程里面调用sleep()方法就阻塞哪个线程。</p></blockquote><p>此外, Thread 还提供了一个与sleep()方法有点相似的<code>yield()</code>静态方法,它也可以让当前正在执行的线程礼让其它线程，即将CPU的控制权交给其它线程,<strong>但它不会阻塞该线程,它只是将该线程转入就绪状态</strong> 。即yield()只是让当前线程暂停一下,让系统的线程调度器重新调度一次。“礼让”，不一定会成功，这与系统底层的资源分配有关。 </p><h2 id="4-3-线程优先级"><a href="#4-3-线程优先级" class="headerlink" title="4.3 线程优先级"></a>4.3 线程优先级</h2><p>每个线程执行时都具有一定的优先级,<strong>优先级高的线程获得较多的执行机会</strong>,而优先级低的线程则获得较少的执行机会 。每个线程默认的优先级都与创建它的<strong>父</strong>线程的优先级相同, 在默认情况下 , main线程具有普通优先级。</p><p>可以通过调用Thread对象的<code>setPriority()</code>方法和<code>getPriority()</code>方法来设置和获取<strong>当前</strong>线程的优先级。方法的参数是一个<code>int</code>类型，Thread为其提供了三个静态常量，更<strong>推荐</strong>使用这种方式来设置线程的优先级。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(),<span class="string">&quot;max&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">norm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(),<span class="string">&quot;normal&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">min</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(),<span class="string">&quot;min&quot;</span>);</span><br><span class="line"></span><br><span class="line">        max.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        norm.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        min.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        max.start();</span><br><span class="line">        norm.start();</span><br><span class="line">        min.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-线程同步"><a href="#5-线程同步" class="headerlink" title="5. 线程同步"></a>5. 线程同步</h1><p>当使用多个线程来访问同一个数据时 , 很容易 “偶然” 出现<strong>线程安全</strong>问题 。因为线程调度的不确定性，不能知道共享的数据变量是如何被操作的，可能不会按照程序所预期的顺序来执行，造成数据错误！</p><p>一个典型的案例就是存款取款问题，正常情况下，我们存款取款的顺序为：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 用户登录</span><br><span class="line"><span class="bullet">2.</span> 用户取款</span><br><span class="line"><span class="bullet">3.</span> 系统判断用户账户余额是否大于取款余额</span><br><span class="line"><span class="bullet">4.</span> 如果余额大于取款金额, 则取款成功 ; 如果余额小于取款金额 ,则取款失败。</span><br></pre></td></tr></table></figure><p>但是当多个用户同时取款时，即在多线程并发的情况下，该数据就可能会出现问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafety</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1</span>,<span class="number">100D</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DrawThread</span>(account,<span class="number">70D</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DrawThread</span>(account,<span class="number">50D</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="comment">// 账户id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> Double balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> id,Double balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money&lt;=balance)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;取款成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;现有余额为：&quot;</span>+balance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;取款失败余额不足，现有余额为：&quot;</span>+balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Double drawCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account account,Double drawCount)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.account  = account;</span><br><span class="line">        <span class="built_in">this</span>.drawCount = drawCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        account.draw(drawCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取款成功</span><br><span class="line">取款成功</span><br><span class="line">现有余额为：-<span class="number">20.0</span></span><br><span class="line">现有余额为：-<span class="number">20.0</span></span><br></pre></td></tr></table></figure><p>可见，余额变为了负数！,run()方法的方法体不具有同步安全性一一程序中有两个并发线程在修改 Account 对象，因此造成了数据出现问题。如何解决这个问题呢？</p><p>Java 的多线程引入了<strong>同步监视器</strong>来解决这个问题，包含同步代码块和同步方法，即使用关键字<code>synchronized</code>修饰的代码块称为同步代码块，使用关键字<code>synchronized</code>修饰的方法称为同步方法。在该同步代码块\方法执行期间，该共享资源<strong>只能</strong>被当前线程操作，其它现成无法操作该共享资源，从而保证了数据的安全性。</p><p>任何线程进入同步代码块、同步方法之前,必须先获得对同步监视器的锁定 , 那么何时会释放对同步监视器的锁定呢?   线程会在如下几种情况下遇 到 break 、 retum 终止 了该 代码块 、 该方法的继续 执行 ：</p><ol><li>同步代码块、同步方法正常结束</li><li>同步代码块、同步方法遇到 break 、 retum 终止了该代码块 、该方法的继续执行</li><li>同步代码块、同步方法中出现了未处理的 Error 或 Exception</li><li>程序执行了同步监视器对象的wait()方法</li></ol><blockquote><p>程序调用Thread , sleep() 、 Thread, yield()方法来暂停当前线程的执行,当前线程<strong>不会</strong>释放同步监视器。</p></blockquote><h2 id="6-1-同步代码块"><a href="#6-1-同步代码块" class="headerlink" title="6.1 同步代码块"></a>6.1 同步代码块</h2><p>同步监视器的目的 : 阻止两个线程对同一个共享资源进行并发访问,因此通常<strong>推荐使用可能被并发访问的共享资源充当同步监视器</strong> 。同步代码的语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    同步代码块部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用同步代码块来解决上面的问题，将DrawThread类更改为如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Double drawCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account account,Double drawCount)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.account  = account;</span><br><span class="line">        <span class="built_in">this</span>.drawCount = drawCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 新加代码</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">            account.draw(drawCount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//account.draw(drawCount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行程序，数据错误的情况消失了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取款成功</span><br><span class="line">现有余额为：<span class="number">30.0</span></span><br><span class="line">取款失败余额不足，现有余额为：<span class="number">30.0</span></span><br></pre></td></tr></table></figure><h2 id="6-2-同步方法"><a href="#6-2-同步方法" class="headerlink" title="6.2 同步方法"></a>6.2 同步方法</h2><p>同步方法就是使用<code>synchronized</code>关键字来修饰某个方法,则该方法称为<strong>同步方法</strong>。对于synchronized修饰的实例方法(非static方法)而<br>言,无须显式指定同步监视器 ,<strong>同步方法的同步监视器是 this</strong> ,也就是调用该方法当前对象。 也就是说，<strong>对于含有同步方法的对象, 任意时刻只能</strong><br><strong>有一个线程获得对 该对象的锁定。</strong></p><p>我们使用同步代码块来解决上面的问题，这里不会再修改DrawThread类，而是修改Account类，将其draw()方法更改为同步方法，即使用synchronized修饰该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">draw</span><span class="params">(<span class="type">double</span> money)</span>&#123;………………&#125;</span><br></pre></td></tr></table></figure><p>运行程序，同样结解决了数据不安全问题！</p><h2 id="6-3-同步锁"><a href="#6-3-同步锁" class="headerlink" title="6.3 同步锁"></a>6.3 同步锁</h2><p>从 Java 5 开始, Java 提供了一种功能更强大的线程同步机制一一通过<strong>显式定义</strong>同步锁对象来实现对共享资源的锁定。每次只能有一个线程对 Lock对象加锁,线程开 始访问共享资源之前应先获得 Lock对象，无论是否正常退出，访问完毕后都要解除锁，因此解除锁的操作一般都会放在finally中。</p><blockquote><ol><li>Lcok是显式锁（需要手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁。</li><li>使用Lcok锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的拓展性（提供更多的子类）</li></ol></blockquote><p>在实现线程安全的控制中, 比较常用的是 ReentrantLock (可重 入锁 )。使用该 Lock 对象可以显式地加锁、释放锁:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 在进入临界区之前获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">……</span><br><span class="line">            ……</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无论是否正常结束，都需要释放锁</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用锁机制来解决上面的问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> Double balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> id,Double balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">draw</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(money&lt;=balance)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取款成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                balance -= money;</span><br><span class="line">                System.out.println(<span class="string">&quot;现有余额为：&quot;</span>+balance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取款失败余额不足，现有余额为：&quot;</span>+balance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6-线程通信"><a href="#6-线程通信" class="headerlink" title="6. 线程通信"></a>6. 线程通信</h1><p>很多情况下，尽管我们创建了多个线程，程序通常无法准确控制线程的轮换执行,也会出现几乎一个线程执行完所有操作的时候，这时候我们就需要让线程间相互交流，来保证线程协调运行。</p><h2 id="6-1-问题引入"><a href="#6-1-问题引入" class="headerlink" title="6.1 问题引入"></a>6.1 问题引入</h2><p>我们将会引入一个问题，通过该问题来解决线程通信问题。这是一个经典的线程通信问题：生产者消费者</p><p>假设现在系统中有两个线程 ,这两个线程分别代表生产者和消费者。现在假设系统有一种特殊的要求,系统要求生产者和消费者不断地重复向仓库内放入、取出货物的动作,而且要求每当生产者将货物存入仓库中后,消费者就立即取出货物。 不允许生产者连续放入货物,也不允许消费者连续两次取出货物。 </p><h2 id="6-2-针对synchronized的线程通信机制"><a href="#6-2-针对synchronized的线程通信机制" class="headerlink" title="6.2 针对synchronized的线程通信机制"></a>6.2 针对synchronized的线程通信机制</h2><p>为了实现这种功能,可以借助于<strong>Object</strong> 类提供的 <code>wait()</code> 、 <code>notify()</code>和 <code>notifyAll()</code>三个方法 <strong>。这三个方法并不属于 Thread 类,而是属于 Object 类</strong>，<strong>但这三个方法必须由同步监视器对象来调用</strong> 。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>导致当前线程<strong>等待</strong> , 直到其他线程调用该同步监视器的 notify()方法或 notifyAll()方法来唤醒该线程 。</td></tr><tr><td>notify()</td><td><strong>唤醒</strong>在此同步监视器上等待的<strong>单个</strong>线程 。 如果所有线程都在此同步监视器上等待,则会选择唤醒其中一个线程。</td></tr><tr><td>notifyAll()</td><td><strong>唤醒</strong>在此同步监视器土等待的<strong>所有</strong>线程。</td></tr></tbody></table><p>我们可以为仓库这个“对象”设置一个信号量<code>sign</code>，当仓库内没有货物时值为<code>false</code>，生产者可以向其内放入货物，并将信号量设置为<code>true</code>，表示仓库内含有货物; 当信号量为<code>true</code>时，消费者就可以在仓库内拿取货物，并将sign设置为<code>false</code>，表示仓库内没有货物。这两者之间的通信，我们就使用上面所说的通信机制。</p><p>首先，我们先来创建一个Depository的仓库类，用于存放货物。</p><blockquote><p>需要注意的是，信号量的判断总是应该放在循环中！也就是说，<strong>等待总是需要放在循环中！</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仓库类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depository</span> &#123;</span><br><span class="line">    <span class="comment">// false 代表没有货物</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 注意这里不能使用if进行判断，因为这里的 syn 锁定的不是整个方法，而是this对象！因此总会执行if语句！</span></span><br><span class="line">        <span class="keyword">while</span> (sign) &#123;</span><br><span class="line">           <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:存入货物&quot;</span>);</span><br><span class="line">        count += num;</span><br><span class="line">        sign = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 注意这里不能使用if进行判断，因为这里的 syn 锁定的不是整个方法，而是this对象！因此总会执行if语句！</span></span><br><span class="line">        <span class="keyword">while</span> (!sign)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:取出货物&quot;</span>);</span><br><span class="line">        count -= num;</span><br><span class="line">        sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们创建消费者和生产者线程类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Depository depository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SaveThread</span><span class="params">(Depository depository)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.depository = depository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                depository.save(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Depository depository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Depository depository)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.depository  =depository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                depository.draw(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Depository</span> <span class="variable">depository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depository</span>();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SaveThread</span>(depository),<span class="string">&quot;生产者1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SaveThread</span>(depository),<span class="string">&quot;生产者2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DrawThread</span>(depository),<span class="string">&quot;消费者1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DrawThread</span>(depository),<span class="string">&quot;消费者2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察输入，可以发现，程序总是按照生产者-消费者-生产者的顺序来执行程序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产者<span class="number">1</span>:存入货物</span><br><span class="line">消费者<span class="number">2</span>:取出货物</span><br><span class="line">生产者<span class="number">2</span>:存入货物</span><br><span class="line">消费者<span class="number">1</span>:取出货物</span><br><span class="line">生产者<span class="number">1</span>:存入货物</span><br><span class="line">消费者<span class="number">2</span>:取出货物</span><br><span class="line">生产者<span class="number">2</span>:存入货物</span><br><span class="line">消费者<span class="number">1</span>:取出货物</span><br><span class="line">生产者<span class="number">1</span>:存入货物</span><br></pre></td></tr></table></figure><h2 id="6-3-针对Lock锁的线程通信机制"><a href="#6-3-针对Lock锁的线程通信机制" class="headerlink" title="6.3 针对Lock锁的线程通信机制"></a>6.3 针对Lock锁的线程通信机制</h2><p>如果程序不使用synchronized关键字来保证同步,而是直接使用Lock对象来保证同步,则系统中不存在隐式的同步监视器,也就不能使用wait()、notify()、notifyAll()方法进行线程通信了。<br>那么，当使用Lock对象来保证同步时,Java提供了一个<code>Condition类</code>来保持协调,使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象,Condition对象也可以唤醒其他处于等待的线程。通过condition对象来调用<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法实现线程之间的通信。</p><p>要获得特定Lock实例的Condition 实例 , 调 用 Lock对象的<code>newCondition() </code>方法即可 。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>await()</td><td>类似于隐式同步监视器上的wait()方法,导致当前线程<strong>等待</strong>,直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。</td></tr><tr><td>signal()</td><td><strong>唤醒</strong>在此<strong>Lock对象</strong>上等待的单个线程。</td></tr><tr><td>signalAll()</td><td>唤醒在此Lock对象上等待的所有线程</td></tr></tbody></table><p>我们使用这种方式来实现上面案例中的线程通信：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Depository</span> &#123;</span><br><span class="line">    <span class="comment">// false 代表没有货物</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sign)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:存入货物&quot;</span>);</span><br><span class="line">            count += num;</span><br><span class="line">            sign = <span class="literal">true</span>;</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!sign)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:取出货物&quot;</span>);</span><br><span class="line">            count -= num;</span><br><span class="line">            sign = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-ThreadLocal"><a href="#7-ThreadLocal" class="headerlink" title="7. ThreadLocal"></a>7. ThreadLocal</h1><p><strong>ThreadLocal</strong>,是Thread Local Variable(线程<strong>局部</strong>变量)的意思。 线程局部变量(ThreadLocal)的功用其实非常简单,就是<strong>为每一个使用该变量的线程都提供一个变量值的副本</strong>,<strong>使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突。</strong>从线程的角度看,就好像每一个线程都完全拥有该变量一样<code>ThreadLocal&lt;T&gt;</code>对象仅含有3个方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T get()</td><td>获取此线程局部变量中当前线程副本中的值</td></tr><tr><td>void set(T value)</td><td>删除此线程局部变量中当前线程的值</td></tr><tr><td>void remove()</td><td>设置此线程局部变量中当前线程副本中的值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadLocal.set(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadLocal.set(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadLocal.remove();</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal将需要并发访问的资源复制多份,每个线程拥有一份资源,每个线程都拥有自己的资源副本,从而也就没有必要对该变量进行同步了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -java - thread - 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
