<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL高级篇 | Xcy.小相</title><meta name="keywords" content="sql,mysql"><meta name="author" content="Xcy.小相"><meta name="copyright" content="Xcy.小相"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级篇">
<meta property="og:url" content="http://example.com/article/a63b7bb5.html">
<meta property="og:site_name" content="Xcy.小相">
<meta property="og:description" content="MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png">
<meta property="article:published_time" content="2022-05-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-26T12:55:24.467Z">
<meta property="article:author" content="Xcy.小相">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/article/a63b7bb5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":800,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: Xcy.小相","link":"链接: ","source":"来源: Xcy.小相","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL高级篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-26 20:55:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Xcy.小相" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光机</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于小相</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xcy.小相</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-camera-retro"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光机</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于小相</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL高级篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-19T16:00:00.000Z" title="发表于 2022-05-20 00:00:00">2022-05-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-26T12:55:24.467Z" title="更新于 2022-05-26 20:55:24">2022-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL高级篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p>
<h2 id="1-2-存储引擎简介"><a href="#1-2-存储引擎简介" class="headerlink" title="1.2 存储引擎简介"></a>1.2 存储引擎简介</h2><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的<strong>实现方式</strong>。存储引擎是<strong>基于表</strong>而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是<code>InnoDB</code>，这一点我们可以通过<code>show engines;</code>命令来查看当前数据库所支持的引擎及其相关信息。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220523192015053.png" alt="image-20220523192015053"></p>
<p>也可以在建表时通过<code>engine=引擎名称</code>来指定当前表的引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">	) ENGINE=INNODB;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-InnoDB引擎"><a href="#1-3-InnoDB引擎" class="headerlink" title="1.3 InnoDB引擎"></a>1.3 InnoDB引擎</h2><p>InnoDB 是一种兼顾<strong>高可靠性</strong>和<strong>高性能</strong>的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是<strong>默认</strong>的 MySQL 引擎。它具有如下<strong>特点</strong>：</p>
<ol>
<li><p>DML 操作遵循 ACID 模型，支持<strong>事务</strong></p>
</li>
<li><p><strong>行级锁</strong>，提高并发访问性能</p>
</li>
<li><p>支持<strong>外键</strong>约束，保证数据的完整性和正确性</p>
<p>InnoDB 引擎的每张表都会对应一个<code>xxx.ibd</code>表空间文件，存储该表的<strong>表结构</strong>（frm、sdi）、<strong>数据</strong>和<strong>索引</strong>。通过<code>show variables like &#39;datadir&#39;</code>命令，我们可以查看当前数据库的数据存放位置为<code>/var/lib/mysql/</code>。可以看到每一个数据库都对应着一个文件夹，每个数据表对应这一个<code>.idb</code>文件。<img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220523200421002.png" alt="image-20220523200421002"></p>
</li>
</ol>
<p>通过命令<code>ibd2sdi xxx.ibd</code>可以从查看idb文件的<strong>表结构</strong>数据。</p>
<p>参数<code>innodb_file_per_table</code>，决定多张表共享一个表空间还是每张表对应一个表空间。通过如下命令查看，可知，<strong>mysql默认是每张表对应一个表空间的。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220523195111151.png" alt="image-20220523195111151"></p>
<p>InnoDB 逻辑存储结构：<br><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p>
<ul>
<li><code>表空间</code> : InnoDB存储引擎逻辑结构的最高层,<strong>ibd文件其实就是表空间文件</strong>,在表空间中可以包含多个Segment段。</li>
<li><code>段</code> : <strong>表空间是由多个段组成</strong>的, 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理,都是引擎自身完成,不需要人为对其控制,一个段中包含多个区。</li>
<li><code>区</code> : 区是表空间的单元结构,每个区的大小为1M。 默认情况下, InnoDB存储引擎页大小为16K, 即<strong>一个区中一共有64个连续的页</strong>。</li>
<li><code>页</code> : 页是组成区的最小单元,<strong>页也是InnoDB 存储引擎磁盘管理的最小单元</strong>,每个页的大小默认为 16KB。为了保证页的连续性,InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li><code>行</code> : InnoDB 存储引擎是面向行的,也就是说<strong>数据是按行进行存放的</strong>,在每一行中除了定义表时所指定的字段以外,还包含两个隐藏字段(后面会详细介绍)。</li>
</ul>
<h2 id="1-4-MyISAM引擎"><a href="#1-4-MyISAM引擎" class="headerlink" title="1.4 MyISAM引擎"></a>1.4 MyISAM引擎</h2><p>MyISAM 是 MySQL 早期的默认存储引擎。具有如下<strong>特点</strong>：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li><code>xxx.sdi</code>: 存储表结构信息</li>
<li><code>xxx.MYD</code>: 存储数据</li>
<li><code>xxx.MYI</code>: 存储索引</li>
</ul>
<h2 id="1-5-Memory引擎"><a href="#1-5-Memory引擎" class="headerlink" title="1.5 Memory引擎"></a>1.5 Memory引擎</h2><p>Memory 引擎的表数据是存储在<strong>内存</strong>中的，受硬件问题、断电问题的影响，只能将这些表作为<strong>临时表或缓存</strong>使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li><strong>hash索引（默认）</strong></li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h2 id="1-6-存储引擎特点对比"><a href="#1-6-存储引擎特点对比" class="headerlink" title="1.6 存储引擎特点对比"></a>1.6 存储引擎特点对比</h2><table>
<thead>
<tr>
<th>特点</th>
<th><code>InnoDB</code></th>
<th><code>MyISAM</code></th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>&#x3D;&#x3D;支持&#x3D;&#x3D;</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>&#x3D;&#x3D;行锁&#x3D;&#x3D;</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>&#x3D;&#x3D;支持&#x3D;&#x3D;</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>面试题：InnoDB与MyISAM引擎的区别</strong>：</p>
<p>在早期，mysql使用MyISAM作为默认引擎，后期改为使用InnoDB作为默认引擎。我们可以通过<code>show engines</code>命令开查看所有引擎的相关信息。其中<code>InnoDB</code>的comment中有这么一段话:”&#x3D;&#x3D;Supports transactions, row-level locking, and foreign keys&#x3D;&#x3D;”。这也是两者的主要区别。详细见： <a href="MySQL%E9%9D%A2%E8%AF%95%E9%A2%98-MySAM%E4%B8%8EInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB.md">MySQL面试题-MySAM与InnoDB的区别.md</a> </p>
</blockquote>
<h2 id="1-7-存储引擎的选择"><a href="#1-7-存储引擎的选择" class="headerlink" title="1.7 存储引擎的选择"></a>1.7 存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li><p><code>InnoDB</code>: 如果应用对<code>事务</code>的完整性有比较高的要求，在<strong>并发</strong>条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择。<strong>常用于存储业务系统中的核心数据。</strong></p>
</li>
<li><p><code>MyISAM</code>: 如果应用是<strong>以读操作和插入操作为主</strong>，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的，如日志、评论等表结构。而这种存储类型，可以使用<strong>MongDB</strong>来进行替代。</p>
<pre><code>Innodb：frm是表定义文件，ibd是数据文件

Myisam：frm是表定义文件，myd是数据文件，myi是索引文件
</code></pre>
</li>
<li><p><code>Memory</code>: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。这种存储要求可以使用<strong>Redis</strong>来替代。</p>
</li>
</ul>
<h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h1><p><strong>索引</strong>是帮助 MySQL <strong>高效获取数据</strong>的**<code>数据结构（有序）</code>**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。索引具有以下的优缺点：</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索效率，降低数据库的IO成本</td>
<td>索引列也是要占用空间的</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td>
<td>索引大大提高了<strong>查询</strong>效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE。</td>
</tr>
</tbody></table>
<p>在这一部分，我们将会了解以下内容。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526205514414.png" alt="image-20220526205514414">&#96;</p>
<h2 id="2-1-索引结构"><a href="#2-1-索引结构" class="headerlink" title="2.1 索引结构"></a>2.1 索引结构</h2><p>MySQL的<strong>索引是在存储引擎层实现</strong>的,不同的存储引擎有不同的索引结构,<strong>默认指的B+树结构组织的索引</strong>。主要包含以下几种:</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;B+Tree&#x3D;&#x3D;</td>
<td><strong>最常见</strong>的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，<strong>不支持范围查询</strong></td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody></table>
<p>不同的存储引擎对于<strong>索引结构</strong>的支持情况也有所不同：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;B+Tree索引&#x3D;&#x3D;</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>&#x3D;&#x3D;支持&#x3D;&#x3D;</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="2-1-1-B-Tree"><a href="#2-1-1-B-Tree" class="headerlink" title="2.1.1 B-Tree"></a>2.1.1 B-Tree</h3><p>B-Tree,B树是一种<strong>多叉路</strong><code>平衡</code>查找树,相对于二叉树,B树每个节点可以有多个分支,即多叉。<br>以一颗最大度数(max-degree)为<code>5</code>(5阶)的b-tree为例,那这个B树每个节点最多存储<code>4个key</code>,<code>5 个指针</code>。在B树中,<strong>非叶子节点和叶子节点都会存放数据</strong>。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p>
<blockquote>
<p>B-Tree 的数据插入过程动画参照：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
</blockquote>
<p>依次插入一组数据 <code>100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250</code> 。然后观察一些数据插入过程中,节点的变化情况。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220524185600964.png" alt="image-20220524185600964"></p>
<p>我们选择的是一个最大阶数为5的B树，因此其每一个节点<strong>最多存储4个key（存储数据）,对应5个指针（指向子节点）</strong>。一旦节点存储的key数量到达5,就会立刻发生裂变,<strong>中间元素（包含新加的第五个key）</strong>向上分裂。</p>
<h3 id="2-1-2-B-Tree"><a href="#2-1-2-B-Tree" class="headerlink" title="2.1.2 B+Tree"></a>2.1.2 B+Tree</h3><p>B+Tree是B-Tree的变种。与 B-Tree相比,主要有以下三点区别：</p>
<ol>
<li><strong>所有的数据都会保存在叶子节点</strong>，非叶子节点仅仅起到索引数据作用,具体的数据都是在叶子节点存放的。</li>
<li>叶子节点形成一个<strong>单向</strong>链表。</li>
</ol>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p>
<blockquote>
<p>演示地址：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
</blockquote>
<h3 id="2-1-3-MySQL优化的B-树"><a href="#2-1-3-MySQL优化的B-树" class="headerlink" title="2.1.3 MySQL优化的B+树"></a>2.1.3 MySQL优化的B+树</h3><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，<strong>增加一个指向相邻叶子节点的链表指针</strong>，即<strong>由原先的单链表变成了双链表</strong>，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p>
<h3 id="2-1-4-Hash"><a href="#2-1-4-Hash" class="headerlink" title="2.1.4 Hash"></a>2.1.4 Hash</h3><p>MySQL中除了支持B+Tree索引,还支持一种索引类型—Hash索引。<strong>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的存储槽位上，然后存储在hash表中。</strong>所以，当使用hash查找数据时，只需要通过hash算法计算其key，就可以直接得到其存储位置，效率极高！</p>
<p>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过<strong>链表</strong>来解决。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p>
<p><strong>特点：</strong></p>
<ul>
<li>Hash索引只能用于<strong>对等比较</strong>（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li>
<li>无法利用索引完成排序操作</li>
<li><strong>查询效率高</strong>，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li>
</ul>
<p>在MySQL中,<strong>支持hash索引的是Memory存储引擎。</strong> 而InnoDB中具有自适应hash功能,hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下<strong>自动</strong>构建的。</p>
<blockquote>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><strong>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</strong></p>
<ul>
<li>相对于二叉树，<strong>层级更少，搜索效率高</strong>。</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作。</li>
</ul>
</blockquote>
<h2 id="2-2-索引分类"><a href="#2-2-索引分类" class="headerlink" title="2. 2 索引分类"></a>2. 2 索引分类</h2><p>在MySQL数据库,将索引的具体类型主要分为以下<strong>4类</strong>:主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td><code>主键索引</code></td>
<td>针对于表中主键创建的索引</td>
<td>默认<strong>自动创建</strong>，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td><code>唯一索引</code></td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td><code>常规索引</code></td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td><code>全文索引</code></td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在 <strong>InnoDB 存储引擎</strong>中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放一块，索引结构的<strong>叶子节点保存了行数据</strong>。</td>
<td><strong>必须有，而且只有一个</strong></td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的<strong>叶子节点关联的是对应的主键</strong>。又称为辅助索引。</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ol>
<li><p>如果存在主键，<strong>主键索引</strong>就是聚集索引</p>
</li>
<li><p>如果不存在主键，将使用<strong>第一个非空唯一(UNIQUE)索引</strong>作为聚集索引</p>
</li>
<li><p>如果表没有主键或没有合适的唯一索引，则 InnoDB 会<strong>自动生成一个 rowid</strong> 作为隐藏的聚集索引</p>
</li>
</ol>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"></p>
<p>如查询语句<code>select * from user where name = Arm</code>这一语句的查询过程如下。这一过程也称为<strong>回表查询</strong>：</p>
<ol>
<li>根据二级索引的跟节点和<code>Arm</code>对比，Arm位于Lee之前，跳转到其由最左侧的子节点</li>
<li>字节点的索引<code>Gee</code>和<code>Arm</code>对比，Arm仍然位于Gee之前，跳转到其最左侧的字节点</li>
<li>找到了<code>Arm</code>索引，获取到Arm的聚集索引。</li>
<li>根据聚集索引的值，按照B+树的规则寻找其对应的<strong>行数据</strong>。</li>
</ol>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220524194913619.png" alt="image-20220524194913619"></p>
<blockquote>
<h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p><strong>1. 以下 SQL 语句，哪个执行效率高？为什么？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>

<p>答：第一条语句，因为<strong>第二条需要回表查询</strong>，相当于两个步骤。</p>
<p><strong>2. InnoDB 主键索引的 B+Tree 高度为多少？</strong></p>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>数据量 = n * 8 + (n + 1) * 6 </code>，其中 ，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。 </p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code></p>
</blockquote>
<h2 id="2-3-索引语法"><a href="#2-3-索引语法" class="headerlink" title="2.3 索引语法"></a>2.3 索引语法</h2><h3 id="2-3-1-创建索引"><a href="#2-3-1-创建索引" class="headerlink" title="2.3.1 创建索引"></a>2.3.1 创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] index 索引名称 <span class="keyword">on</span> 表名 (字段<span class="number">1</span>, ...);</span><br></pre></td></tr></table></figure>

<p>若不指定索引类型，则默认是常规索引。当使用多个字段作为索引时，这个索引就被称为<code>联合索引</code>。数据会先按照联合索引的第一个值进行“排序”，若第一个相同，则按照第二个值进行排序……</p>
<ul>
<li><p><code>单列索引</code>：即一个索引只包含单个列</p>
</li>
<li><p><code>联合索引</code>：即一个索引包含了多个列</p>
</li>
</ul>
<p>在业务场景中，如果<strong>存在多个查询条件</strong>，考虑针对于查询字段建立索引时，建议<strong>建立联合索引</strong>，而非单列索引。当使用多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</p>
<h3 id="2-3-2-查看索引"><a href="#2-3-2-查看索引" class="headerlink" title="2.3.2 查看索引"></a>2.3.2 查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名；</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-删除索引"><a href="#2-3-3-删除索引" class="headerlink" title="2.3.3 删除索引"></a>2.3.3 删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> 表名;</span><br></pre></td></tr></table></figure>

<p>我们通过一个小案例来熟悉一下语法。通通过下面的语句来创建一个数据库表，并根据要求创建合适的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">phone <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">100</span>) comment <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">profession <span class="type">varchar</span>(<span class="number">11</span>) comment <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line">age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别 , 1: 男, 2: 女&#x27;</span>,</span><br><span class="line">status <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">createtime datetime comment <span class="string">&#x27;创建时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;系统用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查看默认索引</span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 2.为name 字段创建一个索引，注意 name字段可以重复</span><br><span class="line">create index  idx_user_name on tb_user(name);</span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 3.为phone字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user(phone);</span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 4.为profession 、age、status 创建联合索引</span><br><span class="line">create index tb_user_idx_profession_age_satus on tb_user(profession,age,status);</span><br><span class="line">show index from tb_user;</span><br><span class="line"></span><br><span class="line">-- 5.为email 建立合适的索引来提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line">show index from tb_user;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h2><h3 id="2-4-1-查看执行频次"><a href="#2-4-1-查看执行频次" class="headerlink" title="2.4.1 查看执行频次"></a>2.4.1 查看执行频次</h3><p>MySQL 客户端连接成功后,通过 <code>show [session|global] status;</code> 命令可以查看服务器状态信息。通过如下指令可以查看当前数据库的<code>INSERT、UPDATE、DELETE、SELECT</code>的使用频次：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span><span class="operator">/</span>session status <span class="keyword">like</span> ‘Com_______(<span class="number">7</span>个下划线)’;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>global 表示查询全局</li>
<li>session表示仅查询当前会话</li>
</ul>
</blockquote>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220525101945665.png" alt="image-20220525101945665"></p>
<p>通过上述指令,我们可以查看到<strong>当前数据库到底是以查询为主,还是以增删改为主</strong>,从而为数据库优化提供参考依据。 如果是以增删改为主,我们可以考虑不对其进行索引的优化。 如果是<strong>以查询为主,那么就要考虑对数据库的索引进行优化了</strong>。</p>
<h3 id="2-4-2-查看慢查询日志"><a href="#2-4-2-查看慢查询日志" class="headerlink" title="2.4.2 查看慢查询日志"></a>2.4.2 查看慢查询日志</h3><p>慢查询日志记录了所有执行时间<strong>超过</strong>指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志，从而能够知道哪些sql执行时间长，从而进行优化。可以通过<code>show variables like &#39;slow_query_log&#39;;</code>语句来查看MySQL的慢查询日志是否开启（<strong>默认没有开启</strong>），若要开启则需要在MySQL的配置文件（<code>/etc/mysql/my.cnf</code>）中配置如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>配置完毕后，需要<strong>重启</strong>MySQL服务，日志文件位于<code>/var/lib/mysql/****-slow.log</code>。</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220525104452813.png" alt="image-20220525104452813"></p>
<h3 id="2-4-3-查看详情"><a href="#2-4-3-查看详情" class="headerlink" title="2.4.3 查看详情"></a>2.4.3 查看详情</h3><p><code>show profile</code> 能在做SQL优化时帮我们了解SQL语句执行时间都耗费在哪里。通过 <code>have_profiling</code> 参数，能看到当前 MySQL 是否支持 profile 操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@have</span>_profiling <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> YES              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br></pre></td></tr></table></figure>

<p>profiling 默认关闭，我们可以通过set语句在<code>session/global</code>级别开启 profiling：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>开启profilling后，我们就可以通过如下指令查看指令的执行耗时:</p>
<ul>
<li>查看所有语句的耗时：<br><code>show profiles;</code></li>
<li>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code></li>
<li>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></li>
</ul>
<h3 id="2-4-4-explain"><a href="#2-4-4-explain" class="headerlink" title="2.4.4 explain"></a>2.4.4 explain</h3><p><code>explain </code>或者 <code>desc</code>命令用于获取 <strong>MySQL 如何执行 <code>SELECT</code> 语句的信息</strong>,包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain<span class="operator">/</span><span class="keyword">desc</span> <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<p>  如查询语句<code>explain select * from tb_user where id =1;</code>的结果如下：<img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220525163429112.png" alt="image-20220525163429112"></p>
<p>EXPLAIN 各字段含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>表示查询中执行 select 子句或者<strong>操作表的顺序</strong>。id相同，执行顺序<strong>从上到下</strong>；id不同，值越<strong>大</strong>越<strong>先</strong>执行。</td>
<td></td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型。常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td>
<td></td>
</tr>
<tr>
<td><code>type</code></td>
<td>表示连接类型，性能<strong>由好到差</strong>的连接类型为 NULL、system、const（使用主键或唯一索引时的等级）、eq_ref、ref（使用非唯一性索引时的等级）、range、index、all</td>
<td></td>
</tr>
<tr>
<td><code>possible_key</code></td>
<td>可能应用在这张表上的索引，一个或多个</td>
<td></td>
</tr>
<tr>
<td><code>Key</code></td>
<td>实际使用的索引，如果为 NULL，则没有使用索引</td>
<td></td>
</tr>
<tr>
<td><code>Key_len</code></td>
<td><strong>表示索引中使用的字节数</strong>，该值为索引字段最大可能长度，并非实际使用长度，<strong>在不损失精确性的前提下，长度越短越好</strong>。</td>
<td></td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个<strong>估计值</strong>，可能并不总是准确的</td>
<td></td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。过滤掉的越少，占比也就越大，无用查询也就越少，效率就越高。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-4-索引使用"><a href="#2-4-索引使用" class="headerlink" title="2.4 索引使用"></a>2.4 索引使用</h2><h3 id="2-4-1-最左前缀法则"><a href="#2-4-1-最左前缀法则" class="headerlink" title="2.4.1 最左前缀法则"></a>2.4.1 最左前缀法则</h3><p>如果索引关联了多列（<strong>联合索引</strong>），就要遵守最左前缀法则，<strong>最左前缀法则指的是<code>查询</code>必须从索引的最左列开始（查询的索引条件存在即可，无关顺序），并且不跳过索引中的列</strong>，否则将会导致<strong>跳过的索引以及之后的索引</strong>失效。</p>
<p>如使用如下语句查询<code>tb_user</code>表，索引<code>tb_user_idx+profession_age_status</code>生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where profession=&#x27;软件工程&#x27;   and age=23 and status=6;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526091136057.png" alt="image-20220526091136057"></p>
<p>当我们将查询语句改为如下时，会发现索引<code>tb_user_idx+profession_age_status</code>仍然生效，但是<code>key_len</code>长度却变小了。这是因为查询是从最索引的最左列开始，但是<strong>中间却跳过了一条索引</strong>，因此导致<strong>跳过的索引以及之后的索引</strong>失效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526091530031.png" alt="image-20220526091530031"></p>
<blockquote>
<p>注意 : 最左前缀法则中指的最左边的列,是指在查询时,联合索引的最左边的字段(即是第一个字段)<strong>必须存在</strong>,与我们编写SQL时的条件编写的<strong>先后顺序无关</strong>。</p>
</blockquote>
<h3 id="2-4-2-范围查询"><a href="#2-4-2-范围查询" class="headerlink" title="2.4.2 范围查询"></a>2.4.2 范围查询</h3><p>联合索引中，若出现范围查询（&lt;, &gt;），范围查询条件<strong>之后</strong>的的列索引失效。<strong>可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526093512001.png" alt="image-20220526093512001"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;6&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526093532221.png" alt="image-20220526093532221"></p>
<h3 id="2-4-3-索引失效情况"><a href="#2-4-3-索引失效情况" class="headerlink" title="2.4.3 索引失效情况"></a>2.4.3 索引失效情况</h3><ol>
<li><p><strong>在索引列上进行运算操作</strong>，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></p>
</li>
<li><p>字符串类型字段使用时，<strong>不加引号</strong>，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</p>
</li>
<li><p>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是<strong>头部模糊匹配</strong>，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526094858383.png" alt="image-20220526094858383"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526094923680.png" alt="image-20220526094923680"></p>
<blockquote>
<p>各大搜索引擎的搜索也是采用的尾部模糊查询，因为这样可以使得索引生效，提高效率。 </p>
</blockquote>
</li>
<li><p><strong>用 or 分割开的条件，如果 or 其中一个条件的列没有索引</strong>，那么涉及的索引<strong>都</strong>不会被用到。</p>
</li>
<li><p>如果 MySQL <strong>评估</strong>使用索引比全表更慢，则不使用索引。</p>
</li>
</ol>
<h3 id="2-4-4-SQL-提示"><a href="#2-4-4-SQL-提示" class="headerlink" title="2.4.4 SQL 提示"></a>2.4.4 SQL 提示</h3><p>SQL提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些<strong>人为的提示</strong>来达到优化操作的目的。常用方法如下：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>use index()</td>
<td>建议MySQL<strong>使用</strong>哪个索引，该建议MySQL可能不接受</td>
<td><code>explain select * from tb_user use index(idx_user_profession) where profession=&#39;软件工程&#39;;</code></td>
</tr>
<tr>
<td>ignore index()</td>
<td>指定<strong>不使用</strong>哪个索引</td>
<td><code>explain select * from tb_user ignore index(idx_user_profession) where profession=&#39;软件工程&#39;;</code></td>
</tr>
<tr>
<td>force index()</td>
<td><strong>强制</strong>必须使用哪个索引</td>
<td><code>explain select * from tb_user force index(idx_user_profession) where profession=&#39;软件工程&#39;;</code></td>
</tr>
</tbody></table>
<p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p>
<p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p>
<h3 id="2-4-5-覆盖索引-amp-回表查询"><a href="#2-4-5-覆盖索引-amp-回表查询" class="headerlink" title="2.4.5 覆盖索引&amp;回表查询"></a>2.4.5 覆盖索引&amp;回表查询</h3><p>覆盖索引是指查询过程中使用了索引，且<strong>需要返回的列（<code>select后要查询的列</code>）在该索引中全部能够找到</strong> 。尽量要使用覆盖索引，减少 <code>select *</code>的使用。</p>
<p>前面我们对<code>tb_user</code>表创建了一个联合索引<code>tb_user_idx_profession_age_satus</code>。这里我们使用<code>select</code>查询不同的字段，查看其详细信息：</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526165039780.png" alt="image-20220526165039780"></p>
<p>可以发现，当查询的字段在联合索引范围内时，<code>extra</code>的内容为<code>using where; using index；</code>;当查询的字段有不在联合索引范围内时，<code>extra</code>的内容为<code>using index condition</code>。使用<code>explain</code>关键字查询出来的数据中<code>extra </code>字段的含义如下：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>using index condition</code></td>
<td>查找使用了索引，但是需要<strong>回表</strong>查询数据。</td>
</tr>
<tr>
<td><code>using where; using index；</code></td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，<strong>不需要</strong>回表查询。</td>
</tr>
</tbody></table>
<p>这是因为,在tb_user表中有一个<code>联合索引 idx_user_pro_age_sta</code>,<strong>该索引关联了三个字段profession、age、status</strong>,而这个索引也是一个<strong>二级索引</strong>,所以叶子节点下面挂的是这一行的主键id：</p>
<ol>
<li><p>当我们查询返回的数据在 id、profession、age、status 之中,则<strong>直接走二级索引直接返回数据</strong>了。 </p>
</li>
<li><p>如果超出这个范围,就<strong>需要拿到主键id,<strong>再去</strong>扫描聚集索引</strong>获取额外的数据,这个过程就是回表查询。</p>
</li>
</ol>
<p><strong>因此尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段。</strong></p>
<blockquote>
<p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p>
<p>解：给<strong>username和password字段建立联合索引</strong>，则不需要回表查询，直接覆盖索引</p>
</blockquote>
<h3 id="2-4-6-前缀索引"><a href="#2-4-6-前缀索引" class="headerlink" title="2.4.6 前缀索引"></a>2.4.6 前缀索引</h3><p>当字段类型为字符串（varchar, text等）时，<strong>有时候需要索引<code>很长</code>的字符串，这会让索引变得很大</strong>，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名(字段(要截取的前缀长度));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>前缀长度</code>：可以根据索引的<strong>选择性</strong>来决定，而<strong>选择性是指 不重复的索引数 和 数据表的记录总数 的比值</strong>，索引选择性越高则查询效率越高，最高为<code>1</code>。</p>
</li>
<li><p>求选择性公式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(字段, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一个前缀索引的查询流程如下：</p>
<p><img src="/img/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20220526195139878.png" alt="image-20220526195139878"></p>
<blockquote>
<p>当查询到数据后，还需要从查询到的数据内取出<code>email</code>的值和where条件进行对比，无误后才会返回数据。</p>
</blockquote>
<h3 id="2-4-7-单列索引-amp-联合索引"><a href="#2-4-7-单列索引-amp-联合索引" class="headerlink" title="2.4.7 单列索引&amp;联合索引"></a>2.4.7 单列索引&amp;联合索引</h3><ul>
<li><code>	单列索引</code>：即一个索引只包含单个列</li>
<li><code>联合索引</code>：即一个索引包含了多个列<br>在业务场景中，如果<strong>存在多个查询条件</strong>，考虑针对于查询字段建立索引时，建议<strong>建立联合索引</strong>，而非单列索引。当使用多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li>
</ul>
<h2 id="2-5-设计原则"><a href="#2-5-设计原则" class="headerlink" title="2.5 设计原则"></a>2.5 设计原则</h2><ol>
<li>针对于<strong>数据量较大</strong>，且<strong>查询比较频繁</strong>的表建立索引。</li>
<li>针对于<strong>常作为查询条件（<code>where</code>）、排序（<code>order by</code>）、分组（<code>group by</code>）操作的字段</strong>建立索引。</li>
<li>尽量选择<strong>区分度高的列作为索引</strong>，即尽量建立<strong>唯一</strong>索引，区分度越高索引的效率越高。</li>
<li>如果是字符串类型的字段，<strong>字段长度较长</strong>，可以针对于字段的特点，<strong>建立前缀索引</strong>。</li>
<li><strong>尽量使用联合索引</strong>，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要<strong>控制索引的数量</strong>，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率。</li>
<li><strong>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。</strong>当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<h1 id="4-SQL-优化"><a href="#4-SQL-优化" class="headerlink" title="4. SQL 优化"></a>4. SQL 优化</h1><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p>
<ol>
<li>采用批量插入（一次插入的数据不建议超过1000条）</li>
<li>手动提交事务</li>
<li>主键顺序插入</li>
</ol>
<p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p>
<p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p>
<blockquote>
<p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p>
</blockquote>
<p>主键设计原则：</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li>
<li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ol>
<p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p>
<p>总结：</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li>
<li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li>
</ul>
<h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ul>
<p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 此语句耗时很长</span><br><span class="line">select * from tb_sku limit 9000000, 10;</span><br><span class="line">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="line">select id from tb_sku order by id limit 9000000, 10;</span><br><span class="line">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span><br><span class="line">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="line">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="line">select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;</span><br></pre></td></tr></table></figure>

<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p>
<p>count的几种用法：</p>
<ul>
<li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li>
<li>用法：count(*)、count(主键)、count(字段)、count(1)</li>
<li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li>
</ul>
<p>各种用法的性能：</p>
<ul>
<li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li>
<li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li>
<li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li>
</ul>
<p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p>
<h3 id="update优化（避免行锁升级为表锁）"><a href="#update优化（避免行锁升级为表锁）" class="headerlink" title="update优化（避免行锁升级为表锁）"></a>update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Xcy.小相</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/article/a63b7bb5.html">http://example.com/article/a63b7bb5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Xcy.小相</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a><a class="post-meta__tags" href="/tags/sql/">sql</a></div><div class="post_share"><div class="social-share" data-image="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/337fcc87.html"><img class="prev-cover" src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL基础篇</div></div></a></div><div class="next-post pull-right"><a href="/article/8d2c916c.html"><img class="next-cover" src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430213550615.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE|Java网络编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/749ae3a4.html" title="MySQL|SQL数据定义"><img class="cover" src="/img/PythonPython%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8F/image-20220505225318787.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-07</div><div class="title">MySQL|SQL数据定义</div></div></a></div><div><a href="/article/7647f2b.html" title="MySQL数据库设计"><img class="cover" src="/img/PythonPython%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8F/image-20220505225318787.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-08</div><div class="title">MySQL数据库设计</div></div></a></div><div><a href="/article/bf7316f5.html" title="MySQL面试题|MySAM与InnoDB的区别"><img class="cover" src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-23</div><div class="title">MySQL面试题|MySAM与InnoDB的区别</div></div></a></div><div><a href="/article/337fcc87.html" title="MySQL基础篇"><img class="cover" src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-20</div><div class="title">MySQL基础篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xcy.小相</div><div class="author-info__description">远赴人间惊鸿宴，一睹人间盛世颜</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xcyxiaoxiang"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到xcy.小相的个人博客空间，在这里，享受时光，分享技术！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">1. 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1.1 MySQL体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B"><span class="toc-text">1.2 存储引擎简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-InnoDB%E5%BC%95%E6%93%8E"><span class="toc-text">1.3 InnoDB引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-MyISAM%E5%BC%95%E6%93%8E"><span class="toc-text">1.4 MyISAM引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Memory%E5%BC%95%E6%93%8E"><span class="toc-text">1.5 Memory引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-text">1.6 存储引擎特点对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">1.7 存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-B-Tree"><span class="toc-text">2.1.1 B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-B-Tree"><span class="toc-text">2.1.2 B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-MySQL%E4%BC%98%E5%8C%96%E7%9A%84B-%E6%A0%91"><span class="toc-text">2.1.3 MySQL优化的B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-Hash"><span class="toc-text">2.1.4 Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">2. 2 索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-text">面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-text">2.3 索引语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">2.3.1 创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">2.3.2 查看索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">2.3.3 删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2.4 性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1"><span class="toc-text">2.4.1 查看执行频次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">2.4.2 查看慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85"><span class="toc-text">2.4.3 查看详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-explain"><span class="toc-text">2.4.4 explain</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-text">2.4 索引使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-text">2.4.1 最左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.4.2 范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-text">2.4.3 索引失效情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-SQL-%E6%8F%90%E7%A4%BA"><span class="toc-text">2.4.4 SQL 提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-amp-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.4.5 覆盖索引&amp;回表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-text">2.4.6 前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-amp-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">2.4.7 单列索引&amp;联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">2.5 设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-SQL-%E4%BC%98%E5%8C%96"><span class="toc-text">4. SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="toc-text">order by优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by%E4%BC%98%E5%8C%96"><span class="toc-text">group by优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96%EF%BC%88%E9%81%BF%E5%85%8D%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81%EF%BC%89"><span class="toc-text">update优化（避免行锁升级为表锁）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/bf7316f5.html" title="MySQL面试题|MySAM与InnoDB的区别"><img src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL面试题|MySAM与InnoDB的区别"/></a><div class="content"><a class="title" href="/article/bf7316f5.html" title="MySQL面试题|MySAM与InnoDB的区别">MySQL面试题|MySAM与InnoDB的区别</a><time datetime="2022-05-23T02:20:30.000Z" title="发表于 2022-05-23 10:20:30">2022-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/337fcc87.html" title="MySQL基础篇"><img src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL基础篇"/></a><div class="content"><a class="title" href="/article/337fcc87.html" title="MySQL基础篇">MySQL基础篇</a><time datetime="2022-05-19T16:00:00.000Z" title="发表于 2022-05-20 00:00:00">2022-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/a63b7bb5.html" title="MySQL高级篇"><img src="/img/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/image-20220520183647583.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL高级篇"/></a><div class="content"><a class="title" href="/article/a63b7bb5.html" title="MySQL高级篇">MySQL高级篇</a><time datetime="2022-05-19T16:00:00.000Z" title="发表于 2022-05-20 00:00:00">2022-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/8d2c916c.html" title="JavaSE|Java网络编程"><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430213550615.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaSE|Java网络编程"/></a><div class="content"><a class="title" href="/article/8d2c916c.html" title="JavaSE|Java网络编程">JavaSE|Java网络编程</a><time datetime="2022-05-05T04:20:30.000Z" title="发表于 2022-05-05 12:20:30">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/19cd5c15.html" title="Linux|记一次裸机安装Ubuntu的过程"><img src="/img/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A3%B8%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%E7%9A%84%E8%BF%87%E7%A8%8B/image-20220430213550615.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux|记一次裸机安装Ubuntu的过程"/></a><div class="content"><a class="title" href="/article/19cd5c15.html" title="Linux|记一次裸机安装Ubuntu的过程">Linux|记一次裸机安装Ubuntu的过程</a><time datetime="2022-04-28T16:00:00.000Z" title="发表于 2022-04-29 00:00:00">2022-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Xcy.小相</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">越努力越幸运</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>